"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/modern-screenshot";
exports.ids = ["vendor-chunks/modern-screenshot"];
exports.modules = {

/***/ "(ssr)/./node_modules/modern-screenshot/dist/index.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/modern-screenshot/dist/index.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createContext: () => (/* binding */ createContext),\n/* harmony export */   destroyContext: () => (/* binding */ destroyContext),\n/* harmony export */   domToBlob: () => (/* binding */ domToBlob),\n/* harmony export */   domToCanvas: () => (/* binding */ domToCanvas),\n/* harmony export */   domToDataUrl: () => (/* binding */ domToDataUrl),\n/* harmony export */   domToForeignObjectSvg: () => (/* binding */ domToForeignObjectSvg),\n/* harmony export */   domToImage: () => (/* binding */ domToImage),\n/* harmony export */   domToJpeg: () => (/* binding */ domToJpeg),\n/* harmony export */   domToPixel: () => (/* binding */ domToPixel),\n/* harmony export */   domToPng: () => (/* binding */ domToPng),\n/* harmony export */   domToSvg: () => (/* binding */ domToSvg),\n/* harmony export */   domToWebp: () => (/* binding */ domToWebp),\n/* harmony export */   loadMedia: () => (/* binding */ loadMedia),\n/* harmony export */   waitUntilLoad: () => (/* binding */ waitUntilLoad)\n/* harmony export */ });\nfunction changeJpegDpi(uint8Array, dpi) {\n  uint8Array[13] = 1;\n  uint8Array[14] = dpi >> 8;\n  uint8Array[15] = dpi & 255;\n  uint8Array[16] = dpi >> 8;\n  uint8Array[17] = dpi & 255;\n  return uint8Array;\n}\n\nconst _P = \"p\".charCodeAt(0);\nconst _H = \"H\".charCodeAt(0);\nconst _Y = \"Y\".charCodeAt(0);\nconst _S = \"s\".charCodeAt(0);\nlet pngDataTable;\nfunction createPngDataTable() {\n  const crcTable = new Int32Array(256);\n  for (let n = 0; n < 256; n++) {\n    let c = n;\n    for (let k = 0; k < 8; k++) {\n      c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;\n    }\n    crcTable[n] = c;\n  }\n  return crcTable;\n}\nfunction calcCrc(uint8Array) {\n  let c = -1;\n  if (!pngDataTable)\n    pngDataTable = createPngDataTable();\n  for (let n = 0; n < uint8Array.length; n++) {\n    c = pngDataTable[(c ^ uint8Array[n]) & 255] ^ c >>> 8;\n  }\n  return c ^ -1;\n}\nfunction searchStartOfPhys(uint8Array) {\n  const length = uint8Array.length - 1;\n  for (let i = length; i >= 4; i--) {\n    if (uint8Array[i - 4] === 9 && uint8Array[i - 3] === _P && uint8Array[i - 2] === _H && uint8Array[i - 1] === _Y && uint8Array[i] === _S) {\n      return i - 3;\n    }\n  }\n  return 0;\n}\nfunction changePngDpi(uint8Array, dpi, overwritepHYs = false) {\n  const physChunk = new Uint8Array(13);\n  dpi *= 39.3701;\n  physChunk[0] = _P;\n  physChunk[1] = _H;\n  physChunk[2] = _Y;\n  physChunk[3] = _S;\n  physChunk[4] = dpi >>> 24;\n  physChunk[5] = dpi >>> 16;\n  physChunk[6] = dpi >>> 8;\n  physChunk[7] = dpi & 255;\n  physChunk[8] = physChunk[4];\n  physChunk[9] = physChunk[5];\n  physChunk[10] = physChunk[6];\n  physChunk[11] = physChunk[7];\n  physChunk[12] = 1;\n  const crc = calcCrc(physChunk);\n  const crcChunk = new Uint8Array(4);\n  crcChunk[0] = crc >>> 24;\n  crcChunk[1] = crc >>> 16;\n  crcChunk[2] = crc >>> 8;\n  crcChunk[3] = crc & 255;\n  if (overwritepHYs) {\n    const startingIndex = searchStartOfPhys(uint8Array);\n    uint8Array.set(physChunk, startingIndex);\n    uint8Array.set(crcChunk, startingIndex + 13);\n    return uint8Array;\n  } else {\n    const chunkLength = new Uint8Array(4);\n    chunkLength[0] = 0;\n    chunkLength[1] = 0;\n    chunkLength[2] = 0;\n    chunkLength[3] = 9;\n    const finalHeader = new Uint8Array(54);\n    finalHeader.set(uint8Array, 0);\n    finalHeader.set(chunkLength, 33);\n    finalHeader.set(physChunk, 37);\n    finalHeader.set(crcChunk, 50);\n    return finalHeader;\n  }\n}\nconst b64PhysSignature1 = \"AAlwSFlz\";\nconst b64PhysSignature2 = \"AAAJcEhZ\";\nconst b64PhysSignature3 = \"AAAACXBI\";\nfunction detectPhysChunkFromDataUrl(dataUrl) {\n  let b64index = dataUrl.indexOf(b64PhysSignature1);\n  if (b64index === -1) {\n    b64index = dataUrl.indexOf(b64PhysSignature2);\n  }\n  if (b64index === -1) {\n    b64index = dataUrl.indexOf(b64PhysSignature3);\n  }\n  return b64index;\n}\n\nconst PREFIX = \"[modern-screenshot]\";\nconst IN_BROWSER = typeof window !== \"undefined\";\nconst SUPPORT_WEB_WORKER = IN_BROWSER && \"Worker\" in window;\nconst SUPPORT_ATOB = IN_BROWSER && \"atob\" in window;\nconst SUPPORT_BTOA = IN_BROWSER && \"btoa\" in window;\nconst USER_AGENT = IN_BROWSER ? window.navigator?.userAgent : \"\";\nconst IN_CHROME = USER_AGENT.includes(\"Chrome\");\nconst IN_SAFARI = USER_AGENT.includes(\"AppleWebKit\") && !IN_CHROME;\nconst IN_FIREFOX = USER_AGENT.includes(\"Firefox\");\nconst isContext = (value) => value && \"__CONTEXT__\" in value;\nconst isCssFontFaceRule = (rule) => rule.constructor.name === \"CSSFontFaceRule\";\nconst isCSSImportRule = (rule) => rule.constructor.name === \"CSSImportRule\";\nconst isElementNode = (node) => node.nodeType === 1;\nconst isSVGElementNode = (node) => typeof node.className === \"object\";\nconst isSVGImageElementNode = (node) => node.tagName === \"image\";\nconst isSVGUseElementNode = (node) => node.tagName === \"use\";\nconst isHTMLElementNode = (node) => isElementNode(node) && typeof node.style !== \"undefined\" && !isSVGElementNode(node);\nconst isCommentNode = (node) => node.nodeType === 8;\nconst isTextNode = (node) => node.nodeType === 3;\nconst isImageElement = (node) => node.tagName === \"IMG\";\nconst isVideoElement = (node) => node.tagName === \"VIDEO\";\nconst isCanvasElement = (node) => node.tagName === \"CANVAS\";\nconst isTextareaElement = (node) => node.tagName === \"TEXTAREA\";\nconst isInputElement = (node) => node.tagName === \"INPUT\";\nconst isStyleElement = (node) => node.tagName === \"STYLE\";\nconst isScriptElement = (node) => node.tagName === \"SCRIPT\";\nconst isSelectElement = (node) => node.tagName === \"SELECT\";\nconst isSlotElement = (node) => node.tagName === \"SLOT\";\nconst isIFrameElement = (node) => node.tagName === \"IFRAME\";\nconst consoleWarn = (...args) => console.warn(PREFIX, ...args);\nfunction supportWebp(ownerDocument) {\n  const canvas = ownerDocument?.createElement?.(\"canvas\");\n  if (canvas) {\n    canvas.height = canvas.width = 1;\n  }\n  return Boolean(canvas) && \"toDataURL\" in canvas && Boolean(canvas.toDataURL(\"image/webp\").includes(\"image/webp\"));\n}\nconst isDataUrl = (url) => url.startsWith(\"data:\");\nfunction resolveUrl(url, baseUrl) {\n  if (url.match(/^[a-z]+:\\/\\//i))\n    return url;\n  if (IN_BROWSER && url.match(/^\\/\\//))\n    return window.location.protocol + url;\n  if (url.match(/^[a-z]+:/i))\n    return url;\n  if (!IN_BROWSER)\n    return url;\n  const doc = getDocument().implementation.createHTMLDocument();\n  const base = doc.createElement(\"base\");\n  const a = doc.createElement(\"a\");\n  doc.head.appendChild(base);\n  doc.body.appendChild(a);\n  if (baseUrl)\n    base.href = baseUrl;\n  a.href = url;\n  return a.href;\n}\nfunction getDocument(target) {\n  return (target && isElementNode(target) ? target?.ownerDocument : target) ?? window.document;\n}\nconst XMLNS = \"http://www.w3.org/2000/svg\";\nfunction createSvg(width, height, ownerDocument) {\n  const svg = getDocument(ownerDocument).createElementNS(XMLNS, \"svg\");\n  svg.setAttributeNS(null, \"width\", width.toString());\n  svg.setAttributeNS(null, \"height\", height.toString());\n  svg.setAttributeNS(null, \"viewBox\", `0 0 ${width} ${height}`);\n  return svg;\n}\nfunction svgToDataUrl(svg, removeControlCharacter) {\n  let xhtml = new XMLSerializer().serializeToString(svg);\n  if (removeControlCharacter) {\n    xhtml = xhtml.replace(/[\\u0000-\\u0008\\v\\f\\u000E-\\u001F\\uD800-\\uDFFF\\uFFFE\\uFFFF]/gu, \"\");\n  }\n  return `data:image/svg+xml;charset=utf-8,${encodeURIComponent(xhtml)}`;\n}\nasync function canvasToBlob(canvas, type = \"image/png\", quality = 1) {\n  try {\n    return await new Promise((resolve, reject) => {\n      canvas.toBlob((blob) => {\n        if (blob) {\n          resolve(blob);\n        } else {\n          reject(new Error(\"Blob is null\"));\n        }\n      }, type, quality);\n    });\n  } catch (error) {\n    if (SUPPORT_ATOB) {\n      return dataUrlToBlob(canvas.toDataURL(type, quality));\n    }\n    throw error;\n  }\n}\nfunction dataUrlToBlob(dataUrl) {\n  const [header, base64] = dataUrl.split(\",\");\n  const type = header.match(/data:(.+);/)?.[1] ?? void 0;\n  const decoded = window.atob(base64);\n  const length = decoded.length;\n  const buffer = new Uint8Array(length);\n  for (let i = 0; i < length; i += 1) {\n    buffer[i] = decoded.charCodeAt(i);\n  }\n  return new Blob([buffer], { type });\n}\nfunction readBlob(blob, type) {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onload = () => resolve(reader.result);\n    reader.onerror = () => reject(reader.error);\n    reader.onabort = () => reject(new Error(`Failed read blob to ${type}`));\n    if (type === \"dataUrl\") {\n      reader.readAsDataURL(blob);\n    } else if (type === \"arrayBuffer\") {\n      reader.readAsArrayBuffer(blob);\n    }\n  });\n}\nconst blobToDataUrl = (blob) => readBlob(blob, \"dataUrl\");\nconst blobToArrayBuffer = (blob) => readBlob(blob, \"arrayBuffer\");\nfunction createImage(url, ownerDocument) {\n  const img = getDocument(ownerDocument).createElement(\"img\");\n  img.decoding = \"sync\";\n  img.loading = \"eager\";\n  img.src = url;\n  return img;\n}\nfunction loadMedia(media, options) {\n  return new Promise((resolve) => {\n    const { timeout, ownerDocument, onError: userOnError, onWarn } = options ?? {};\n    const node = typeof media === \"string\" ? createImage(media, getDocument(ownerDocument)) : media;\n    let timer = null;\n    let removeEventListeners = null;\n    function onResolve() {\n      resolve(node);\n      timer && clearTimeout(timer);\n      removeEventListeners?.();\n    }\n    if (timeout) {\n      timer = setTimeout(onResolve, timeout);\n    }\n    if (isVideoElement(node)) {\n      const currentSrc = node.currentSrc || node.src;\n      if (!currentSrc) {\n        if (node.poster) {\n          return loadMedia(node.poster, options).then(resolve);\n        }\n        return onResolve();\n      }\n      if (node.readyState >= 2) {\n        return onResolve();\n      }\n      const onLoadeddata = onResolve;\n      const onError = (error) => {\n        onWarn?.(\n          \"Failed video load\",\n          currentSrc,\n          error\n        );\n        userOnError?.(error);\n        onResolve();\n      };\n      removeEventListeners = () => {\n        node.removeEventListener(\"loadeddata\", onLoadeddata);\n        node.removeEventListener(\"error\", onError);\n      };\n      node.addEventListener(\"loadeddata\", onLoadeddata, { once: true });\n      node.addEventListener(\"error\", onError, { once: true });\n    } else {\n      const currentSrc = isSVGImageElementNode(node) ? node.href.baseVal : node.currentSrc || node.src;\n      if (!currentSrc) {\n        return onResolve();\n      }\n      const onLoad = async () => {\n        if (isImageElement(node) && \"decode\" in node) {\n          try {\n            await node.decode();\n          } catch (error) {\n            onWarn?.(\n              \"Failed to decode image, trying to render anyway\",\n              node.dataset.originalSrc || currentSrc,\n              error\n            );\n          }\n        }\n        onResolve();\n      };\n      const onError = (error) => {\n        onWarn?.(\n          \"Failed image load\",\n          node.dataset.originalSrc || currentSrc,\n          error\n        );\n        onResolve();\n      };\n      if (isImageElement(node) && node.complete) {\n        return onLoad();\n      }\n      removeEventListeners = () => {\n        node.removeEventListener(\"load\", onLoad);\n        node.removeEventListener(\"error\", onError);\n      };\n      node.addEventListener(\"load\", onLoad, { once: true });\n      node.addEventListener(\"error\", onError, { once: true });\n    }\n  });\n}\nasync function waitUntilLoad(node, options) {\n  if (isHTMLElementNode(node)) {\n    if (isImageElement(node) || isVideoElement(node)) {\n      await loadMedia(node, options);\n    } else {\n      await Promise.all(\n        [\"img\", \"video\"].flatMap((selectors) => {\n          return Array.from(node.querySelectorAll(selectors)).map((el) => loadMedia(el, options));\n        })\n      );\n    }\n  }\n}\nconst uuid = /* @__PURE__ */ function uuid2() {\n  let counter = 0;\n  const random = () => `0000${(Math.random() * 36 ** 4 << 0).toString(36)}`.slice(-4);\n  return () => {\n    counter += 1;\n    return `u${random()}${counter}`;\n  };\n}();\nfunction splitFontFamily(fontFamily) {\n  return fontFamily?.split(\",\").map((val) => val.trim().replace(/\"|'/g, \"\").toLowerCase()).filter(Boolean);\n}\n\nlet uid = 0;\nfunction createLogger(debug) {\n  const prefix = `${PREFIX}[#${uid}]`;\n  uid++;\n  return {\n    // eslint-disable-next-line no-console\n    time: (label) => debug && console.time(`${prefix} ${label}`),\n    // eslint-disable-next-line no-console\n    timeEnd: (label) => debug && console.timeEnd(`${prefix} ${label}`),\n    warn: (...args) => debug && consoleWarn(...args)\n  };\n}\n\nfunction getDefaultRequestInit(bypassingCache) {\n  return {\n    cache: bypassingCache ? \"no-cache\" : \"force-cache\"\n  };\n}\n\nasync function orCreateContext(node, options) {\n  return isContext(node) ? node : createContext(node, { ...options, autoDestruct: true });\n}\nasync function createContext(node, options) {\n  const { scale = 1, workerUrl, workerNumber = 1 } = options || {};\n  const debug = Boolean(options?.debug);\n  const features = options?.features ?? true;\n  const ownerDocument = node.ownerDocument ?? (IN_BROWSER ? window.document : void 0);\n  const ownerWindow = node.ownerDocument?.defaultView ?? (IN_BROWSER ? window : void 0);\n  const requests = /* @__PURE__ */ new Map();\n  const context = {\n    // Options\n    width: 0,\n    height: 0,\n    quality: 1,\n    type: \"image/png\",\n    scale,\n    backgroundColor: null,\n    style: null,\n    filter: null,\n    maximumCanvasSize: 0,\n    timeout: 3e4,\n    progress: null,\n    debug,\n    fetch: {\n      requestInit: getDefaultRequestInit(options?.fetch?.bypassingCache),\n      placeholderImage: \"data:image/png;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\",\n      bypassingCache: false,\n      ...options?.fetch\n    },\n    fetchFn: null,\n    font: {},\n    drawImageInterval: 100,\n    workerUrl: null,\n    workerNumber,\n    onCloneEachNode: null,\n    onCloneNode: null,\n    onEmbedNode: null,\n    onCreateForeignObjectSvg: null,\n    includeStyleProperties: null,\n    autoDestruct: false,\n    ...options,\n    // InternalContext\n    __CONTEXT__: true,\n    log: createLogger(debug),\n    node,\n    ownerDocument,\n    ownerWindow,\n    dpi: scale === 1 ? null : 96 * scale,\n    svgStyleElement: createStyleElement(ownerDocument),\n    svgDefsElement: ownerDocument?.createElementNS(XMLNS, \"defs\"),\n    svgStyles: /* @__PURE__ */ new Map(),\n    defaultComputedStyles: /* @__PURE__ */ new Map(),\n    workers: [\n      ...Array.from({\n        length: SUPPORT_WEB_WORKER && workerUrl && workerNumber ? workerNumber : 0\n      })\n    ].map(() => {\n      try {\n        const worker = new Worker(workerUrl);\n        worker.onmessage = async (event) => {\n          const { url, result } = event.data;\n          if (result) {\n            requests.get(url)?.resolve?.(result);\n          } else {\n            requests.get(url)?.reject?.(new Error(`Error receiving message from worker: ${url}`));\n          }\n        };\n        worker.onmessageerror = (event) => {\n          const { url } = event.data;\n          requests.get(url)?.reject?.(new Error(`Error receiving message from worker: ${url}`));\n        };\n        return worker;\n      } catch (error) {\n        context.log.warn(\"Failed to new Worker\", error);\n        return null;\n      }\n    }).filter(Boolean),\n    fontFamilies: /* @__PURE__ */ new Map(),\n    fontCssTexts: /* @__PURE__ */ new Map(),\n    acceptOfImage: `${[\n      supportWebp(ownerDocument) && \"image/webp\",\n      \"image/svg+xml\",\n      \"image/*\",\n      \"*/*\"\n    ].filter(Boolean).join(\",\")};q=0.8`,\n    requests,\n    drawImageCount: 0,\n    tasks: [],\n    features,\n    isEnable: (key) => {\n      if (key === \"restoreScrollPosition\") {\n        return typeof features === \"boolean\" ? false : features[key] ?? false;\n      }\n      if (typeof features === \"boolean\") {\n        return features;\n      }\n      return features[key] ?? true;\n    },\n    shadowRoots: []\n  };\n  context.log.time(\"wait until load\");\n  await waitUntilLoad(node, { timeout: context.timeout, onWarn: context.log.warn });\n  context.log.timeEnd(\"wait until load\");\n  const { width, height } = resolveBoundingBox(node, context);\n  context.width = width;\n  context.height = height;\n  return context;\n}\nfunction createStyleElement(ownerDocument) {\n  if (!ownerDocument)\n    return void 0;\n  const style = ownerDocument.createElement(\"style\");\n  const cssText = style.ownerDocument.createTextNode(`\n.______background-clip--text {\n  background-clip: text;\n  -webkit-background-clip: text;\n}\n`);\n  style.appendChild(cssText);\n  return style;\n}\nfunction resolveBoundingBox(node, context) {\n  let { width, height } = context;\n  if (isElementNode(node) && (!width || !height)) {\n    const box = node.getBoundingClientRect();\n    width = width || box.width || Number(node.getAttribute(\"width\")) || 0;\n    height = height || box.height || Number(node.getAttribute(\"height\")) || 0;\n  }\n  return { width, height };\n}\n\nasync function imageToCanvas(image, context) {\n  const {\n    log,\n    timeout,\n    drawImageCount,\n    drawImageInterval\n  } = context;\n  log.time(\"image to canvas\");\n  const loaded = await loadMedia(image, { timeout, onWarn: context.log.warn });\n  const { canvas, context2d } = createCanvas(image.ownerDocument, context);\n  const drawImage = () => {\n    try {\n      context2d?.drawImage(loaded, 0, 0, canvas.width, canvas.height);\n    } catch (error) {\n      context.log.warn(\"Failed to drawImage\", error);\n    }\n  };\n  drawImage();\n  if (context.isEnable(\"fixSvgXmlDecode\")) {\n    for (let i = 0; i < drawImageCount; i++) {\n      await new Promise((resolve) => {\n        setTimeout(() => {\n          context2d?.clearRect(0, 0, canvas.width, canvas.height);\n          drawImage();\n          resolve();\n        }, i + drawImageInterval);\n      });\n    }\n  }\n  context.drawImageCount = 0;\n  log.timeEnd(\"image to canvas\");\n  return canvas;\n}\nfunction createCanvas(ownerDocument, context) {\n  const { width, height, scale, backgroundColor, maximumCanvasSize: max } = context;\n  const canvas = ownerDocument.createElement(\"canvas\");\n  canvas.width = Math.floor(width * scale);\n  canvas.height = Math.floor(height * scale);\n  canvas.style.width = `${width}px`;\n  canvas.style.height = `${height}px`;\n  if (max) {\n    if (canvas.width > max || canvas.height > max) {\n      if (canvas.width > max && canvas.height > max) {\n        if (canvas.width > canvas.height) {\n          canvas.height *= max / canvas.width;\n          canvas.width = max;\n        } else {\n          canvas.width *= max / canvas.height;\n          canvas.height = max;\n        }\n      } else if (canvas.width > max) {\n        canvas.height *= max / canvas.width;\n        canvas.width = max;\n      } else {\n        canvas.width *= max / canvas.height;\n        canvas.height = max;\n      }\n    }\n  }\n  const context2d = canvas.getContext(\"2d\");\n  if (context2d && backgroundColor) {\n    context2d.fillStyle = backgroundColor;\n    context2d.fillRect(0, 0, canvas.width, canvas.height);\n  }\n  return { canvas, context2d };\n}\n\nfunction cloneCanvas(canvas, context) {\n  if (canvas.ownerDocument) {\n    try {\n      const dataURL = canvas.toDataURL();\n      if (dataURL !== \"data:,\") {\n        return createImage(dataURL, canvas.ownerDocument);\n      }\n    } catch (error) {\n      context.log.warn(\"Failed to clone canvas\", error);\n    }\n  }\n  const cloned = canvas.cloneNode(false);\n  const ctx = canvas.getContext(\"2d\");\n  const clonedCtx = cloned.getContext(\"2d\");\n  try {\n    if (ctx && clonedCtx) {\n      clonedCtx.putImageData(\n        ctx.getImageData(0, 0, canvas.width, canvas.height),\n        0,\n        0\n      );\n    }\n    return cloned;\n  } catch (error) {\n    context.log.warn(\"Failed to clone canvas\", error);\n  }\n  return cloned;\n}\n\nfunction cloneIframe(iframe, context) {\n  try {\n    if (iframe?.contentDocument?.body) {\n      return cloneNode(iframe.contentDocument.body, context);\n    }\n  } catch (error) {\n    context.log.warn(\"Failed to clone iframe\", error);\n  }\n  return iframe.cloneNode(false);\n}\n\nfunction cloneImage(image) {\n  const cloned = image.cloneNode(false);\n  if (image.currentSrc && image.currentSrc !== image.src) {\n    cloned.src = image.currentSrc;\n    cloned.srcset = \"\";\n  }\n  if (cloned.loading === \"lazy\") {\n    cloned.loading = \"eager\";\n  }\n  return cloned;\n}\n\nasync function cloneVideo(video, context) {\n  if (video.ownerDocument && !video.currentSrc && video.poster) {\n    return createImage(video.poster, video.ownerDocument);\n  }\n  const cloned = video.cloneNode(false);\n  cloned.crossOrigin = \"anonymous\";\n  if (video.currentSrc && video.currentSrc !== video.src) {\n    cloned.src = video.currentSrc;\n  }\n  const ownerDocument = cloned.ownerDocument;\n  if (ownerDocument) {\n    let canPlay = true;\n    await loadMedia(cloned, { onError: () => canPlay = false, onWarn: context.log.warn });\n    if (!canPlay) {\n      if (video.poster) {\n        return createImage(video.poster, video.ownerDocument);\n      }\n      return cloned;\n    }\n    cloned.currentTime = video.currentTime;\n    await new Promise((resolve) => {\n      cloned.addEventListener(\"seeked\", resolve, { once: true });\n    });\n    const canvas = ownerDocument.createElement(\"canvas\");\n    canvas.width = video.offsetWidth;\n    canvas.height = video.offsetHeight;\n    try {\n      const ctx = canvas.getContext(\"2d\");\n      if (ctx)\n        ctx.drawImage(cloned, 0, 0, canvas.width, canvas.height);\n    } catch (error) {\n      context.log.warn(\"Failed to clone video\", error);\n      if (video.poster) {\n        return createImage(video.poster, video.ownerDocument);\n      }\n      return cloned;\n    }\n    return cloneCanvas(canvas, context);\n  }\n  return cloned;\n}\n\nfunction cloneElement(node, context) {\n  if (isCanvasElement(node)) {\n    return cloneCanvas(node, context);\n  }\n  if (isIFrameElement(node)) {\n    return cloneIframe(node, context);\n  }\n  if (isImageElement(node)) {\n    return cloneImage(node);\n  }\n  if (isVideoElement(node)) {\n    return cloneVideo(node, context);\n  }\n  return node.cloneNode(false);\n}\n\nfunction getSandBox(context) {\n  let sandbox = context.sandbox;\n  if (!sandbox) {\n    const { ownerDocument } = context;\n    try {\n      if (ownerDocument) {\n        sandbox = ownerDocument.createElement(\"iframe\");\n        sandbox.id = `__SANDBOX__${uuid()}`;\n        sandbox.width = \"0\";\n        sandbox.height = \"0\";\n        sandbox.style.visibility = \"hidden\";\n        sandbox.style.position = \"fixed\";\n        ownerDocument.body.appendChild(sandbox);\n        sandbox.srcdoc = '<!DOCTYPE html><meta charset=\"UTF-8\"><title></title><body>';\n        context.sandbox = sandbox;\n      }\n    } catch (error) {\n      context.log.warn(\"Failed to getSandBox\", error);\n    }\n  }\n  return sandbox;\n}\n\nconst ignoredStyles = [\n  \"width\",\n  \"height\",\n  \"-webkit-text-fill-color\"\n];\nconst includedAttributes = [\n  \"stroke\",\n  \"fill\"\n];\nfunction getDefaultStyle(node, pseudoElement, context) {\n  const { defaultComputedStyles } = context;\n  const nodeName = node.nodeName.toLowerCase();\n  const isSvgNode = isSVGElementNode(node) && nodeName !== \"svg\";\n  const attributes = isSvgNode ? includedAttributes.map((name) => [name, node.getAttribute(name)]).filter(([, value]) => value !== null) : [];\n  const key = [\n    isSvgNode && \"svg\",\n    nodeName,\n    attributes.map((name, value) => `${name}=${value}`).join(\",\"),\n    pseudoElement\n  ].filter(Boolean).join(\":\");\n  if (defaultComputedStyles.has(key))\n    return defaultComputedStyles.get(key);\n  const sandbox = getSandBox(context);\n  const sandboxWindow = sandbox?.contentWindow;\n  if (!sandboxWindow)\n    return /* @__PURE__ */ new Map();\n  const sandboxDocument = sandboxWindow?.document;\n  let root;\n  let el;\n  if (isSvgNode) {\n    root = sandboxDocument.createElementNS(XMLNS, \"svg\");\n    el = root.ownerDocument.createElementNS(root.namespaceURI, nodeName);\n    attributes.forEach(([name, value]) => {\n      el.setAttributeNS(null, name, value);\n    });\n    root.appendChild(el);\n  } else {\n    root = el = sandboxDocument.createElement(nodeName);\n  }\n  el.textContent = \" \";\n  sandboxDocument.body.appendChild(root);\n  const computedStyle = sandboxWindow.getComputedStyle(el, pseudoElement);\n  const styles = /* @__PURE__ */ new Map();\n  for (let len = computedStyle.length, i = 0; i < len; i++) {\n    const name = computedStyle.item(i);\n    if (ignoredStyles.includes(name))\n      continue;\n    styles.set(name, computedStyle.getPropertyValue(name));\n  }\n  sandboxDocument.body.removeChild(root);\n  defaultComputedStyles.set(key, styles);\n  return styles;\n}\n\nfunction getDiffStyle(style, defaultStyle, includeStyleProperties) {\n  const diffStyle = /* @__PURE__ */ new Map();\n  const prefixs = [];\n  const prefixTree = /* @__PURE__ */ new Map();\n  if (includeStyleProperties) {\n    for (const name of includeStyleProperties) {\n      applyTo(name);\n    }\n  } else {\n    for (let len = style.length, i = 0; i < len; i++) {\n      const name = style.item(i);\n      applyTo(name);\n    }\n  }\n  for (let len = prefixs.length, i = 0; i < len; i++) {\n    prefixTree.get(prefixs[i])?.forEach((value, name) => diffStyle.set(name, value));\n  }\n  function applyTo(name) {\n    const value = style.getPropertyValue(name);\n    const priority = style.getPropertyPriority(name);\n    const subIndex = name.lastIndexOf(\"-\");\n    const prefix = subIndex > -1 ? name.substring(0, subIndex) : void 0;\n    if (prefix) {\n      let map = prefixTree.get(prefix);\n      if (!map) {\n        map = /* @__PURE__ */ new Map();\n        prefixTree.set(prefix, map);\n      }\n      map.set(name, [value, priority]);\n    }\n    if (defaultStyle.get(name) === value && !priority)\n      return;\n    if (prefix) {\n      prefixs.push(prefix);\n    } else {\n      diffStyle.set(name, [value, priority]);\n    }\n  }\n  return diffStyle;\n}\n\nfunction copyCssStyles(node, cloned, isRoot, context) {\n  const { ownerWindow, includeStyleProperties, currentParentNodeStyle } = context;\n  const clonedStyle = cloned.style;\n  const computedStyle = ownerWindow.getComputedStyle(node);\n  const defaultStyle = getDefaultStyle(node, null, context);\n  currentParentNodeStyle?.forEach((_, key) => {\n    defaultStyle.delete(key);\n  });\n  const style = getDiffStyle(computedStyle, defaultStyle, includeStyleProperties);\n  style.delete(\"transition-property\");\n  style.delete(\"all\");\n  style.delete(\"d\");\n  style.delete(\"content\");\n  if (isRoot) {\n    style.delete(\"margin-top\");\n    style.delete(\"margin-right\");\n    style.delete(\"margin-bottom\");\n    style.delete(\"margin-left\");\n    style.delete(\"margin-block-start\");\n    style.delete(\"margin-block-end\");\n    style.delete(\"margin-inline-start\");\n    style.delete(\"margin-inline-end\");\n    style.set(\"box-sizing\", [\"border-box\", \"\"]);\n  }\n  if (style.get(\"background-clip\")?.[0] === \"text\") {\n    cloned.classList.add(\"______background-clip--text\");\n  }\n  if (IN_CHROME) {\n    if (!style.has(\"font-kerning\"))\n      style.set(\"font-kerning\", [\"normal\", \"\"]);\n    if ((style.get(\"overflow-x\")?.[0] === \"hidden\" || style.get(\"overflow-y\")?.[0] === \"hidden\") && style.get(\"text-overflow\")?.[0] === \"ellipsis\" && node.scrollWidth === node.clientWidth) {\n      style.set(\"text-overflow\", [\"clip\", \"\"]);\n    }\n  }\n  for (let len = clonedStyle.length, i = 0; i < len; i++) {\n    clonedStyle.removeProperty(clonedStyle.item(i));\n  }\n  style.forEach(([value, priority], name) => {\n    clonedStyle.setProperty(name, value, priority);\n  });\n  return style;\n}\n\nfunction copyInputValue(node, cloned) {\n  if (isTextareaElement(node) || isInputElement(node) || isSelectElement(node)) {\n    cloned.setAttribute(\"value\", node.value);\n  }\n}\n\nconst pseudoClasses = [\n  \"::before\",\n  \"::after\"\n  // '::placeholder', TODO\n];\nconst scrollbarPseudoClasses = [\n  \"::-webkit-scrollbar\",\n  \"::-webkit-scrollbar-button\",\n  // '::-webkit-scrollbar:horizontal', TODO\n  \"::-webkit-scrollbar-thumb\",\n  \"::-webkit-scrollbar-track\",\n  \"::-webkit-scrollbar-track-piece\",\n  // '::-webkit-scrollbar:vertical', TODO\n  \"::-webkit-scrollbar-corner\",\n  \"::-webkit-resizer\"\n];\nfunction copyPseudoClass(node, cloned, copyScrollbar, context, addWordToFontFamilies) {\n  const { ownerWindow, svgStyleElement, svgStyles, currentNodeStyle } = context;\n  if (!svgStyleElement || !ownerWindow)\n    return;\n  function copyBy(pseudoClass) {\n    const computedStyle = ownerWindow.getComputedStyle(node, pseudoClass);\n    let content = computedStyle.getPropertyValue(\"content\");\n    if (!content || content === \"none\")\n      return;\n    addWordToFontFamilies?.(content);\n    content = content.replace(/(')|(\")|(counter\\(.+\\))/g, \"\");\n    const klasses = [uuid()];\n    const defaultStyle = getDefaultStyle(node, pseudoClass, context);\n    currentNodeStyle?.forEach((_, key) => {\n      defaultStyle.delete(key);\n    });\n    const style = getDiffStyle(computedStyle, defaultStyle, context.includeStyleProperties);\n    style.delete(\"content\");\n    style.delete(\"-webkit-locale\");\n    if (style.get(\"background-clip\")?.[0] === \"text\") {\n      cloned.classList.add(\"______background-clip--text\");\n    }\n    const cloneStyle = [\n      `content: '${content}';`\n    ];\n    style.forEach(([value, priority], name) => {\n      cloneStyle.push(`${name}: ${value}${priority ? \" !important\" : \"\"};`);\n    });\n    if (cloneStyle.length === 1)\n      return;\n    try {\n      cloned.className = [cloned.className, ...klasses].join(\" \");\n    } catch (err) {\n      context.log.warn(\"Failed to copyPseudoClass\", err);\n      return;\n    }\n    const cssText = cloneStyle.join(\"\\n  \");\n    let allClasses = svgStyles.get(cssText);\n    if (!allClasses) {\n      allClasses = [];\n      svgStyles.set(cssText, allClasses);\n    }\n    allClasses.push(`.${klasses[0]}${pseudoClass}`);\n  }\n  pseudoClasses.forEach(copyBy);\n  if (copyScrollbar)\n    scrollbarPseudoClasses.forEach(copyBy);\n}\n\nconst excludeParentNodes = /* @__PURE__ */ new Set([\n  \"symbol\"\n  // test/fixtures/svg.symbol.html\n]);\nasync function appendChildNode(node, cloned, child, context, addWordToFontFamilies) {\n  if (isElementNode(child) && (isStyleElement(child) || isScriptElement(child)))\n    return;\n  if (context.filter && !context.filter(child))\n    return;\n  if (excludeParentNodes.has(cloned.nodeName) || excludeParentNodes.has(child.nodeName)) {\n    context.currentParentNodeStyle = void 0;\n  } else {\n    context.currentParentNodeStyle = context.currentNodeStyle;\n  }\n  const childCloned = await cloneNode(child, context, false, addWordToFontFamilies);\n  if (context.isEnable(\"restoreScrollPosition\")) {\n    restoreScrollPosition(node, childCloned);\n  }\n  cloned.appendChild(childCloned);\n}\nasync function cloneChildNodes(node, cloned, context, addWordToFontFamilies) {\n  let firstChild = node.firstChild;\n  if (isElementNode(node)) {\n    if (node.shadowRoot) {\n      firstChild = node.shadowRoot?.firstChild;\n      context.shadowRoots.push(node.shadowRoot);\n    }\n  }\n  for (let child = firstChild; child; child = child.nextSibling) {\n    if (isCommentNode(child))\n      continue;\n    if (isElementNode(child) && isSlotElement(child) && typeof child.assignedNodes === \"function\") {\n      const nodes = child.assignedNodes();\n      for (let i = 0; i < nodes.length; i++) {\n        await appendChildNode(node, cloned, nodes[i], context, addWordToFontFamilies);\n      }\n    } else {\n      await appendChildNode(node, cloned, child, context, addWordToFontFamilies);\n    }\n  }\n}\nfunction restoreScrollPosition(node, chlidCloned) {\n  if (!isHTMLElementNode(node) || !isHTMLElementNode(chlidCloned))\n    return;\n  const { scrollTop, scrollLeft } = node;\n  if (!scrollTop && !scrollLeft) {\n    return;\n  }\n  const { transform } = chlidCloned.style;\n  const matrix = new DOMMatrix(transform);\n  const { a, b, c, d } = matrix;\n  matrix.a = 1;\n  matrix.b = 0;\n  matrix.c = 0;\n  matrix.d = 1;\n  matrix.translateSelf(-scrollLeft, -scrollTop);\n  matrix.a = a;\n  matrix.b = b;\n  matrix.c = c;\n  matrix.d = d;\n  chlidCloned.style.transform = matrix.toString();\n}\nfunction applyCssStyleWithOptions(cloned, context) {\n  const { backgroundColor, width, height, style: styles } = context;\n  const clonedStyle = cloned.style;\n  if (backgroundColor)\n    clonedStyle.setProperty(\"background-color\", backgroundColor, \"important\");\n  if (width)\n    clonedStyle.setProperty(\"width\", `${width}px`, \"important\");\n  if (height)\n    clonedStyle.setProperty(\"height\", `${height}px`, \"important\");\n  if (styles) {\n    for (const name in styles) clonedStyle[name] = styles[name];\n  }\n}\nconst NORMAL_ATTRIBUTE_RE = /^[\\w-:]+$/;\nasync function cloneNode(node, context, isRoot = false, addWordToFontFamilies) {\n  const { ownerDocument, ownerWindow, fontFamilies, onCloneEachNode } = context;\n  if (ownerDocument && isTextNode(node)) {\n    if (addWordToFontFamilies && /\\S/.test(node.data)) {\n      addWordToFontFamilies(node.data);\n    }\n    return ownerDocument.createTextNode(node.data);\n  }\n  if (ownerDocument && ownerWindow && isElementNode(node) && (isHTMLElementNode(node) || isSVGElementNode(node))) {\n    const cloned2 = await cloneElement(node, context);\n    if (context.isEnable(\"removeAbnormalAttributes\")) {\n      const names = cloned2.getAttributeNames();\n      for (let len = names.length, i = 0; i < len; i++) {\n        const name = names[i];\n        if (!NORMAL_ATTRIBUTE_RE.test(name)) {\n          cloned2.removeAttribute(name);\n        }\n      }\n    }\n    const style = context.currentNodeStyle = copyCssStyles(node, cloned2, isRoot, context);\n    if (isRoot)\n      applyCssStyleWithOptions(cloned2, context);\n    let copyScrollbar = false;\n    if (context.isEnable(\"copyScrollbar\")) {\n      const overflow = [\n        style.get(\"overflow-x\")?.[0],\n        style.get(\"overflow-y\")?.[0]\n      ];\n      copyScrollbar = overflow.includes(\"scroll\") || (overflow.includes(\"auto\") || overflow.includes(\"overlay\")) && (node.scrollHeight > node.clientHeight || node.scrollWidth > node.clientWidth);\n    }\n    const textTransform = style.get(\"text-transform\")?.[0];\n    const families = splitFontFamily(style.get(\"font-family\")?.[0]);\n    const addWordToFontFamilies2 = families ? (word) => {\n      if (textTransform === \"uppercase\") {\n        word = word.toUpperCase();\n      } else if (textTransform === \"lowercase\") {\n        word = word.toLowerCase();\n      } else if (textTransform === \"capitalize\") {\n        word = word[0].toUpperCase() + word.substring(1);\n      }\n      families.forEach((family) => {\n        let fontFamily = fontFamilies.get(family);\n        if (!fontFamily) {\n          fontFamilies.set(family, fontFamily = /* @__PURE__ */ new Set());\n        }\n        word.split(\"\").forEach((text) => fontFamily.add(text));\n      });\n    } : void 0;\n    copyPseudoClass(\n      node,\n      cloned2,\n      copyScrollbar,\n      context,\n      addWordToFontFamilies2\n    );\n    copyInputValue(node, cloned2);\n    if (!isVideoElement(node)) {\n      await cloneChildNodes(\n        node,\n        cloned2,\n        context,\n        addWordToFontFamilies2\n      );\n    }\n    await onCloneEachNode?.(cloned2);\n    return cloned2;\n  }\n  const cloned = node.cloneNode(false);\n  await cloneChildNodes(node, cloned, context);\n  await onCloneEachNode?.(cloned);\n  return cloned;\n}\n\nfunction destroyContext(context) {\n  context.ownerDocument = void 0;\n  context.ownerWindow = void 0;\n  context.svgStyleElement = void 0;\n  context.svgDefsElement = void 0;\n  context.svgStyles.clear();\n  context.defaultComputedStyles.clear();\n  if (context.sandbox) {\n    try {\n      context.sandbox.remove();\n    } catch (err) {\n      context.log.warn(\"Failed to destroyContext\", err);\n    }\n    context.sandbox = void 0;\n  }\n  context.workers = [];\n  context.fontFamilies.clear();\n  context.fontCssTexts.clear();\n  context.requests.clear();\n  context.tasks = [];\n  context.shadowRoots = [];\n}\n\nfunction baseFetch(options) {\n  const { url, timeout, responseType, ...requestInit } = options;\n  const controller = new AbortController();\n  const timer = timeout ? setTimeout(() => controller.abort(), timeout) : void 0;\n  return fetch(url, { signal: controller.signal, ...requestInit }).then((response) => {\n    if (!response.ok) {\n      throw new Error(\"Failed fetch, not 2xx response\", { cause: response });\n    }\n    switch (responseType) {\n      case \"arrayBuffer\":\n        return response.arrayBuffer();\n      case \"dataUrl\":\n        return response.blob().then(blobToDataUrl);\n      case \"text\":\n      default:\n        return response.text();\n    }\n  }).finally(() => clearTimeout(timer));\n}\nfunction contextFetch(context, options) {\n  const { url: rawUrl, requestType = \"text\", responseType = \"text\", imageDom } = options;\n  let url = rawUrl;\n  const {\n    timeout,\n    acceptOfImage,\n    requests,\n    fetchFn,\n    fetch: {\n      requestInit,\n      bypassingCache,\n      placeholderImage\n    },\n    font,\n    workers,\n    fontFamilies\n  } = context;\n  if (requestType === \"image\" && (IN_SAFARI || IN_FIREFOX)) {\n    context.drawImageCount++;\n  }\n  let request = requests.get(rawUrl);\n  if (!request) {\n    if (bypassingCache) {\n      if (bypassingCache instanceof RegExp && bypassingCache.test(url)) {\n        url += (/\\?/.test(url) ? \"&\" : \"?\") + (/* @__PURE__ */ new Date()).getTime();\n      }\n    }\n    const canFontMinify = requestType.startsWith(\"font\") && font && font.minify;\n    const fontTexts = /* @__PURE__ */ new Set();\n    if (canFontMinify) {\n      const families = requestType.split(\";\")[1].split(\",\");\n      families.forEach((family) => {\n        if (!fontFamilies.has(family))\n          return;\n        fontFamilies.get(family).forEach((text) => fontTexts.add(text));\n      });\n    }\n    const needFontMinify = canFontMinify && fontTexts.size;\n    const baseFetchOptions = {\n      url,\n      timeout,\n      responseType: needFontMinify ? \"arrayBuffer\" : responseType,\n      headers: requestType === \"image\" ? { accept: acceptOfImage } : void 0,\n      ...requestInit\n    };\n    request = {\n      type: requestType,\n      resolve: void 0,\n      reject: void 0,\n      response: null\n    };\n    request.response = (async () => {\n      if (fetchFn && requestType === \"image\") {\n        const result = await fetchFn(rawUrl);\n        if (result)\n          return result;\n      }\n      if (!IN_SAFARI && rawUrl.startsWith(\"http\") && workers.length) {\n        return new Promise((resolve, reject) => {\n          const worker = workers[requests.size & workers.length - 1];\n          worker.postMessage({ rawUrl, ...baseFetchOptions });\n          request.resolve = resolve;\n          request.reject = reject;\n        });\n      }\n      return baseFetch(baseFetchOptions);\n    })().catch((error) => {\n      requests.delete(rawUrl);\n      if (requestType === \"image\" && placeholderImage) {\n        context.log.warn(\"Failed to fetch image base64, trying to use placeholder image\", url);\n        return typeof placeholderImage === \"string\" ? placeholderImage : placeholderImage(imageDom);\n      }\n      throw error;\n    });\n    requests.set(rawUrl, request);\n  }\n  return request.response;\n}\n\nasync function replaceCssUrlToDataUrl(cssText, baseUrl, context, isImage) {\n  if (!hasCssUrl(cssText))\n    return cssText;\n  for (const [rawUrl, url] of parseCssUrls(cssText, baseUrl)) {\n    try {\n      const dataUrl = await contextFetch(\n        context,\n        {\n          url,\n          requestType: isImage ? \"image\" : \"text\",\n          responseType: \"dataUrl\"\n        }\n      );\n      cssText = cssText.replace(toRE(rawUrl), `$1${dataUrl}$3`);\n    } catch (error) {\n      context.log.warn(\"Failed to fetch css data url\", rawUrl, error);\n    }\n  }\n  return cssText;\n}\nfunction hasCssUrl(cssText) {\n  return /url\\((['\"]?)([^'\"]+?)\\1\\)/.test(cssText);\n}\nconst URL_RE = /url\\((['\"]?)([^'\"]+?)\\1\\)/g;\nfunction parseCssUrls(cssText, baseUrl) {\n  const result = [];\n  cssText.replace(URL_RE, (raw, quotation, url) => {\n    result.push([url, resolveUrl(url, baseUrl)]);\n    return raw;\n  });\n  return result.filter(([url]) => !isDataUrl(url));\n}\nfunction toRE(url) {\n  const escaped = url.replace(/([.*+?^${}()|\\[\\]\\/\\\\])/g, \"\\\\$1\");\n  return new RegExp(`(url\\\\(['\"]?)(${escaped})(['\"]?\\\\))`, \"g\");\n}\n\nconst properties = [\n  \"background-image\",\n  \"border-image-source\",\n  \"-webkit-border-image\",\n  \"-webkit-mask-image\",\n  \"list-style-image\"\n];\nfunction embedCssStyleImage(style, context) {\n  return properties.map((property) => {\n    const value = style.getPropertyValue(property);\n    if (!value || value === \"none\") {\n      return null;\n    }\n    if (IN_SAFARI || IN_FIREFOX) {\n      context.drawImageCount++;\n    }\n    return replaceCssUrlToDataUrl(value, null, context, true).then((newValue) => {\n      if (!newValue || value === newValue)\n        return;\n      style.setProperty(\n        property,\n        newValue,\n        style.getPropertyPriority(property)\n      );\n    });\n  }).filter(Boolean);\n}\n\nfunction embedImageElement(cloned, context) {\n  if (isImageElement(cloned)) {\n    const originalSrc = cloned.currentSrc || cloned.src;\n    if (!isDataUrl(originalSrc)) {\n      return [\n        contextFetch(context, {\n          url: originalSrc,\n          imageDom: cloned,\n          requestType: \"image\",\n          responseType: \"dataUrl\"\n        }).then((url) => {\n          if (!url)\n            return;\n          cloned.srcset = \"\";\n          cloned.dataset.originalSrc = originalSrc;\n          cloned.src = url || \"\";\n        })\n      ];\n    }\n    if (IN_SAFARI || IN_FIREFOX) {\n      context.drawImageCount++;\n    }\n  } else if (isSVGElementNode(cloned) && !isDataUrl(cloned.href.baseVal)) {\n    const originalSrc = cloned.href.baseVal;\n    return [\n      contextFetch(context, {\n        url: originalSrc,\n        imageDom: cloned,\n        requestType: \"image\",\n        responseType: \"dataUrl\"\n      }).then((url) => {\n        if (!url)\n          return;\n        cloned.dataset.originalSrc = originalSrc;\n        cloned.href.baseVal = url || \"\";\n      })\n    ];\n  }\n  return [];\n}\n\nfunction embedSvgUse(cloned, context) {\n  const { ownerDocument, svgDefsElement } = context;\n  const href = cloned.getAttribute(\"href\") ?? cloned.getAttribute(\"xlink:href\");\n  if (!href)\n    return [];\n  const [svgUrl, id] = href.split(\"#\");\n  if (id) {\n    const query = `#${id}`;\n    const definition = context.shadowRoots.reduce(\n      (res, root) => {\n        return res ?? root.querySelector(`svg ${query}`);\n      },\n      ownerDocument?.querySelector(`svg ${query}`)\n    );\n    if (svgUrl) {\n      cloned.setAttribute(\"href\", query);\n    }\n    if (svgDefsElement?.querySelector(query))\n      return [];\n    if (definition) {\n      svgDefsElement?.appendChild(definition.cloneNode(true));\n      return [];\n    } else if (svgUrl) {\n      return [\n        contextFetch(context, {\n          url: svgUrl,\n          responseType: \"text\"\n        }).then((svgData) => {\n          svgDefsElement?.insertAdjacentHTML(\"beforeend\", svgData);\n        })\n      ];\n    }\n  }\n  return [];\n}\n\nfunction embedNode(cloned, context) {\n  const { tasks } = context;\n  if (isElementNode(cloned)) {\n    if (isImageElement(cloned) || isSVGImageElementNode(cloned)) {\n      tasks.push(...embedImageElement(cloned, context));\n    }\n    if (isSVGUseElementNode(cloned)) {\n      tasks.push(...embedSvgUse(cloned, context));\n    }\n  }\n  if (isHTMLElementNode(cloned)) {\n    tasks.push(...embedCssStyleImage(cloned.style, context));\n  }\n  cloned.childNodes.forEach((child) => {\n    embedNode(child, context);\n  });\n}\n\nasync function embedWebFont(clone, context) {\n  const {\n    ownerDocument,\n    svgStyleElement,\n    fontFamilies,\n    fontCssTexts,\n    tasks,\n    font\n  } = context;\n  if (!ownerDocument || !svgStyleElement || !fontFamilies.size) {\n    return;\n  }\n  if (font && font.cssText) {\n    const cssText = filterPreferredFormat(font.cssText, context);\n    svgStyleElement.appendChild(ownerDocument.createTextNode(`${cssText}\n`));\n  } else {\n    const styleSheets = Array.from(ownerDocument.styleSheets).filter((styleSheet) => {\n      try {\n        return \"cssRules\" in styleSheet && Boolean(styleSheet.cssRules.length);\n      } catch (error) {\n        context.log.warn(`Error while reading CSS rules from ${styleSheet.href}`, error);\n        return false;\n      }\n    });\n    await Promise.all(\n      styleSheets.flatMap((styleSheet) => {\n        return Array.from(styleSheet.cssRules).map(async (cssRule, index) => {\n          if (isCSSImportRule(cssRule)) {\n            let importIndex = index + 1;\n            const baseUrl = cssRule.href;\n            let cssText = \"\";\n            try {\n              cssText = await contextFetch(context, {\n                url: baseUrl,\n                requestType: \"text\",\n                responseType: \"text\"\n              });\n            } catch (error) {\n              context.log.warn(`Error fetch remote css import from ${baseUrl}`, error);\n            }\n            const replacedCssText = cssText.replace(\n              URL_RE,\n              (raw, quotation, url) => raw.replace(url, resolveUrl(url, baseUrl))\n            );\n            for (const rule of parseCss(replacedCssText)) {\n              try {\n                styleSheet.insertRule(\n                  rule,\n                  rule.startsWith(\"@import\") ? importIndex += 1 : styleSheet.cssRules.length\n                );\n              } catch (error) {\n                context.log.warn(\"Error inserting rule from remote css import\", { rule, error });\n              }\n            }\n          }\n        });\n      })\n    );\n    const cssRules = styleSheets.flatMap((styleSheet) => Array.from(styleSheet.cssRules));\n    cssRules.filter((cssRule) => isCssFontFaceRule(cssRule) && hasCssUrl(cssRule.style.getPropertyValue(\"src\")) && splitFontFamily(cssRule.style.getPropertyValue(\"font-family\"))?.some((val) => fontFamilies.has(val))).forEach((value) => {\n      const rule = value;\n      const cssText = fontCssTexts.get(rule.cssText);\n      if (cssText) {\n        svgStyleElement.appendChild(ownerDocument.createTextNode(`${cssText}\n`));\n      } else {\n        tasks.push(\n          replaceCssUrlToDataUrl(\n            rule.cssText,\n            rule.parentStyleSheet ? rule.parentStyleSheet.href : null,\n            context\n          ).then((cssText2) => {\n            cssText2 = filterPreferredFormat(cssText2, context);\n            fontCssTexts.set(rule.cssText, cssText2);\n            svgStyleElement.appendChild(ownerDocument.createTextNode(`${cssText2}\n`));\n          })\n        );\n      }\n    });\n  }\n}\nconst COMMENTS_RE = /(\\/\\*[\\s\\S]*?\\*\\/)/g;\nconst KEYFRAMES_RE = /((@.*?keyframes [\\s\\S]*?){([\\s\\S]*?}\\s*?)})/gi;\nfunction parseCss(source) {\n  if (source == null)\n    return [];\n  const result = [];\n  let cssText = source.replace(COMMENTS_RE, \"\");\n  while (true) {\n    const matches = KEYFRAMES_RE.exec(cssText);\n    if (!matches)\n      break;\n    result.push(matches[0]);\n  }\n  cssText = cssText.replace(KEYFRAMES_RE, \"\");\n  const IMPORT_RE = /@import[\\s\\S]*?url\\([^)]*\\)[\\s\\S]*?;/gi;\n  const UNIFIED_RE = new RegExp(\n    // eslint-disable-next-line\n    \"((\\\\s*?(?:\\\\/\\\\*[\\\\s\\\\S]*?\\\\*\\\\/)?\\\\s*?@media[\\\\s\\\\S]*?){([\\\\s\\\\S]*?)}\\\\s*?})|(([\\\\s\\\\S]*?){([\\\\s\\\\S]*?)})\",\n    \"gi\"\n  );\n  while (true) {\n    let matches = IMPORT_RE.exec(cssText);\n    if (!matches) {\n      matches = UNIFIED_RE.exec(cssText);\n      if (!matches) {\n        break;\n      } else {\n        IMPORT_RE.lastIndex = UNIFIED_RE.lastIndex;\n      }\n    } else {\n      UNIFIED_RE.lastIndex = IMPORT_RE.lastIndex;\n    }\n    result.push(matches[0]);\n  }\n  return result;\n}\nconst URL_WITH_FORMAT_RE = /url\\([^)]+\\)\\s*format\\(([\"']?)([^\"']+)\\1\\)/g;\nconst FONT_SRC_RE = /src:\\s*(?:url\\([^)]+\\)\\s*format\\([^)]+\\)[,;]\\s*)+/g;\nfunction filterPreferredFormat(str, context) {\n  const { font } = context;\n  const preferredFormat = font ? font?.preferredFormat : void 0;\n  return preferredFormat ? str.replace(FONT_SRC_RE, (match) => {\n    while (true) {\n      const [src, , format] = URL_WITH_FORMAT_RE.exec(match) || [];\n      if (!format)\n        return \"\";\n      if (format === preferredFormat)\n        return `src: ${src};`;\n    }\n  }) : str;\n}\n\nasync function domToForeignObjectSvg(node, options) {\n  const context = await orCreateContext(node, options);\n  if (isElementNode(context.node) && isSVGElementNode(context.node))\n    return context.node;\n  const {\n    ownerDocument,\n    log,\n    tasks,\n    svgStyleElement,\n    svgDefsElement,\n    svgStyles,\n    font,\n    progress,\n    autoDestruct,\n    onCloneNode,\n    onEmbedNode,\n    onCreateForeignObjectSvg\n  } = context;\n  log.time(\"clone node\");\n  const clone = await cloneNode(context.node, context, true);\n  if (svgStyleElement && ownerDocument) {\n    let allCssText = \"\";\n    svgStyles.forEach((klasses, cssText) => {\n      allCssText += `${klasses.join(\",\\n\")} {\n  ${cssText}\n}\n`;\n    });\n    svgStyleElement.appendChild(ownerDocument.createTextNode(allCssText));\n  }\n  log.timeEnd(\"clone node\");\n  await onCloneNode?.(clone);\n  if (font !== false && isElementNode(clone)) {\n    log.time(\"embed web font\");\n    await embedWebFont(clone, context);\n    log.timeEnd(\"embed web font\");\n  }\n  log.time(\"embed node\");\n  embedNode(clone, context);\n  const count = tasks.length;\n  let current = 0;\n  const runTask = async () => {\n    while (true) {\n      const task = tasks.pop();\n      if (!task)\n        break;\n      try {\n        await task;\n      } catch (error) {\n        context.log.warn(\"Failed to run task\", error);\n      }\n      progress?.(++current, count);\n    }\n  };\n  progress?.(current, count);\n  await Promise.all([...Array.from({ length: 4 })].map(runTask));\n  log.timeEnd(\"embed node\");\n  await onEmbedNode?.(clone);\n  const svg = createForeignObjectSvg(clone, context);\n  svgDefsElement && svg.insertBefore(svgDefsElement, svg.children[0]);\n  svgStyleElement && svg.insertBefore(svgStyleElement, svg.children[0]);\n  autoDestruct && destroyContext(context);\n  await onCreateForeignObjectSvg?.(svg);\n  return svg;\n}\nfunction createForeignObjectSvg(clone, context) {\n  const { width, height } = context;\n  const svg = createSvg(width, height, clone.ownerDocument);\n  const foreignObject = svg.ownerDocument.createElementNS(svg.namespaceURI, \"foreignObject\");\n  foreignObject.setAttributeNS(null, \"x\", \"0%\");\n  foreignObject.setAttributeNS(null, \"y\", \"0%\");\n  foreignObject.setAttributeNS(null, \"width\", \"100%\");\n  foreignObject.setAttributeNS(null, \"height\", \"100%\");\n  foreignObject.append(clone);\n  svg.appendChild(foreignObject);\n  return svg;\n}\n\nasync function domToCanvas(node, options) {\n  const context = await orCreateContext(node, options);\n  const svg = await domToForeignObjectSvg(context);\n  const dataUrl = svgToDataUrl(svg, context.isEnable(\"removeControlCharacter\"));\n  if (!context.autoDestruct) {\n    context.svgStyleElement = createStyleElement(context.ownerDocument);\n    context.svgDefsElement = context.ownerDocument?.createElementNS(XMLNS, \"defs\");\n    context.svgStyles.clear();\n  }\n  const image = createImage(dataUrl, svg.ownerDocument);\n  return await imageToCanvas(image, context);\n}\n\nasync function domToBlob(node, options) {\n  const context = await orCreateContext(node, options);\n  const { log, type, quality, dpi } = context;\n  const canvas = await domToCanvas(context);\n  log.time(\"canvas to blob\");\n  const blob = await canvasToBlob(canvas, type, quality);\n  if ([\"image/png\", \"image/jpeg\"].includes(type) && dpi) {\n    const arrayBuffer = await blobToArrayBuffer(blob.slice(0, 33));\n    let uint8Array = new Uint8Array(arrayBuffer);\n    if (type === \"image/png\") {\n      uint8Array = changePngDpi(uint8Array, dpi);\n    } else if (type === \"image/jpeg\") {\n      uint8Array = changeJpegDpi(uint8Array, dpi);\n    }\n    log.timeEnd(\"canvas to blob\");\n    return new Blob([uint8Array, blob.slice(33)], { type });\n  }\n  log.timeEnd(\"canvas to blob\");\n  return blob;\n}\n\nasync function domToDataUrl(node, options) {\n  const context = await orCreateContext(node, options);\n  const { log, quality, type, dpi } = context;\n  const canvas = await domToCanvas(context);\n  log.time(\"canvas to data url\");\n  let dataUrl = canvas.toDataURL(type, quality);\n  if ([\"image/png\", \"image/jpeg\"].includes(type) && dpi && SUPPORT_ATOB && SUPPORT_BTOA) {\n    const [format, body] = dataUrl.split(\",\");\n    let headerLength = 0;\n    let overwritepHYs = false;\n    if (type === \"image/png\") {\n      const b64Index = detectPhysChunkFromDataUrl(body);\n      if (b64Index >= 0) {\n        headerLength = Math.ceil((b64Index + 28) / 3) * 4;\n        overwritepHYs = true;\n      } else {\n        headerLength = 33 / 3 * 4;\n      }\n    } else if (type === \"image/jpeg\") {\n      headerLength = 18 / 3 * 4;\n    }\n    const stringHeader = body.substring(0, headerLength);\n    const restOfData = body.substring(headerLength);\n    const headerBytes = window.atob(stringHeader);\n    const uint8Array = new Uint8Array(headerBytes.length);\n    for (let i = 0; i < uint8Array.length; i++) {\n      uint8Array[i] = headerBytes.charCodeAt(i);\n    }\n    const finalArray = type === \"image/png\" ? changePngDpi(uint8Array, dpi, overwritepHYs) : changeJpegDpi(uint8Array, dpi);\n    const base64Header = window.btoa(String.fromCharCode(...finalArray));\n    dataUrl = [format, \",\", base64Header, restOfData].join(\"\");\n  }\n  log.timeEnd(\"canvas to data url\");\n  return dataUrl;\n}\n\nasync function domToSvg(node, options) {\n  const context = await orCreateContext(node, options);\n  const { width, height, ownerDocument } = context;\n  const dataUrl = await domToDataUrl(context);\n  const svg = createSvg(width, height, ownerDocument);\n  const svgImage = svg.ownerDocument.createElementNS(svg.namespaceURI, \"image\");\n  svgImage.setAttributeNS(null, \"href\", dataUrl);\n  svgImage.setAttributeNS(null, \"height\", \"100%\");\n  svgImage.setAttributeNS(null, \"width\", \"100%\");\n  svg.appendChild(svgImage);\n  return svgToDataUrl(svg, context.isEnable(\"removeControlCharacter\"));\n}\n\nasync function domToImage(node, options) {\n  const context = await orCreateContext(node, options);\n  const { ownerDocument, width, height, scale, type } = context;\n  const url = type === \"image/svg+xml\" ? await domToSvg(context) : await domToDataUrl(context);\n  const image = createImage(url, ownerDocument);\n  image.width = Math.floor(width * scale);\n  image.height = Math.floor(height * scale);\n  image.style.width = `${width}px`;\n  image.style.height = `${height}px`;\n  return image;\n}\n\nasync function domToJpeg(node, options) {\n  return domToDataUrl(\n    await orCreateContext(node, { ...options, type: \"image/jpeg\" })\n  );\n}\n\nasync function domToPixel(node, options) {\n  const context = await orCreateContext(node, options);\n  const canvas = await domToCanvas(context);\n  return canvas.getContext(\"2d\").getImageData(0, 0, canvas.width, canvas.height).data;\n}\n\nasync function domToPng(node, options) {\n  return domToDataUrl(\n    await orCreateContext(node, { ...options, type: \"image/png\" })\n  );\n}\n\nasync function domToWebp(node, options) {\n  return domToDataUrl(\n    await orCreateContext(node, { ...options, type: \"image/webp\" })\n  );\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbW9kZXJuLXNjcmVlbnNob3QvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix1QkFBdUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFFBQVE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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VUFBVSw0Q0FBNEM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsTUFBTTtBQUMvQiwwQkFBMEIsT0FBTztBQUNqQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0MsZ0NBQWdDO0FBQ2xFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0NBQWtDLCtCQUErQjtBQUNqRTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0MsZ0NBQWdDO0FBQ2xFO0FBQ0E7O0FBRWtNIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2luZW1hX3Bvc3Rlci8uL25vZGVfbW9kdWxlcy9tb2Rlcm4tc2NyZWVuc2hvdC9kaXN0L2luZGV4Lm1qcz9iYzVkIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGNoYW5nZUpwZWdEcGkodWludDhBcnJheSwgZHBpKSB7XG4gIHVpbnQ4QXJyYXlbMTNdID0gMTtcbiAgdWludDhBcnJheVsxNF0gPSBkcGkgPj4gODtcbiAgdWludDhBcnJheVsxNV0gPSBkcGkgJiAyNTU7XG4gIHVpbnQ4QXJyYXlbMTZdID0gZHBpID4+IDg7XG4gIHVpbnQ4QXJyYXlbMTddID0gZHBpICYgMjU1O1xuICByZXR1cm4gdWludDhBcnJheTtcbn1cblxuY29uc3QgX1AgPSBcInBcIi5jaGFyQ29kZUF0KDApO1xuY29uc3QgX0ggPSBcIkhcIi5jaGFyQ29kZUF0KDApO1xuY29uc3QgX1kgPSBcIllcIi5jaGFyQ29kZUF0KDApO1xuY29uc3QgX1MgPSBcInNcIi5jaGFyQ29kZUF0KDApO1xubGV0IHBuZ0RhdGFUYWJsZTtcbmZ1bmN0aW9uIGNyZWF0ZVBuZ0RhdGFUYWJsZSgpIHtcbiAgY29uc3QgY3JjVGFibGUgPSBuZXcgSW50MzJBcnJheSgyNTYpO1xuICBmb3IgKGxldCBuID0gMDsgbiA8IDI1NjsgbisrKSB7XG4gICAgbGV0IGMgPSBuO1xuICAgIGZvciAobGV0IGsgPSAwOyBrIDwgODsgaysrKSB7XG4gICAgICBjID0gYyAmIDEgPyAzOTg4MjkyMzg0IF4gYyA+Pj4gMSA6IGMgPj4+IDE7XG4gICAgfVxuICAgIGNyY1RhYmxlW25dID0gYztcbiAgfVxuICByZXR1cm4gY3JjVGFibGU7XG59XG5mdW5jdGlvbiBjYWxjQ3JjKHVpbnQ4QXJyYXkpIHtcbiAgbGV0IGMgPSAtMTtcbiAgaWYgKCFwbmdEYXRhVGFibGUpXG4gICAgcG5nRGF0YVRhYmxlID0gY3JlYXRlUG5nRGF0YVRhYmxlKCk7XG4gIGZvciAobGV0IG4gPSAwOyBuIDwgdWludDhBcnJheS5sZW5ndGg7IG4rKykge1xuICAgIGMgPSBwbmdEYXRhVGFibGVbKGMgXiB1aW50OEFycmF5W25dKSAmIDI1NV0gXiBjID4+PiA4O1xuICB9XG4gIHJldHVybiBjIF4gLTE7XG59XG5mdW5jdGlvbiBzZWFyY2hTdGFydE9mUGh5cyh1aW50OEFycmF5KSB7XG4gIGNvbnN0IGxlbmd0aCA9IHVpbnQ4QXJyYXkubGVuZ3RoIC0gMTtcbiAgZm9yIChsZXQgaSA9IGxlbmd0aDsgaSA+PSA0OyBpLS0pIHtcbiAgICBpZiAodWludDhBcnJheVtpIC0gNF0gPT09IDkgJiYgdWludDhBcnJheVtpIC0gM10gPT09IF9QICYmIHVpbnQ4QXJyYXlbaSAtIDJdID09PSBfSCAmJiB1aW50OEFycmF5W2kgLSAxXSA9PT0gX1kgJiYgdWludDhBcnJheVtpXSA9PT0gX1MpIHtcbiAgICAgIHJldHVybiBpIC0gMztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiBjaGFuZ2VQbmdEcGkodWludDhBcnJheSwgZHBpLCBvdmVyd3JpdGVwSFlzID0gZmFsc2UpIHtcbiAgY29uc3QgcGh5c0NodW5rID0gbmV3IFVpbnQ4QXJyYXkoMTMpO1xuICBkcGkgKj0gMzkuMzcwMTtcbiAgcGh5c0NodW5rWzBdID0gX1A7XG4gIHBoeXNDaHVua1sxXSA9IF9IO1xuICBwaHlzQ2h1bmtbMl0gPSBfWTtcbiAgcGh5c0NodW5rWzNdID0gX1M7XG4gIHBoeXNDaHVua1s0XSA9IGRwaSA+Pj4gMjQ7XG4gIHBoeXNDaHVua1s1XSA9IGRwaSA+Pj4gMTY7XG4gIHBoeXNDaHVua1s2XSA9IGRwaSA+Pj4gODtcbiAgcGh5c0NodW5rWzddID0gZHBpICYgMjU1O1xuICBwaHlzQ2h1bmtbOF0gPSBwaHlzQ2h1bmtbNF07XG4gIHBoeXNDaHVua1s5XSA9IHBoeXNDaHVua1s1XTtcbiAgcGh5c0NodW5rWzEwXSA9IHBoeXNDaHVua1s2XTtcbiAgcGh5c0NodW5rWzExXSA9IHBoeXNDaHVua1s3XTtcbiAgcGh5c0NodW5rWzEyXSA9IDE7XG4gIGNvbnN0IGNyYyA9IGNhbGNDcmMocGh5c0NodW5rKTtcbiAgY29uc3QgY3JjQ2h1bmsgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgY3JjQ2h1bmtbMF0gPSBjcmMgPj4+IDI0O1xuICBjcmNDaHVua1sxXSA9IGNyYyA+Pj4gMTY7XG4gIGNyY0NodW5rWzJdID0gY3JjID4+PiA4O1xuICBjcmNDaHVua1szXSA9IGNyYyAmIDI1NTtcbiAgaWYgKG92ZXJ3cml0ZXBIWXMpIHtcbiAgICBjb25zdCBzdGFydGluZ0luZGV4ID0gc2VhcmNoU3RhcnRPZlBoeXModWludDhBcnJheSk7XG4gICAgdWludDhBcnJheS5zZXQocGh5c0NodW5rLCBzdGFydGluZ0luZGV4KTtcbiAgICB1aW50OEFycmF5LnNldChjcmNDaHVuaywgc3RhcnRpbmdJbmRleCArIDEzKTtcbiAgICByZXR1cm4gdWludDhBcnJheTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBjaHVua0xlbmd0aCA9IG5ldyBVaW50OEFycmF5KDQpO1xuICAgIGNodW5rTGVuZ3RoWzBdID0gMDtcbiAgICBjaHVua0xlbmd0aFsxXSA9IDA7XG4gICAgY2h1bmtMZW5ndGhbMl0gPSAwO1xuICAgIGNodW5rTGVuZ3RoWzNdID0gOTtcbiAgICBjb25zdCBmaW5hbEhlYWRlciA9IG5ldyBVaW50OEFycmF5KDU0KTtcbiAgICBmaW5hbEhlYWRlci5zZXQodWludDhBcnJheSwgMCk7XG4gICAgZmluYWxIZWFkZXIuc2V0KGNodW5rTGVuZ3RoLCAzMyk7XG4gICAgZmluYWxIZWFkZXIuc2V0KHBoeXNDaHVuaywgMzcpO1xuICAgIGZpbmFsSGVhZGVyLnNldChjcmNDaHVuaywgNTApO1xuICAgIHJldHVybiBmaW5hbEhlYWRlcjtcbiAgfVxufVxuY29uc3QgYjY0UGh5c1NpZ25hdHVyZTEgPSBcIkFBbHdTRmx6XCI7XG5jb25zdCBiNjRQaHlzU2lnbmF0dXJlMiA9IFwiQUFBSmNFaFpcIjtcbmNvbnN0IGI2NFBoeXNTaWduYXR1cmUzID0gXCJBQUFBQ1hCSVwiO1xuZnVuY3Rpb24gZGV0ZWN0UGh5c0NodW5rRnJvbURhdGFVcmwoZGF0YVVybCkge1xuICBsZXQgYjY0aW5kZXggPSBkYXRhVXJsLmluZGV4T2YoYjY0UGh5c1NpZ25hdHVyZTEpO1xuICBpZiAoYjY0aW5kZXggPT09IC0xKSB7XG4gICAgYjY0aW5kZXggPSBkYXRhVXJsLmluZGV4T2YoYjY0UGh5c1NpZ25hdHVyZTIpO1xuICB9XG4gIGlmIChiNjRpbmRleCA9PT0gLTEpIHtcbiAgICBiNjRpbmRleCA9IGRhdGFVcmwuaW5kZXhPZihiNjRQaHlzU2lnbmF0dXJlMyk7XG4gIH1cbiAgcmV0dXJuIGI2NGluZGV4O1xufVxuXG5jb25zdCBQUkVGSVggPSBcIlttb2Rlcm4tc2NyZWVuc2hvdF1cIjtcbmNvbnN0IElOX0JST1dTRVIgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiO1xuY29uc3QgU1VQUE9SVF9XRUJfV09SS0VSID0gSU5fQlJPV1NFUiAmJiBcIldvcmtlclwiIGluIHdpbmRvdztcbmNvbnN0IFNVUFBPUlRfQVRPQiA9IElOX0JST1dTRVIgJiYgXCJhdG9iXCIgaW4gd2luZG93O1xuY29uc3QgU1VQUE9SVF9CVE9BID0gSU5fQlJPV1NFUiAmJiBcImJ0b2FcIiBpbiB3aW5kb3c7XG5jb25zdCBVU0VSX0FHRU5UID0gSU5fQlJPV1NFUiA/IHdpbmRvdy5uYXZpZ2F0b3I/LnVzZXJBZ2VudCA6IFwiXCI7XG5jb25zdCBJTl9DSFJPTUUgPSBVU0VSX0FHRU5ULmluY2x1ZGVzKFwiQ2hyb21lXCIpO1xuY29uc3QgSU5fU0FGQVJJID0gVVNFUl9BR0VOVC5pbmNsdWRlcyhcIkFwcGxlV2ViS2l0XCIpICYmICFJTl9DSFJPTUU7XG5jb25zdCBJTl9GSVJFRk9YID0gVVNFUl9BR0VOVC5pbmNsdWRlcyhcIkZpcmVmb3hcIik7XG5jb25zdCBpc0NvbnRleHQgPSAodmFsdWUpID0+IHZhbHVlICYmIFwiX19DT05URVhUX19cIiBpbiB2YWx1ZTtcbmNvbnN0IGlzQ3NzRm9udEZhY2VSdWxlID0gKHJ1bGUpID0+IHJ1bGUuY29uc3RydWN0b3IubmFtZSA9PT0gXCJDU1NGb250RmFjZVJ1bGVcIjtcbmNvbnN0IGlzQ1NTSW1wb3J0UnVsZSA9IChydWxlKSA9PiBydWxlLmNvbnN0cnVjdG9yLm5hbWUgPT09IFwiQ1NTSW1wb3J0UnVsZVwiO1xuY29uc3QgaXNFbGVtZW50Tm9kZSA9IChub2RlKSA9PiBub2RlLm5vZGVUeXBlID09PSAxO1xuY29uc3QgaXNTVkdFbGVtZW50Tm9kZSA9IChub2RlKSA9PiB0eXBlb2Ygbm9kZS5jbGFzc05hbWUgPT09IFwib2JqZWN0XCI7XG5jb25zdCBpc1NWR0ltYWdlRWxlbWVudE5vZGUgPSAobm9kZSkgPT4gbm9kZS50YWdOYW1lID09PSBcImltYWdlXCI7XG5jb25zdCBpc1NWR1VzZUVsZW1lbnROb2RlID0gKG5vZGUpID0+IG5vZGUudGFnTmFtZSA9PT0gXCJ1c2VcIjtcbmNvbnN0IGlzSFRNTEVsZW1lbnROb2RlID0gKG5vZGUpID0+IGlzRWxlbWVudE5vZGUobm9kZSkgJiYgdHlwZW9mIG5vZGUuc3R5bGUgIT09IFwidW5kZWZpbmVkXCIgJiYgIWlzU1ZHRWxlbWVudE5vZGUobm9kZSk7XG5jb25zdCBpc0NvbW1lbnROb2RlID0gKG5vZGUpID0+IG5vZGUubm9kZVR5cGUgPT09IDg7XG5jb25zdCBpc1RleHROb2RlID0gKG5vZGUpID0+IG5vZGUubm9kZVR5cGUgPT09IDM7XG5jb25zdCBpc0ltYWdlRWxlbWVudCA9IChub2RlKSA9PiBub2RlLnRhZ05hbWUgPT09IFwiSU1HXCI7XG5jb25zdCBpc1ZpZGVvRWxlbWVudCA9IChub2RlKSA9PiBub2RlLnRhZ05hbWUgPT09IFwiVklERU9cIjtcbmNvbnN0IGlzQ2FudmFzRWxlbWVudCA9IChub2RlKSA9PiBub2RlLnRhZ05hbWUgPT09IFwiQ0FOVkFTXCI7XG5jb25zdCBpc1RleHRhcmVhRWxlbWVudCA9IChub2RlKSA9PiBub2RlLnRhZ05hbWUgPT09IFwiVEVYVEFSRUFcIjtcbmNvbnN0IGlzSW5wdXRFbGVtZW50ID0gKG5vZGUpID0+IG5vZGUudGFnTmFtZSA9PT0gXCJJTlBVVFwiO1xuY29uc3QgaXNTdHlsZUVsZW1lbnQgPSAobm9kZSkgPT4gbm9kZS50YWdOYW1lID09PSBcIlNUWUxFXCI7XG5jb25zdCBpc1NjcmlwdEVsZW1lbnQgPSAobm9kZSkgPT4gbm9kZS50YWdOYW1lID09PSBcIlNDUklQVFwiO1xuY29uc3QgaXNTZWxlY3RFbGVtZW50ID0gKG5vZGUpID0+IG5vZGUudGFnTmFtZSA9PT0gXCJTRUxFQ1RcIjtcbmNvbnN0IGlzU2xvdEVsZW1lbnQgPSAobm9kZSkgPT4gbm9kZS50YWdOYW1lID09PSBcIlNMT1RcIjtcbmNvbnN0IGlzSUZyYW1lRWxlbWVudCA9IChub2RlKSA9PiBub2RlLnRhZ05hbWUgPT09IFwiSUZSQU1FXCI7XG5jb25zdCBjb25zb2xlV2FybiA9ICguLi5hcmdzKSA9PiBjb25zb2xlLndhcm4oUFJFRklYLCAuLi5hcmdzKTtcbmZ1bmN0aW9uIHN1cHBvcnRXZWJwKG93bmVyRG9jdW1lbnQpIHtcbiAgY29uc3QgY2FudmFzID0gb3duZXJEb2N1bWVudD8uY3JlYXRlRWxlbWVudD8uKFwiY2FudmFzXCIpO1xuICBpZiAoY2FudmFzKSB7XG4gICAgY2FudmFzLmhlaWdodCA9IGNhbnZhcy53aWR0aCA9IDE7XG4gIH1cbiAgcmV0dXJuIEJvb2xlYW4oY2FudmFzKSAmJiBcInRvRGF0YVVSTFwiIGluIGNhbnZhcyAmJiBCb29sZWFuKGNhbnZhcy50b0RhdGFVUkwoXCJpbWFnZS93ZWJwXCIpLmluY2x1ZGVzKFwiaW1hZ2Uvd2VicFwiKSk7XG59XG5jb25zdCBpc0RhdGFVcmwgPSAodXJsKSA9PiB1cmwuc3RhcnRzV2l0aChcImRhdGE6XCIpO1xuZnVuY3Rpb24gcmVzb2x2ZVVybCh1cmwsIGJhc2VVcmwpIHtcbiAgaWYgKHVybC5tYXRjaCgvXlthLXpdKzpcXC9cXC8vaSkpXG4gICAgcmV0dXJuIHVybDtcbiAgaWYgKElOX0JST1dTRVIgJiYgdXJsLm1hdGNoKC9eXFwvXFwvLykpXG4gICAgcmV0dXJuIHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCArIHVybDtcbiAgaWYgKHVybC5tYXRjaCgvXlthLXpdKzovaSkpXG4gICAgcmV0dXJuIHVybDtcbiAgaWYgKCFJTl9CUk9XU0VSKVxuICAgIHJldHVybiB1cmw7XG4gIGNvbnN0IGRvYyA9IGdldERvY3VtZW50KCkuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCk7XG4gIGNvbnN0IGJhc2UgPSBkb2MuY3JlYXRlRWxlbWVudChcImJhc2VcIik7XG4gIGNvbnN0IGEgPSBkb2MuY3JlYXRlRWxlbWVudChcImFcIik7XG4gIGRvYy5oZWFkLmFwcGVuZENoaWxkKGJhc2UpO1xuICBkb2MuYm9keS5hcHBlbmRDaGlsZChhKTtcbiAgaWYgKGJhc2VVcmwpXG4gICAgYmFzZS5ocmVmID0gYmFzZVVybDtcbiAgYS5ocmVmID0gdXJsO1xuICByZXR1cm4gYS5ocmVmO1xufVxuZnVuY3Rpb24gZ2V0RG9jdW1lbnQodGFyZ2V0KSB7XG4gIHJldHVybiAodGFyZ2V0ICYmIGlzRWxlbWVudE5vZGUodGFyZ2V0KSA/IHRhcmdldD8ub3duZXJEb2N1bWVudCA6IHRhcmdldCkgPz8gd2luZG93LmRvY3VtZW50O1xufVxuY29uc3QgWE1MTlMgPSBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI7XG5mdW5jdGlvbiBjcmVhdGVTdmcod2lkdGgsIGhlaWdodCwgb3duZXJEb2N1bWVudCkge1xuICBjb25zdCBzdmcgPSBnZXREb2N1bWVudChvd25lckRvY3VtZW50KS5jcmVhdGVFbGVtZW50TlMoWE1MTlMsIFwic3ZnXCIpO1xuICBzdmcuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ3aWR0aFwiLCB3aWR0aC50b1N0cmluZygpKTtcbiAgc3ZnLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiaGVpZ2h0XCIsIGhlaWdodC50b1N0cmluZygpKTtcbiAgc3ZnLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwidmlld0JveFwiLCBgMCAwICR7d2lkdGh9ICR7aGVpZ2h0fWApO1xuICByZXR1cm4gc3ZnO1xufVxuZnVuY3Rpb24gc3ZnVG9EYXRhVXJsKHN2ZywgcmVtb3ZlQ29udHJvbENoYXJhY3Rlcikge1xuICBsZXQgeGh0bWwgPSBuZXcgWE1MU2VyaWFsaXplcigpLnNlcmlhbGl6ZVRvU3RyaW5nKHN2Zyk7XG4gIGlmIChyZW1vdmVDb250cm9sQ2hhcmFjdGVyKSB7XG4gICAgeGh0bWwgPSB4aHRtbC5yZXBsYWNlKC9bXFx1MDAwMC1cXHUwMDA4XFx2XFxmXFx1MDAwRS1cXHUwMDFGXFx1RDgwMC1cXHVERkZGXFx1RkZGRVxcdUZGRkZdL2d1LCBcIlwiKTtcbiAgfVxuICByZXR1cm4gYGRhdGE6aW1hZ2Uvc3ZnK3htbDtjaGFyc2V0PXV0Zi04LCR7ZW5jb2RlVVJJQ29tcG9uZW50KHhodG1sKX1gO1xufVxuYXN5bmMgZnVuY3Rpb24gY2FudmFzVG9CbG9iKGNhbnZhcywgdHlwZSA9IFwiaW1hZ2UvcG5nXCIsIHF1YWxpdHkgPSAxKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNhbnZhcy50b0Jsb2IoKGJsb2IpID0+IHtcbiAgICAgICAgaWYgKGJsb2IpIHtcbiAgICAgICAgICByZXNvbHZlKGJsb2IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJCbG9iIGlzIG51bGxcIikpO1xuICAgICAgICB9XG4gICAgICB9LCB0eXBlLCBxdWFsaXR5KTtcbiAgICB9KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoU1VQUE9SVF9BVE9CKSB7XG4gICAgICByZXR1cm4gZGF0YVVybFRvQmxvYihjYW52YXMudG9EYXRhVVJMKHR5cGUsIHF1YWxpdHkpKTtcbiAgICB9XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cbmZ1bmN0aW9uIGRhdGFVcmxUb0Jsb2IoZGF0YVVybCkge1xuICBjb25zdCBbaGVhZGVyLCBiYXNlNjRdID0gZGF0YVVybC5zcGxpdChcIixcIik7XG4gIGNvbnN0IHR5cGUgPSBoZWFkZXIubWF0Y2goL2RhdGE6KC4rKTsvKT8uWzFdID8/IHZvaWQgMDtcbiAgY29uc3QgZGVjb2RlZCA9IHdpbmRvdy5hdG9iKGJhc2U2NCk7XG4gIGNvbnN0IGxlbmd0aCA9IGRlY29kZWQubGVuZ3RoO1xuICBjb25zdCBidWZmZXIgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgYnVmZmVyW2ldID0gZGVjb2RlZC5jaGFyQ29kZUF0KGkpO1xuICB9XG4gIHJldHVybiBuZXcgQmxvYihbYnVmZmVyXSwgeyB0eXBlIH0pO1xufVxuZnVuY3Rpb24gcmVhZEJsb2IoYmxvYiwgdHlwZSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgcmVhZGVyLm9ubG9hZCA9ICgpID0+IHJlc29sdmUocmVhZGVyLnJlc3VsdCk7XG4gICAgcmVhZGVyLm9uZXJyb3IgPSAoKSA9PiByZWplY3QocmVhZGVyLmVycm9yKTtcbiAgICByZWFkZXIub25hYm9ydCA9ICgpID0+IHJlamVjdChuZXcgRXJyb3IoYEZhaWxlZCByZWFkIGJsb2IgdG8gJHt0eXBlfWApKTtcbiAgICBpZiAodHlwZSA9PT0gXCJkYXRhVXJsXCIpIHtcbiAgICAgIHJlYWRlci5yZWFkQXNEYXRhVVJMKGJsb2IpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJhcnJheUJ1ZmZlclwiKSB7XG4gICAgICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoYmxvYik7XG4gICAgfVxuICB9KTtcbn1cbmNvbnN0IGJsb2JUb0RhdGFVcmwgPSAoYmxvYikgPT4gcmVhZEJsb2IoYmxvYiwgXCJkYXRhVXJsXCIpO1xuY29uc3QgYmxvYlRvQXJyYXlCdWZmZXIgPSAoYmxvYikgPT4gcmVhZEJsb2IoYmxvYiwgXCJhcnJheUJ1ZmZlclwiKTtcbmZ1bmN0aW9uIGNyZWF0ZUltYWdlKHVybCwgb3duZXJEb2N1bWVudCkge1xuICBjb25zdCBpbWcgPSBnZXREb2N1bWVudChvd25lckRvY3VtZW50KS5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xuICBpbWcuZGVjb2RpbmcgPSBcInN5bmNcIjtcbiAgaW1nLmxvYWRpbmcgPSBcImVhZ2VyXCI7XG4gIGltZy5zcmMgPSB1cmw7XG4gIHJldHVybiBpbWc7XG59XG5mdW5jdGlvbiBsb2FkTWVkaWEobWVkaWEsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgY29uc3QgeyB0aW1lb3V0LCBvd25lckRvY3VtZW50LCBvbkVycm9yOiB1c2VyT25FcnJvciwgb25XYXJuIH0gPSBvcHRpb25zID8/IHt9O1xuICAgIGNvbnN0IG5vZGUgPSB0eXBlb2YgbWVkaWEgPT09IFwic3RyaW5nXCIgPyBjcmVhdGVJbWFnZShtZWRpYSwgZ2V0RG9jdW1lbnQob3duZXJEb2N1bWVudCkpIDogbWVkaWE7XG4gICAgbGV0IHRpbWVyID0gbnVsbDtcbiAgICBsZXQgcmVtb3ZlRXZlbnRMaXN0ZW5lcnMgPSBudWxsO1xuICAgIGZ1bmN0aW9uIG9uUmVzb2x2ZSgpIHtcbiAgICAgIHJlc29sdmUobm9kZSk7XG4gICAgICB0aW1lciAmJiBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcnM/LigpO1xuICAgIH1cbiAgICBpZiAodGltZW91dCkge1xuICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KG9uUmVzb2x2ZSwgdGltZW91dCk7XG4gICAgfVxuICAgIGlmIChpc1ZpZGVvRWxlbWVudChub2RlKSkge1xuICAgICAgY29uc3QgY3VycmVudFNyYyA9IG5vZGUuY3VycmVudFNyYyB8fCBub2RlLnNyYztcbiAgICAgIGlmICghY3VycmVudFNyYykge1xuICAgICAgICBpZiAobm9kZS5wb3N0ZXIpIHtcbiAgICAgICAgICByZXR1cm4gbG9hZE1lZGlhKG5vZGUucG9zdGVyLCBvcHRpb25zKS50aGVuKHJlc29sdmUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvblJlc29sdmUoKTtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlLnJlYWR5U3RhdGUgPj0gMikge1xuICAgICAgICByZXR1cm4gb25SZXNvbHZlKCk7XG4gICAgICB9XG4gICAgICBjb25zdCBvbkxvYWRlZGRhdGEgPSBvblJlc29sdmU7XG4gICAgICBjb25zdCBvbkVycm9yID0gKGVycm9yKSA9PiB7XG4gICAgICAgIG9uV2Fybj8uKFxuICAgICAgICAgIFwiRmFpbGVkIHZpZGVvIGxvYWRcIixcbiAgICAgICAgICBjdXJyZW50U3JjLFxuICAgICAgICAgIGVycm9yXG4gICAgICAgICk7XG4gICAgICAgIHVzZXJPbkVycm9yPy4oZXJyb3IpO1xuICAgICAgICBvblJlc29sdmUoKTtcbiAgICAgIH07XG4gICAgICByZW1vdmVFdmVudExpc3RlbmVycyA9ICgpID0+IHtcbiAgICAgICAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwibG9hZGVkZGF0YVwiLCBvbkxvYWRlZGRhdGEpO1xuICAgICAgICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCBvbkVycm9yKTtcbiAgICAgIH07XG4gICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkZWRkYXRhXCIsIG9uTG9hZGVkZGF0YSwgeyBvbmNlOiB0cnVlIH0pO1xuICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgb25FcnJvciwgeyBvbmNlOiB0cnVlIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjdXJyZW50U3JjID0gaXNTVkdJbWFnZUVsZW1lbnROb2RlKG5vZGUpID8gbm9kZS5ocmVmLmJhc2VWYWwgOiBub2RlLmN1cnJlbnRTcmMgfHwgbm9kZS5zcmM7XG4gICAgICBpZiAoIWN1cnJlbnRTcmMpIHtcbiAgICAgICAgcmV0dXJuIG9uUmVzb2x2ZSgpO1xuICAgICAgfVxuICAgICAgY29uc3Qgb25Mb2FkID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICBpZiAoaXNJbWFnZUVsZW1lbnQobm9kZSkgJiYgXCJkZWNvZGVcIiBpbiBub2RlKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IG5vZGUuZGVjb2RlKCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIG9uV2Fybj8uKFxuICAgICAgICAgICAgICBcIkZhaWxlZCB0byBkZWNvZGUgaW1hZ2UsIHRyeWluZyB0byByZW5kZXIgYW55d2F5XCIsXG4gICAgICAgICAgICAgIG5vZGUuZGF0YXNldC5vcmlnaW5hbFNyYyB8fCBjdXJyZW50U3JjLFxuICAgICAgICAgICAgICBlcnJvclxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgb25SZXNvbHZlKCk7XG4gICAgICB9O1xuICAgICAgY29uc3Qgb25FcnJvciA9IChlcnJvcikgPT4ge1xuICAgICAgICBvbldhcm4/LihcbiAgICAgICAgICBcIkZhaWxlZCBpbWFnZSBsb2FkXCIsXG4gICAgICAgICAgbm9kZS5kYXRhc2V0Lm9yaWdpbmFsU3JjIHx8IGN1cnJlbnRTcmMsXG4gICAgICAgICAgZXJyb3JcbiAgICAgICAgKTtcbiAgICAgICAgb25SZXNvbHZlKCk7XG4gICAgICB9O1xuICAgICAgaWYgKGlzSW1hZ2VFbGVtZW50KG5vZGUpICYmIG5vZGUuY29tcGxldGUpIHtcbiAgICAgICAgcmV0dXJuIG9uTG9hZCgpO1xuICAgICAgfVxuICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcnMgPSAoKSA9PiB7XG4gICAgICAgIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgb25Mb2FkKTtcbiAgICAgICAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgb25FcnJvcik7XG4gICAgICB9O1xuICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCBvbkxvYWQsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIG9uRXJyb3IsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICB9XG4gIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gd2FpdFVudGlsTG9hZChub2RlLCBvcHRpb25zKSB7XG4gIGlmIChpc0hUTUxFbGVtZW50Tm9kZShub2RlKSkge1xuICAgIGlmIChpc0ltYWdlRWxlbWVudChub2RlKSB8fCBpc1ZpZGVvRWxlbWVudChub2RlKSkge1xuICAgICAgYXdhaXQgbG9hZE1lZGlhKG5vZGUsIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgW1wiaW1nXCIsIFwidmlkZW9cIl0uZmxhdE1hcCgoc2VsZWN0b3JzKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIEFycmF5LmZyb20obm9kZS5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9ycykpLm1hcCgoZWwpID0+IGxvYWRNZWRpYShlbCwgb3B0aW9ucykpO1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cbmNvbnN0IHV1aWQgPSAvKiBAX19QVVJFX18gKi8gZnVuY3Rpb24gdXVpZDIoKSB7XG4gIGxldCBjb3VudGVyID0gMDtcbiAgY29uc3QgcmFuZG9tID0gKCkgPT4gYDAwMDAkeyhNYXRoLnJhbmRvbSgpICogMzYgKiogNCA8PCAwKS50b1N0cmluZygzNil9YC5zbGljZSgtNCk7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgY291bnRlciArPSAxO1xuICAgIHJldHVybiBgdSR7cmFuZG9tKCl9JHtjb3VudGVyfWA7XG4gIH07XG59KCk7XG5mdW5jdGlvbiBzcGxpdEZvbnRGYW1pbHkoZm9udEZhbWlseSkge1xuICByZXR1cm4gZm9udEZhbWlseT8uc3BsaXQoXCIsXCIpLm1hcCgodmFsKSA9PiB2YWwudHJpbSgpLnJlcGxhY2UoL1wifCcvZywgXCJcIikudG9Mb3dlckNhc2UoKSkuZmlsdGVyKEJvb2xlYW4pO1xufVxuXG5sZXQgdWlkID0gMDtcbmZ1bmN0aW9uIGNyZWF0ZUxvZ2dlcihkZWJ1Zykge1xuICBjb25zdCBwcmVmaXggPSBgJHtQUkVGSVh9WyMke3VpZH1dYDtcbiAgdWlkKys7XG4gIHJldHVybiB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICB0aW1lOiAobGFiZWwpID0+IGRlYnVnICYmIGNvbnNvbGUudGltZShgJHtwcmVmaXh9ICR7bGFiZWx9YCksXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICB0aW1lRW5kOiAobGFiZWwpID0+IGRlYnVnICYmIGNvbnNvbGUudGltZUVuZChgJHtwcmVmaXh9ICR7bGFiZWx9YCksXG4gICAgd2FybjogKC4uLmFyZ3MpID0+IGRlYnVnICYmIGNvbnNvbGVXYXJuKC4uLmFyZ3MpXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldERlZmF1bHRSZXF1ZXN0SW5pdChieXBhc3NpbmdDYWNoZSkge1xuICByZXR1cm4ge1xuICAgIGNhY2hlOiBieXBhc3NpbmdDYWNoZSA/IFwibm8tY2FjaGVcIiA6IFwiZm9yY2UtY2FjaGVcIlxuICB9O1xufVxuXG5hc3luYyBmdW5jdGlvbiBvckNyZWF0ZUNvbnRleHQobm9kZSwgb3B0aW9ucykge1xuICByZXR1cm4gaXNDb250ZXh0KG5vZGUpID8gbm9kZSA6IGNyZWF0ZUNvbnRleHQobm9kZSwgeyAuLi5vcHRpb25zLCBhdXRvRGVzdHJ1Y3Q6IHRydWUgfSk7XG59XG5hc3luYyBmdW5jdGlvbiBjcmVhdGVDb250ZXh0KG5vZGUsIG9wdGlvbnMpIHtcbiAgY29uc3QgeyBzY2FsZSA9IDEsIHdvcmtlclVybCwgd29ya2VyTnVtYmVyID0gMSB9ID0gb3B0aW9ucyB8fCB7fTtcbiAgY29uc3QgZGVidWcgPSBCb29sZWFuKG9wdGlvbnM/LmRlYnVnKTtcbiAgY29uc3QgZmVhdHVyZXMgPSBvcHRpb25zPy5mZWF0dXJlcyA/PyB0cnVlO1xuICBjb25zdCBvd25lckRvY3VtZW50ID0gbm9kZS5vd25lckRvY3VtZW50ID8/IChJTl9CUk9XU0VSID8gd2luZG93LmRvY3VtZW50IDogdm9pZCAwKTtcbiAgY29uc3Qgb3duZXJXaW5kb3cgPSBub2RlLm93bmVyRG9jdW1lbnQ/LmRlZmF1bHRWaWV3ID8/IChJTl9CUk9XU0VSID8gd2luZG93IDogdm9pZCAwKTtcbiAgY29uc3QgcmVxdWVzdHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdCBjb250ZXh0ID0ge1xuICAgIC8vIE9wdGlvbnNcbiAgICB3aWR0aDogMCxcbiAgICBoZWlnaHQ6IDAsXG4gICAgcXVhbGl0eTogMSxcbiAgICB0eXBlOiBcImltYWdlL3BuZ1wiLFxuICAgIHNjYWxlLFxuICAgIGJhY2tncm91bmRDb2xvcjogbnVsbCxcbiAgICBzdHlsZTogbnVsbCxcbiAgICBmaWx0ZXI6IG51bGwsXG4gICAgbWF4aW11bUNhbnZhc1NpemU6IDAsXG4gICAgdGltZW91dDogM2U0LFxuICAgIHByb2dyZXNzOiBudWxsLFxuICAgIGRlYnVnLFxuICAgIGZldGNoOiB7XG4gICAgICByZXF1ZXN0SW5pdDogZ2V0RGVmYXVsdFJlcXVlc3RJbml0KG9wdGlvbnM/LmZldGNoPy5ieXBhc3NpbmdDYWNoZSksXG4gICAgICBwbGFjZWhvbGRlckltYWdlOiBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxSMGxHT0RsaEFRQUJBSUFBQUFBQUFQLy8veUg1QkFFQUFBQUFMQUFBQUFBQkFBRUFBQUlCUkFBN1wiLFxuICAgICAgYnlwYXNzaW5nQ2FjaGU6IGZhbHNlLFxuICAgICAgLi4ub3B0aW9ucz8uZmV0Y2hcbiAgICB9LFxuICAgIGZldGNoRm46IG51bGwsXG4gICAgZm9udDoge30sXG4gICAgZHJhd0ltYWdlSW50ZXJ2YWw6IDEwMCxcbiAgICB3b3JrZXJVcmw6IG51bGwsXG4gICAgd29ya2VyTnVtYmVyLFxuICAgIG9uQ2xvbmVFYWNoTm9kZTogbnVsbCxcbiAgICBvbkNsb25lTm9kZTogbnVsbCxcbiAgICBvbkVtYmVkTm9kZTogbnVsbCxcbiAgICBvbkNyZWF0ZUZvcmVpZ25PYmplY3RTdmc6IG51bGwsXG4gICAgaW5jbHVkZVN0eWxlUHJvcGVydGllczogbnVsbCxcbiAgICBhdXRvRGVzdHJ1Y3Q6IGZhbHNlLFxuICAgIC4uLm9wdGlvbnMsXG4gICAgLy8gSW50ZXJuYWxDb250ZXh0XG4gICAgX19DT05URVhUX186IHRydWUsXG4gICAgbG9nOiBjcmVhdGVMb2dnZXIoZGVidWcpLFxuICAgIG5vZGUsXG4gICAgb3duZXJEb2N1bWVudCxcbiAgICBvd25lcldpbmRvdyxcbiAgICBkcGk6IHNjYWxlID09PSAxID8gbnVsbCA6IDk2ICogc2NhbGUsXG4gICAgc3ZnU3R5bGVFbGVtZW50OiBjcmVhdGVTdHlsZUVsZW1lbnQob3duZXJEb2N1bWVudCksXG4gICAgc3ZnRGVmc0VsZW1lbnQ6IG93bmVyRG9jdW1lbnQ/LmNyZWF0ZUVsZW1lbnROUyhYTUxOUywgXCJkZWZzXCIpLFxuICAgIHN2Z1N0eWxlczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSxcbiAgICBkZWZhdWx0Q29tcHV0ZWRTdHlsZXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksXG4gICAgd29ya2VyczogW1xuICAgICAgLi4uQXJyYXkuZnJvbSh7XG4gICAgICAgIGxlbmd0aDogU1VQUE9SVF9XRUJfV09SS0VSICYmIHdvcmtlclVybCAmJiB3b3JrZXJOdW1iZXIgPyB3b3JrZXJOdW1iZXIgOiAwXG4gICAgICB9KVxuICAgIF0ubWFwKCgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHdvcmtlciA9IG5ldyBXb3JrZXIod29ya2VyVXJsKTtcbiAgICAgICAgd29ya2VyLm9ubWVzc2FnZSA9IGFzeW5jIChldmVudCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgdXJsLCByZXN1bHQgfSA9IGV2ZW50LmRhdGE7XG4gICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgcmVxdWVzdHMuZ2V0KHVybCk/LnJlc29sdmU/LihyZXN1bHQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXF1ZXN0cy5nZXQodXJsKT8ucmVqZWN0Py4obmV3IEVycm9yKGBFcnJvciByZWNlaXZpbmcgbWVzc2FnZSBmcm9tIHdvcmtlcjogJHt1cmx9YCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgd29ya2VyLm9ubWVzc2FnZWVycm9yID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgY29uc3QgeyB1cmwgfSA9IGV2ZW50LmRhdGE7XG4gICAgICAgICAgcmVxdWVzdHMuZ2V0KHVybCk/LnJlamVjdD8uKG5ldyBFcnJvcihgRXJyb3IgcmVjZWl2aW5nIG1lc3NhZ2UgZnJvbSB3b3JrZXI6ICR7dXJsfWApKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHdvcmtlcjtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnRleHQubG9nLndhcm4oXCJGYWlsZWQgdG8gbmV3IFdvcmtlclwiLCBlcnJvcik7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH0pLmZpbHRlcihCb29sZWFuKSxcbiAgICBmb250RmFtaWxpZXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksXG4gICAgZm9udENzc1RleHRzOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLFxuICAgIGFjY2VwdE9mSW1hZ2U6IGAke1tcbiAgICAgIHN1cHBvcnRXZWJwKG93bmVyRG9jdW1lbnQpICYmIFwiaW1hZ2Uvd2VicFwiLFxuICAgICAgXCJpbWFnZS9zdmcreG1sXCIsXG4gICAgICBcImltYWdlLypcIixcbiAgICAgIFwiKi8qXCJcbiAgICBdLmZpbHRlcihCb29sZWFuKS5qb2luKFwiLFwiKX07cT0wLjhgLFxuICAgIHJlcXVlc3RzLFxuICAgIGRyYXdJbWFnZUNvdW50OiAwLFxuICAgIHRhc2tzOiBbXSxcbiAgICBmZWF0dXJlcyxcbiAgICBpc0VuYWJsZTogKGtleSkgPT4ge1xuICAgICAgaWYgKGtleSA9PT0gXCJyZXN0b3JlU2Nyb2xsUG9zaXRpb25cIikge1xuICAgICAgICByZXR1cm4gdHlwZW9mIGZlYXR1cmVzID09PSBcImJvb2xlYW5cIiA/IGZhbHNlIDogZmVhdHVyZXNba2V5XSA/PyBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgZmVhdHVyZXMgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgIHJldHVybiBmZWF0dXJlcztcbiAgICAgIH1cbiAgICAgIHJldHVybiBmZWF0dXJlc1trZXldID8/IHRydWU7XG4gICAgfSxcbiAgICBzaGFkb3dSb290czogW11cbiAgfTtcbiAgY29udGV4dC5sb2cudGltZShcIndhaXQgdW50aWwgbG9hZFwiKTtcbiAgYXdhaXQgd2FpdFVudGlsTG9hZChub2RlLCB7IHRpbWVvdXQ6IGNvbnRleHQudGltZW91dCwgb25XYXJuOiBjb250ZXh0LmxvZy53YXJuIH0pO1xuICBjb250ZXh0LmxvZy50aW1lRW5kKFwid2FpdCB1bnRpbCBsb2FkXCIpO1xuICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHJlc29sdmVCb3VuZGluZ0JveChub2RlLCBjb250ZXh0KTtcbiAgY29udGV4dC53aWR0aCA9IHdpZHRoO1xuICBjb250ZXh0LmhlaWdodCA9IGhlaWdodDtcbiAgcmV0dXJuIGNvbnRleHQ7XG59XG5mdW5jdGlvbiBjcmVhdGVTdHlsZUVsZW1lbnQob3duZXJEb2N1bWVudCkge1xuICBpZiAoIW93bmVyRG9jdW1lbnQpXG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgY29uc3Qgc3R5bGUgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgY29uc3QgY3NzVGV4dCA9IHN0eWxlLm93bmVyRG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoYFxuLl9fX19fX2JhY2tncm91bmQtY2xpcC0tdGV4dCB7XG4gIGJhY2tncm91bmQtY2xpcDogdGV4dDtcbiAgLXdlYmtpdC1iYWNrZ3JvdW5kLWNsaXA6IHRleHQ7XG59XG5gKTtcbiAgc3R5bGUuYXBwZW5kQ2hpbGQoY3NzVGV4dCk7XG4gIHJldHVybiBzdHlsZTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVCb3VuZGluZ0JveChub2RlLCBjb250ZXh0KSB7XG4gIGxldCB7IHdpZHRoLCBoZWlnaHQgfSA9IGNvbnRleHQ7XG4gIGlmIChpc0VsZW1lbnROb2RlKG5vZGUpICYmICghd2lkdGggfHwgIWhlaWdodCkpIHtcbiAgICBjb25zdCBib3ggPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHdpZHRoID0gd2lkdGggfHwgYm94LndpZHRoIHx8IE51bWJlcihub2RlLmdldEF0dHJpYnV0ZShcIndpZHRoXCIpKSB8fCAwO1xuICAgIGhlaWdodCA9IGhlaWdodCB8fCBib3guaGVpZ2h0IHx8IE51bWJlcihub2RlLmdldEF0dHJpYnV0ZShcImhlaWdodFwiKSkgfHwgMDtcbiAgfVxuICByZXR1cm4geyB3aWR0aCwgaGVpZ2h0IH07XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGltYWdlVG9DYW52YXMoaW1hZ2UsIGNvbnRleHQpIHtcbiAgY29uc3Qge1xuICAgIGxvZyxcbiAgICB0aW1lb3V0LFxuICAgIGRyYXdJbWFnZUNvdW50LFxuICAgIGRyYXdJbWFnZUludGVydmFsXG4gIH0gPSBjb250ZXh0O1xuICBsb2cudGltZShcImltYWdlIHRvIGNhbnZhc1wiKTtcbiAgY29uc3QgbG9hZGVkID0gYXdhaXQgbG9hZE1lZGlhKGltYWdlLCB7IHRpbWVvdXQsIG9uV2FybjogY29udGV4dC5sb2cud2FybiB9KTtcbiAgY29uc3QgeyBjYW52YXMsIGNvbnRleHQyZCB9ID0gY3JlYXRlQ2FudmFzKGltYWdlLm93bmVyRG9jdW1lbnQsIGNvbnRleHQpO1xuICBjb25zdCBkcmF3SW1hZ2UgPSAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnRleHQyZD8uZHJhd0ltYWdlKGxvYWRlZCwgMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29udGV4dC5sb2cud2FybihcIkZhaWxlZCB0byBkcmF3SW1hZ2VcIiwgZXJyb3IpO1xuICAgIH1cbiAgfTtcbiAgZHJhd0ltYWdlKCk7XG4gIGlmIChjb250ZXh0LmlzRW5hYmxlKFwiZml4U3ZnWG1sRGVjb2RlXCIpKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkcmF3SW1hZ2VDb3VudDsgaSsrKSB7XG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBjb250ZXh0MmQ/LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICAgIGRyYXdJbWFnZSgpO1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSwgaSArIGRyYXdJbWFnZUludGVydmFsKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBjb250ZXh0LmRyYXdJbWFnZUNvdW50ID0gMDtcbiAgbG9nLnRpbWVFbmQoXCJpbWFnZSB0byBjYW52YXNcIik7XG4gIHJldHVybiBjYW52YXM7XG59XG5mdW5jdGlvbiBjcmVhdGVDYW52YXMob3duZXJEb2N1bWVudCwgY29udGV4dCkge1xuICBjb25zdCB7IHdpZHRoLCBoZWlnaHQsIHNjYWxlLCBiYWNrZ3JvdW5kQ29sb3IsIG1heGltdW1DYW52YXNTaXplOiBtYXggfSA9IGNvbnRleHQ7XG4gIGNvbnN0IGNhbnZhcyA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgY2FudmFzLndpZHRoID0gTWF0aC5mbG9vcih3aWR0aCAqIHNjYWxlKTtcbiAgY2FudmFzLmhlaWdodCA9IE1hdGguZmxvb3IoaGVpZ2h0ICogc2NhbGUpO1xuICBjYW52YXMuc3R5bGUud2lkdGggPSBgJHt3aWR0aH1weGA7XG4gIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSBgJHtoZWlnaHR9cHhgO1xuICBpZiAobWF4KSB7XG4gICAgaWYgKGNhbnZhcy53aWR0aCA+IG1heCB8fCBjYW52YXMuaGVpZ2h0ID4gbWF4KSB7XG4gICAgICBpZiAoY2FudmFzLndpZHRoID4gbWF4ICYmIGNhbnZhcy5oZWlnaHQgPiBtYXgpIHtcbiAgICAgICAgaWYgKGNhbnZhcy53aWR0aCA+IGNhbnZhcy5oZWlnaHQpIHtcbiAgICAgICAgICBjYW52YXMuaGVpZ2h0ICo9IG1heCAvIGNhbnZhcy53aWR0aDtcbiAgICAgICAgICBjYW52YXMud2lkdGggPSBtYXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FudmFzLndpZHRoICo9IG1heCAvIGNhbnZhcy5oZWlnaHQ7XG4gICAgICAgICAgY2FudmFzLmhlaWdodCA9IG1heDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjYW52YXMud2lkdGggPiBtYXgpIHtcbiAgICAgICAgY2FudmFzLmhlaWdodCAqPSBtYXggLyBjYW52YXMud2lkdGg7XG4gICAgICAgIGNhbnZhcy53aWR0aCA9IG1heDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbnZhcy53aWR0aCAqPSBtYXggLyBjYW52YXMuaGVpZ2h0O1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gbWF4O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25zdCBjb250ZXh0MmQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICBpZiAoY29udGV4dDJkICYmIGJhY2tncm91bmRDb2xvcikge1xuICAgIGNvbnRleHQyZC5maWxsU3R5bGUgPSBiYWNrZ3JvdW5kQ29sb3I7XG4gICAgY29udGV4dDJkLmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gIH1cbiAgcmV0dXJuIHsgY2FudmFzLCBjb250ZXh0MmQgfTtcbn1cblxuZnVuY3Rpb24gY2xvbmVDYW52YXMoY2FudmFzLCBjb250ZXh0KSB7XG4gIGlmIChjYW52YXMub3duZXJEb2N1bWVudCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkYXRhVVJMID0gY2FudmFzLnRvRGF0YVVSTCgpO1xuICAgICAgaWYgKGRhdGFVUkwgIT09IFwiZGF0YTosXCIpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUltYWdlKGRhdGFVUkwsIGNhbnZhcy5vd25lckRvY3VtZW50KTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29udGV4dC5sb2cud2FybihcIkZhaWxlZCB0byBjbG9uZSBjYW52YXNcIiwgZXJyb3IpO1xuICAgIH1cbiAgfVxuICBjb25zdCBjbG9uZWQgPSBjYW52YXMuY2xvbmVOb2RlKGZhbHNlKTtcbiAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgY29uc3QgY2xvbmVkQ3R4ID0gY2xvbmVkLmdldENvbnRleHQoXCIyZFwiKTtcbiAgdHJ5IHtcbiAgICBpZiAoY3R4ICYmIGNsb25lZEN0eCkge1xuICAgICAgY2xvbmVkQ3R4LnB1dEltYWdlRGF0YShcbiAgICAgICAgY3R4LmdldEltYWdlRGF0YSgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpLFxuICAgICAgICAwLFxuICAgICAgICAwXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gY2xvbmVkO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnRleHQubG9nLndhcm4oXCJGYWlsZWQgdG8gY2xvbmUgY2FudmFzXCIsIGVycm9yKTtcbiAgfVxuICByZXR1cm4gY2xvbmVkO1xufVxuXG5mdW5jdGlvbiBjbG9uZUlmcmFtZShpZnJhbWUsIGNvbnRleHQpIHtcbiAgdHJ5IHtcbiAgICBpZiAoaWZyYW1lPy5jb250ZW50RG9jdW1lbnQ/LmJvZHkpIHtcbiAgICAgIHJldHVybiBjbG9uZU5vZGUoaWZyYW1lLmNvbnRlbnREb2N1bWVudC5ib2R5LCBjb250ZXh0KTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29udGV4dC5sb2cud2FybihcIkZhaWxlZCB0byBjbG9uZSBpZnJhbWVcIiwgZXJyb3IpO1xuICB9XG4gIHJldHVybiBpZnJhbWUuY2xvbmVOb2RlKGZhbHNlKTtcbn1cblxuZnVuY3Rpb24gY2xvbmVJbWFnZShpbWFnZSkge1xuICBjb25zdCBjbG9uZWQgPSBpbWFnZS5jbG9uZU5vZGUoZmFsc2UpO1xuICBpZiAoaW1hZ2UuY3VycmVudFNyYyAmJiBpbWFnZS5jdXJyZW50U3JjICE9PSBpbWFnZS5zcmMpIHtcbiAgICBjbG9uZWQuc3JjID0gaW1hZ2UuY3VycmVudFNyYztcbiAgICBjbG9uZWQuc3Jjc2V0ID0gXCJcIjtcbiAgfVxuICBpZiAoY2xvbmVkLmxvYWRpbmcgPT09IFwibGF6eVwiKSB7XG4gICAgY2xvbmVkLmxvYWRpbmcgPSBcImVhZ2VyXCI7XG4gIH1cbiAgcmV0dXJuIGNsb25lZDtcbn1cblxuYXN5bmMgZnVuY3Rpb24gY2xvbmVWaWRlbyh2aWRlbywgY29udGV4dCkge1xuICBpZiAodmlkZW8ub3duZXJEb2N1bWVudCAmJiAhdmlkZW8uY3VycmVudFNyYyAmJiB2aWRlby5wb3N0ZXIpIHtcbiAgICByZXR1cm4gY3JlYXRlSW1hZ2UodmlkZW8ucG9zdGVyLCB2aWRlby5vd25lckRvY3VtZW50KTtcbiAgfVxuICBjb25zdCBjbG9uZWQgPSB2aWRlby5jbG9uZU5vZGUoZmFsc2UpO1xuICBjbG9uZWQuY3Jvc3NPcmlnaW4gPSBcImFub255bW91c1wiO1xuICBpZiAodmlkZW8uY3VycmVudFNyYyAmJiB2aWRlby5jdXJyZW50U3JjICE9PSB2aWRlby5zcmMpIHtcbiAgICBjbG9uZWQuc3JjID0gdmlkZW8uY3VycmVudFNyYztcbiAgfVxuICBjb25zdCBvd25lckRvY3VtZW50ID0gY2xvbmVkLm93bmVyRG9jdW1lbnQ7XG4gIGlmIChvd25lckRvY3VtZW50KSB7XG4gICAgbGV0IGNhblBsYXkgPSB0cnVlO1xuICAgIGF3YWl0IGxvYWRNZWRpYShjbG9uZWQsIHsgb25FcnJvcjogKCkgPT4gY2FuUGxheSA9IGZhbHNlLCBvbldhcm46IGNvbnRleHQubG9nLndhcm4gfSk7XG4gICAgaWYgKCFjYW5QbGF5KSB7XG4gICAgICBpZiAodmlkZW8ucG9zdGVyKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVJbWFnZSh2aWRlby5wb3N0ZXIsIHZpZGVvLm93bmVyRG9jdW1lbnQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNsb25lZDtcbiAgICB9XG4gICAgY2xvbmVkLmN1cnJlbnRUaW1lID0gdmlkZW8uY3VycmVudFRpbWU7XG4gICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIGNsb25lZC5hZGRFdmVudExpc3RlbmVyKFwic2Vla2VkXCIsIHJlc29sdmUsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICB9KTtcbiAgICBjb25zdCBjYW52YXMgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgY2FudmFzLndpZHRoID0gdmlkZW8ub2Zmc2V0V2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IHZpZGVvLm9mZnNldEhlaWdodDtcbiAgICB0cnkge1xuICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgIGlmIChjdHgpXG4gICAgICAgIGN0eC5kcmF3SW1hZ2UoY2xvbmVkLCAwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb250ZXh0LmxvZy53YXJuKFwiRmFpbGVkIHRvIGNsb25lIHZpZGVvXCIsIGVycm9yKTtcbiAgICAgIGlmICh2aWRlby5wb3N0ZXIpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUltYWdlKHZpZGVvLnBvc3RlciwgdmlkZW8ub3duZXJEb2N1bWVudCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2xvbmVkO1xuICAgIH1cbiAgICByZXR1cm4gY2xvbmVDYW52YXMoY2FudmFzLCBjb250ZXh0KTtcbiAgfVxuICByZXR1cm4gY2xvbmVkO1xufVxuXG5mdW5jdGlvbiBjbG9uZUVsZW1lbnQobm9kZSwgY29udGV4dCkge1xuICBpZiAoaXNDYW52YXNFbGVtZW50KG5vZGUpKSB7XG4gICAgcmV0dXJuIGNsb25lQ2FudmFzKG5vZGUsIGNvbnRleHQpO1xuICB9XG4gIGlmIChpc0lGcmFtZUVsZW1lbnQobm9kZSkpIHtcbiAgICByZXR1cm4gY2xvbmVJZnJhbWUobm9kZSwgY29udGV4dCk7XG4gIH1cbiAgaWYgKGlzSW1hZ2VFbGVtZW50KG5vZGUpKSB7XG4gICAgcmV0dXJuIGNsb25lSW1hZ2Uobm9kZSk7XG4gIH1cbiAgaWYgKGlzVmlkZW9FbGVtZW50KG5vZGUpKSB7XG4gICAgcmV0dXJuIGNsb25lVmlkZW8obm9kZSwgY29udGV4dCk7XG4gIH1cbiAgcmV0dXJuIG5vZGUuY2xvbmVOb2RlKGZhbHNlKTtcbn1cblxuZnVuY3Rpb24gZ2V0U2FuZEJveChjb250ZXh0KSB7XG4gIGxldCBzYW5kYm94ID0gY29udGV4dC5zYW5kYm94O1xuICBpZiAoIXNhbmRib3gpIHtcbiAgICBjb25zdCB7IG93bmVyRG9jdW1lbnQgfSA9IGNvbnRleHQ7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChvd25lckRvY3VtZW50KSB7XG4gICAgICAgIHNhbmRib3ggPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpZnJhbWVcIik7XG4gICAgICAgIHNhbmRib3guaWQgPSBgX19TQU5EQk9YX18ke3V1aWQoKX1gO1xuICAgICAgICBzYW5kYm94LndpZHRoID0gXCIwXCI7XG4gICAgICAgIHNhbmRib3guaGVpZ2h0ID0gXCIwXCI7XG4gICAgICAgIHNhbmRib3guc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCI7XG4gICAgICAgIHNhbmRib3guc3R5bGUucG9zaXRpb24gPSBcImZpeGVkXCI7XG4gICAgICAgIG93bmVyRG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzYW5kYm94KTtcbiAgICAgICAgc2FuZGJveC5zcmNkb2MgPSAnPCFET0NUWVBFIGh0bWw+PG1ldGEgY2hhcnNldD1cIlVURi04XCI+PHRpdGxlPjwvdGl0bGU+PGJvZHk+JztcbiAgICAgICAgY29udGV4dC5zYW5kYm94ID0gc2FuZGJveDtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29udGV4dC5sb2cud2FybihcIkZhaWxlZCB0byBnZXRTYW5kQm94XCIsIGVycm9yKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNhbmRib3g7XG59XG5cbmNvbnN0IGlnbm9yZWRTdHlsZXMgPSBbXG4gIFwid2lkdGhcIixcbiAgXCJoZWlnaHRcIixcbiAgXCItd2Via2l0LXRleHQtZmlsbC1jb2xvclwiXG5dO1xuY29uc3QgaW5jbHVkZWRBdHRyaWJ1dGVzID0gW1xuICBcInN0cm9rZVwiLFxuICBcImZpbGxcIlxuXTtcbmZ1bmN0aW9uIGdldERlZmF1bHRTdHlsZShub2RlLCBwc2V1ZG9FbGVtZW50LCBjb250ZXh0KSB7XG4gIGNvbnN0IHsgZGVmYXVsdENvbXB1dGVkU3R5bGVzIH0gPSBjb250ZXh0O1xuICBjb25zdCBub2RlTmFtZSA9IG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgY29uc3QgaXNTdmdOb2RlID0gaXNTVkdFbGVtZW50Tm9kZShub2RlKSAmJiBub2RlTmFtZSAhPT0gXCJzdmdcIjtcbiAgY29uc3QgYXR0cmlidXRlcyA9IGlzU3ZnTm9kZSA/IGluY2x1ZGVkQXR0cmlidXRlcy5tYXAoKG5hbWUpID0+IFtuYW1lLCBub2RlLmdldEF0dHJpYnV0ZShuYW1lKV0pLmZpbHRlcigoWywgdmFsdWVdKSA9PiB2YWx1ZSAhPT0gbnVsbCkgOiBbXTtcbiAgY29uc3Qga2V5ID0gW1xuICAgIGlzU3ZnTm9kZSAmJiBcInN2Z1wiLFxuICAgIG5vZGVOYW1lLFxuICAgIGF0dHJpYnV0ZXMubWFwKChuYW1lLCB2YWx1ZSkgPT4gYCR7bmFtZX09JHt2YWx1ZX1gKS5qb2luKFwiLFwiKSxcbiAgICBwc2V1ZG9FbGVtZW50XG4gIF0uZmlsdGVyKEJvb2xlYW4pLmpvaW4oXCI6XCIpO1xuICBpZiAoZGVmYXVsdENvbXB1dGVkU3R5bGVzLmhhcyhrZXkpKVxuICAgIHJldHVybiBkZWZhdWx0Q29tcHV0ZWRTdHlsZXMuZ2V0KGtleSk7XG4gIGNvbnN0IHNhbmRib3ggPSBnZXRTYW5kQm94KGNvbnRleHQpO1xuICBjb25zdCBzYW5kYm94V2luZG93ID0gc2FuZGJveD8uY29udGVudFdpbmRvdztcbiAgaWYgKCFzYW5kYm94V2luZG93KVxuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdCBzYW5kYm94RG9jdW1lbnQgPSBzYW5kYm94V2luZG93Py5kb2N1bWVudDtcbiAgbGV0IHJvb3Q7XG4gIGxldCBlbDtcbiAgaWYgKGlzU3ZnTm9kZSkge1xuICAgIHJvb3QgPSBzYW5kYm94RG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFhNTE5TLCBcInN2Z1wiKTtcbiAgICBlbCA9IHJvb3Qub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50TlMocm9vdC5uYW1lc3BhY2VVUkksIG5vZGVOYW1lKTtcbiAgICBhdHRyaWJ1dGVzLmZvckVhY2goKFtuYW1lLCB2YWx1ZV0pID0+IHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZU5TKG51bGwsIG5hbWUsIHZhbHVlKTtcbiAgICB9KTtcbiAgICByb290LmFwcGVuZENoaWxkKGVsKTtcbiAgfSBlbHNlIHtcbiAgICByb290ID0gZWwgPSBzYW5kYm94RG9jdW1lbnQuY3JlYXRlRWxlbWVudChub2RlTmFtZSk7XG4gIH1cbiAgZWwudGV4dENvbnRlbnQgPSBcIiBcIjtcbiAgc2FuZGJveERvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQocm9vdCk7XG4gIGNvbnN0IGNvbXB1dGVkU3R5bGUgPSBzYW5kYm94V2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwsIHBzZXVkb0VsZW1lbnQpO1xuICBjb25zdCBzdHlsZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBmb3IgKGxldCBsZW4gPSBjb21wdXRlZFN0eWxlLmxlbmd0aCwgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGNvbnN0IG5hbWUgPSBjb21wdXRlZFN0eWxlLml0ZW0oaSk7XG4gICAgaWYgKGlnbm9yZWRTdHlsZXMuaW5jbHVkZXMobmFtZSkpXG4gICAgICBjb250aW51ZTtcbiAgICBzdHlsZXMuc2V0KG5hbWUsIGNvbXB1dGVkU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShuYW1lKSk7XG4gIH1cbiAgc2FuZGJveERvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQocm9vdCk7XG4gIGRlZmF1bHRDb21wdXRlZFN0eWxlcy5zZXQoa2V5LCBzdHlsZXMpO1xuICByZXR1cm4gc3R5bGVzO1xufVxuXG5mdW5jdGlvbiBnZXREaWZmU3R5bGUoc3R5bGUsIGRlZmF1bHRTdHlsZSwgaW5jbHVkZVN0eWxlUHJvcGVydGllcykge1xuICBjb25zdCBkaWZmU3R5bGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdCBwcmVmaXhzID0gW107XG4gIGNvbnN0IHByZWZpeFRyZWUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBpZiAoaW5jbHVkZVN0eWxlUHJvcGVydGllcykge1xuICAgIGZvciAoY29uc3QgbmFtZSBvZiBpbmNsdWRlU3R5bGVQcm9wZXJ0aWVzKSB7XG4gICAgICBhcHBseVRvKG5hbWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKGxldCBsZW4gPSBzdHlsZS5sZW5ndGgsIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGNvbnN0IG5hbWUgPSBzdHlsZS5pdGVtKGkpO1xuICAgICAgYXBwbHlUbyhuYW1lKTtcbiAgICB9XG4gIH1cbiAgZm9yIChsZXQgbGVuID0gcHJlZml4cy5sZW5ndGgsIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBwcmVmaXhUcmVlLmdldChwcmVmaXhzW2ldKT8uZm9yRWFjaCgodmFsdWUsIG5hbWUpID0+IGRpZmZTdHlsZS5zZXQobmFtZSwgdmFsdWUpKTtcbiAgfVxuICBmdW5jdGlvbiBhcHBseVRvKG5hbWUpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHN0eWxlLmdldFByb3BlcnR5VmFsdWUobmFtZSk7XG4gICAgY29uc3QgcHJpb3JpdHkgPSBzdHlsZS5nZXRQcm9wZXJ0eVByaW9yaXR5KG5hbWUpO1xuICAgIGNvbnN0IHN1YkluZGV4ID0gbmFtZS5sYXN0SW5kZXhPZihcIi1cIik7XG4gICAgY29uc3QgcHJlZml4ID0gc3ViSW5kZXggPiAtMSA/IG5hbWUuc3Vic3RyaW5nKDAsIHN1YkluZGV4KSA6IHZvaWQgMDtcbiAgICBpZiAocHJlZml4KSB7XG4gICAgICBsZXQgbWFwID0gcHJlZml4VHJlZS5nZXQocHJlZml4KTtcbiAgICAgIGlmICghbWFwKSB7XG4gICAgICAgIG1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICAgIHByZWZpeFRyZWUuc2V0KHByZWZpeCwgbWFwKTtcbiAgICAgIH1cbiAgICAgIG1hcC5zZXQobmFtZSwgW3ZhbHVlLCBwcmlvcml0eV0pO1xuICAgIH1cbiAgICBpZiAoZGVmYXVsdFN0eWxlLmdldChuYW1lKSA9PT0gdmFsdWUgJiYgIXByaW9yaXR5KVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChwcmVmaXgpIHtcbiAgICAgIHByZWZpeHMucHVzaChwcmVmaXgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkaWZmU3R5bGUuc2V0KG5hbWUsIFt2YWx1ZSwgcHJpb3JpdHldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRpZmZTdHlsZTtcbn1cblxuZnVuY3Rpb24gY29weUNzc1N0eWxlcyhub2RlLCBjbG9uZWQsIGlzUm9vdCwgY29udGV4dCkge1xuICBjb25zdCB7IG93bmVyV2luZG93LCBpbmNsdWRlU3R5bGVQcm9wZXJ0aWVzLCBjdXJyZW50UGFyZW50Tm9kZVN0eWxlIH0gPSBjb250ZXh0O1xuICBjb25zdCBjbG9uZWRTdHlsZSA9IGNsb25lZC5zdHlsZTtcbiAgY29uc3QgY29tcHV0ZWRTdHlsZSA9IG93bmVyV2luZG93LmdldENvbXB1dGVkU3R5bGUobm9kZSk7XG4gIGNvbnN0IGRlZmF1bHRTdHlsZSA9IGdldERlZmF1bHRTdHlsZShub2RlLCBudWxsLCBjb250ZXh0KTtcbiAgY3VycmVudFBhcmVudE5vZGVTdHlsZT8uZm9yRWFjaCgoXywga2V5KSA9PiB7XG4gICAgZGVmYXVsdFN0eWxlLmRlbGV0ZShrZXkpO1xuICB9KTtcbiAgY29uc3Qgc3R5bGUgPSBnZXREaWZmU3R5bGUoY29tcHV0ZWRTdHlsZSwgZGVmYXVsdFN0eWxlLCBpbmNsdWRlU3R5bGVQcm9wZXJ0aWVzKTtcbiAgc3R5bGUuZGVsZXRlKFwidHJhbnNpdGlvbi1wcm9wZXJ0eVwiKTtcbiAgc3R5bGUuZGVsZXRlKFwiYWxsXCIpO1xuICBzdHlsZS5kZWxldGUoXCJkXCIpO1xuICBzdHlsZS5kZWxldGUoXCJjb250ZW50XCIpO1xuICBpZiAoaXNSb290KSB7XG4gICAgc3R5bGUuZGVsZXRlKFwibWFyZ2luLXRvcFwiKTtcbiAgICBzdHlsZS5kZWxldGUoXCJtYXJnaW4tcmlnaHRcIik7XG4gICAgc3R5bGUuZGVsZXRlKFwibWFyZ2luLWJvdHRvbVwiKTtcbiAgICBzdHlsZS5kZWxldGUoXCJtYXJnaW4tbGVmdFwiKTtcbiAgICBzdHlsZS5kZWxldGUoXCJtYXJnaW4tYmxvY2stc3RhcnRcIik7XG4gICAgc3R5bGUuZGVsZXRlKFwibWFyZ2luLWJsb2NrLWVuZFwiKTtcbiAgICBzdHlsZS5kZWxldGUoXCJtYXJnaW4taW5saW5lLXN0YXJ0XCIpO1xuICAgIHN0eWxlLmRlbGV0ZShcIm1hcmdpbi1pbmxpbmUtZW5kXCIpO1xuICAgIHN0eWxlLnNldChcImJveC1zaXppbmdcIiwgW1wiYm9yZGVyLWJveFwiLCBcIlwiXSk7XG4gIH1cbiAgaWYgKHN0eWxlLmdldChcImJhY2tncm91bmQtY2xpcFwiKT8uWzBdID09PSBcInRleHRcIikge1xuICAgIGNsb25lZC5jbGFzc0xpc3QuYWRkKFwiX19fX19fYmFja2dyb3VuZC1jbGlwLS10ZXh0XCIpO1xuICB9XG4gIGlmIChJTl9DSFJPTUUpIHtcbiAgICBpZiAoIXN0eWxlLmhhcyhcImZvbnQta2VybmluZ1wiKSlcbiAgICAgIHN0eWxlLnNldChcImZvbnQta2VybmluZ1wiLCBbXCJub3JtYWxcIiwgXCJcIl0pO1xuICAgIGlmICgoc3R5bGUuZ2V0KFwib3ZlcmZsb3cteFwiKT8uWzBdID09PSBcImhpZGRlblwiIHx8IHN0eWxlLmdldChcIm92ZXJmbG93LXlcIik/LlswXSA9PT0gXCJoaWRkZW5cIikgJiYgc3R5bGUuZ2V0KFwidGV4dC1vdmVyZmxvd1wiKT8uWzBdID09PSBcImVsbGlwc2lzXCIgJiYgbm9kZS5zY3JvbGxXaWR0aCA9PT0gbm9kZS5jbGllbnRXaWR0aCkge1xuICAgICAgc3R5bGUuc2V0KFwidGV4dC1vdmVyZmxvd1wiLCBbXCJjbGlwXCIsIFwiXCJdKTtcbiAgICB9XG4gIH1cbiAgZm9yIChsZXQgbGVuID0gY2xvbmVkU3R5bGUubGVuZ3RoLCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgY2xvbmVkU3R5bGUucmVtb3ZlUHJvcGVydHkoY2xvbmVkU3R5bGUuaXRlbShpKSk7XG4gIH1cbiAgc3R5bGUuZm9yRWFjaCgoW3ZhbHVlLCBwcmlvcml0eV0sIG5hbWUpID0+IHtcbiAgICBjbG9uZWRTdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWx1ZSwgcHJpb3JpdHkpO1xuICB9KTtcbiAgcmV0dXJuIHN0eWxlO1xufVxuXG5mdW5jdGlvbiBjb3B5SW5wdXRWYWx1ZShub2RlLCBjbG9uZWQpIHtcbiAgaWYgKGlzVGV4dGFyZWFFbGVtZW50KG5vZGUpIHx8IGlzSW5wdXRFbGVtZW50KG5vZGUpIHx8IGlzU2VsZWN0RWxlbWVudChub2RlKSkge1xuICAgIGNsb25lZC5zZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiLCBub2RlLnZhbHVlKTtcbiAgfVxufVxuXG5jb25zdCBwc2V1ZG9DbGFzc2VzID0gW1xuICBcIjo6YmVmb3JlXCIsXG4gIFwiOjphZnRlclwiXG4gIC8vICc6OnBsYWNlaG9sZGVyJywgVE9ET1xuXTtcbmNvbnN0IHNjcm9sbGJhclBzZXVkb0NsYXNzZXMgPSBbXG4gIFwiOjotd2Via2l0LXNjcm9sbGJhclwiLFxuICBcIjo6LXdlYmtpdC1zY3JvbGxiYXItYnV0dG9uXCIsXG4gIC8vICc6Oi13ZWJraXQtc2Nyb2xsYmFyOmhvcml6b250YWwnLCBUT0RPXG4gIFwiOjotd2Via2l0LXNjcm9sbGJhci10aHVtYlwiLFxuICBcIjo6LXdlYmtpdC1zY3JvbGxiYXItdHJhY2tcIixcbiAgXCI6Oi13ZWJraXQtc2Nyb2xsYmFyLXRyYWNrLXBpZWNlXCIsXG4gIC8vICc6Oi13ZWJraXQtc2Nyb2xsYmFyOnZlcnRpY2FsJywgVE9ET1xuICBcIjo6LXdlYmtpdC1zY3JvbGxiYXItY29ybmVyXCIsXG4gIFwiOjotd2Via2l0LXJlc2l6ZXJcIlxuXTtcbmZ1bmN0aW9uIGNvcHlQc2V1ZG9DbGFzcyhub2RlLCBjbG9uZWQsIGNvcHlTY3JvbGxiYXIsIGNvbnRleHQsIGFkZFdvcmRUb0ZvbnRGYW1pbGllcykge1xuICBjb25zdCB7IG93bmVyV2luZG93LCBzdmdTdHlsZUVsZW1lbnQsIHN2Z1N0eWxlcywgY3VycmVudE5vZGVTdHlsZSB9ID0gY29udGV4dDtcbiAgaWYgKCFzdmdTdHlsZUVsZW1lbnQgfHwgIW93bmVyV2luZG93KVxuICAgIHJldHVybjtcbiAgZnVuY3Rpb24gY29weUJ5KHBzZXVkb0NsYXNzKSB7XG4gICAgY29uc3QgY29tcHV0ZWRTdHlsZSA9IG93bmVyV2luZG93LmdldENvbXB1dGVkU3R5bGUobm9kZSwgcHNldWRvQ2xhc3MpO1xuICAgIGxldCBjb250ZW50ID0gY29tcHV0ZWRTdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKFwiY29udGVudFwiKTtcbiAgICBpZiAoIWNvbnRlbnQgfHwgY29udGVudCA9PT0gXCJub25lXCIpXG4gICAgICByZXR1cm47XG4gICAgYWRkV29yZFRvRm9udEZhbWlsaWVzPy4oY29udGVudCk7XG4gICAgY29udGVudCA9IGNvbnRlbnQucmVwbGFjZSgvKCcpfChcIil8KGNvdW50ZXJcXCguK1xcKSkvZywgXCJcIik7XG4gICAgY29uc3Qga2xhc3NlcyA9IFt1dWlkKCldO1xuICAgIGNvbnN0IGRlZmF1bHRTdHlsZSA9IGdldERlZmF1bHRTdHlsZShub2RlLCBwc2V1ZG9DbGFzcywgY29udGV4dCk7XG4gICAgY3VycmVudE5vZGVTdHlsZT8uZm9yRWFjaCgoXywga2V5KSA9PiB7XG4gICAgICBkZWZhdWx0U3R5bGUuZGVsZXRlKGtleSk7XG4gICAgfSk7XG4gICAgY29uc3Qgc3R5bGUgPSBnZXREaWZmU3R5bGUoY29tcHV0ZWRTdHlsZSwgZGVmYXVsdFN0eWxlLCBjb250ZXh0LmluY2x1ZGVTdHlsZVByb3BlcnRpZXMpO1xuICAgIHN0eWxlLmRlbGV0ZShcImNvbnRlbnRcIik7XG4gICAgc3R5bGUuZGVsZXRlKFwiLXdlYmtpdC1sb2NhbGVcIik7XG4gICAgaWYgKHN0eWxlLmdldChcImJhY2tncm91bmQtY2xpcFwiKT8uWzBdID09PSBcInRleHRcIikge1xuICAgICAgY2xvbmVkLmNsYXNzTGlzdC5hZGQoXCJfX19fX19iYWNrZ3JvdW5kLWNsaXAtLXRleHRcIik7XG4gICAgfVxuICAgIGNvbnN0IGNsb25lU3R5bGUgPSBbXG4gICAgICBgY29udGVudDogJyR7Y29udGVudH0nO2BcbiAgICBdO1xuICAgIHN0eWxlLmZvckVhY2goKFt2YWx1ZSwgcHJpb3JpdHldLCBuYW1lKSA9PiB7XG4gICAgICBjbG9uZVN0eWxlLnB1c2goYCR7bmFtZX06ICR7dmFsdWV9JHtwcmlvcml0eSA/IFwiICFpbXBvcnRhbnRcIiA6IFwiXCJ9O2ApO1xuICAgIH0pO1xuICAgIGlmIChjbG9uZVN0eWxlLmxlbmd0aCA9PT0gMSlcbiAgICAgIHJldHVybjtcbiAgICB0cnkge1xuICAgICAgY2xvbmVkLmNsYXNzTmFtZSA9IFtjbG9uZWQuY2xhc3NOYW1lLCAuLi5rbGFzc2VzXS5qb2luKFwiIFwiKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnRleHQubG9nLndhcm4oXCJGYWlsZWQgdG8gY29weVBzZXVkb0NsYXNzXCIsIGVycik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNzc1RleHQgPSBjbG9uZVN0eWxlLmpvaW4oXCJcXG4gIFwiKTtcbiAgICBsZXQgYWxsQ2xhc3NlcyA9IHN2Z1N0eWxlcy5nZXQoY3NzVGV4dCk7XG4gICAgaWYgKCFhbGxDbGFzc2VzKSB7XG4gICAgICBhbGxDbGFzc2VzID0gW107XG4gICAgICBzdmdTdHlsZXMuc2V0KGNzc1RleHQsIGFsbENsYXNzZXMpO1xuICAgIH1cbiAgICBhbGxDbGFzc2VzLnB1c2goYC4ke2tsYXNzZXNbMF19JHtwc2V1ZG9DbGFzc31gKTtcbiAgfVxuICBwc2V1ZG9DbGFzc2VzLmZvckVhY2goY29weUJ5KTtcbiAgaWYgKGNvcHlTY3JvbGxiYXIpXG4gICAgc2Nyb2xsYmFyUHNldWRvQ2xhc3Nlcy5mb3JFYWNoKGNvcHlCeSk7XG59XG5cbmNvbnN0IGV4Y2x1ZGVQYXJlbnROb2RlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcbiAgXCJzeW1ib2xcIlxuICAvLyB0ZXN0L2ZpeHR1cmVzL3N2Zy5zeW1ib2wuaHRtbFxuXSk7XG5hc3luYyBmdW5jdGlvbiBhcHBlbmRDaGlsZE5vZGUobm9kZSwgY2xvbmVkLCBjaGlsZCwgY29udGV4dCwgYWRkV29yZFRvRm9udEZhbWlsaWVzKSB7XG4gIGlmIChpc0VsZW1lbnROb2RlKGNoaWxkKSAmJiAoaXNTdHlsZUVsZW1lbnQoY2hpbGQpIHx8IGlzU2NyaXB0RWxlbWVudChjaGlsZCkpKVxuICAgIHJldHVybjtcbiAgaWYgKGNvbnRleHQuZmlsdGVyICYmICFjb250ZXh0LmZpbHRlcihjaGlsZCkpXG4gICAgcmV0dXJuO1xuICBpZiAoZXhjbHVkZVBhcmVudE5vZGVzLmhhcyhjbG9uZWQubm9kZU5hbWUpIHx8IGV4Y2x1ZGVQYXJlbnROb2Rlcy5oYXMoY2hpbGQubm9kZU5hbWUpKSB7XG4gICAgY29udGV4dC5jdXJyZW50UGFyZW50Tm9kZVN0eWxlID0gdm9pZCAwO1xuICB9IGVsc2Uge1xuICAgIGNvbnRleHQuY3VycmVudFBhcmVudE5vZGVTdHlsZSA9IGNvbnRleHQuY3VycmVudE5vZGVTdHlsZTtcbiAgfVxuICBjb25zdCBjaGlsZENsb25lZCA9IGF3YWl0IGNsb25lTm9kZShjaGlsZCwgY29udGV4dCwgZmFsc2UsIGFkZFdvcmRUb0ZvbnRGYW1pbGllcyk7XG4gIGlmIChjb250ZXh0LmlzRW5hYmxlKFwicmVzdG9yZVNjcm9sbFBvc2l0aW9uXCIpKSB7XG4gICAgcmVzdG9yZVNjcm9sbFBvc2l0aW9uKG5vZGUsIGNoaWxkQ2xvbmVkKTtcbiAgfVxuICBjbG9uZWQuYXBwZW5kQ2hpbGQoY2hpbGRDbG9uZWQpO1xufVxuYXN5bmMgZnVuY3Rpb24gY2xvbmVDaGlsZE5vZGVzKG5vZGUsIGNsb25lZCwgY29udGV4dCwgYWRkV29yZFRvRm9udEZhbWlsaWVzKSB7XG4gIGxldCBmaXJzdENoaWxkID0gbm9kZS5maXJzdENoaWxkO1xuICBpZiAoaXNFbGVtZW50Tm9kZShub2RlKSkge1xuICAgIGlmIChub2RlLnNoYWRvd1Jvb3QpIHtcbiAgICAgIGZpcnN0Q2hpbGQgPSBub2RlLnNoYWRvd1Jvb3Q/LmZpcnN0Q2hpbGQ7XG4gICAgICBjb250ZXh0LnNoYWRvd1Jvb3RzLnB1c2gobm9kZS5zaGFkb3dSb290KTtcbiAgICB9XG4gIH1cbiAgZm9yIChsZXQgY2hpbGQgPSBmaXJzdENoaWxkOyBjaGlsZDsgY2hpbGQgPSBjaGlsZC5uZXh0U2libGluZykge1xuICAgIGlmIChpc0NvbW1lbnROb2RlKGNoaWxkKSlcbiAgICAgIGNvbnRpbnVlO1xuICAgIGlmIChpc0VsZW1lbnROb2RlKGNoaWxkKSAmJiBpc1Nsb3RFbGVtZW50KGNoaWxkKSAmJiB0eXBlb2YgY2hpbGQuYXNzaWduZWROb2RlcyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBjb25zdCBub2RlcyA9IGNoaWxkLmFzc2lnbmVkTm9kZXMoKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXdhaXQgYXBwZW5kQ2hpbGROb2RlKG5vZGUsIGNsb25lZCwgbm9kZXNbaV0sIGNvbnRleHQsIGFkZFdvcmRUb0ZvbnRGYW1pbGllcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGF3YWl0IGFwcGVuZENoaWxkTm9kZShub2RlLCBjbG9uZWQsIGNoaWxkLCBjb250ZXh0LCBhZGRXb3JkVG9Gb250RmFtaWxpZXMpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcmVzdG9yZVNjcm9sbFBvc2l0aW9uKG5vZGUsIGNobGlkQ2xvbmVkKSB7XG4gIGlmICghaXNIVE1MRWxlbWVudE5vZGUobm9kZSkgfHwgIWlzSFRNTEVsZW1lbnROb2RlKGNobGlkQ2xvbmVkKSlcbiAgICByZXR1cm47XG4gIGNvbnN0IHsgc2Nyb2xsVG9wLCBzY3JvbGxMZWZ0IH0gPSBub2RlO1xuICBpZiAoIXNjcm9sbFRvcCAmJiAhc2Nyb2xsTGVmdCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB7IHRyYW5zZm9ybSB9ID0gY2hsaWRDbG9uZWQuc3R5bGU7XG4gIGNvbnN0IG1hdHJpeCA9IG5ldyBET01NYXRyaXgodHJhbnNmb3JtKTtcbiAgY29uc3QgeyBhLCBiLCBjLCBkIH0gPSBtYXRyaXg7XG4gIG1hdHJpeC5hID0gMTtcbiAgbWF0cml4LmIgPSAwO1xuICBtYXRyaXguYyA9IDA7XG4gIG1hdHJpeC5kID0gMTtcbiAgbWF0cml4LnRyYW5zbGF0ZVNlbGYoLXNjcm9sbExlZnQsIC1zY3JvbGxUb3ApO1xuICBtYXRyaXguYSA9IGE7XG4gIG1hdHJpeC5iID0gYjtcbiAgbWF0cml4LmMgPSBjO1xuICBtYXRyaXguZCA9IGQ7XG4gIGNobGlkQ2xvbmVkLnN0eWxlLnRyYW5zZm9ybSA9IG1hdHJpeC50b1N0cmluZygpO1xufVxuZnVuY3Rpb24gYXBwbHlDc3NTdHlsZVdpdGhPcHRpb25zKGNsb25lZCwgY29udGV4dCkge1xuICBjb25zdCB7IGJhY2tncm91bmRDb2xvciwgd2lkdGgsIGhlaWdodCwgc3R5bGU6IHN0eWxlcyB9ID0gY29udGV4dDtcbiAgY29uc3QgY2xvbmVkU3R5bGUgPSBjbG9uZWQuc3R5bGU7XG4gIGlmIChiYWNrZ3JvdW5kQ29sb3IpXG4gICAgY2xvbmVkU3R5bGUuc2V0UHJvcGVydHkoXCJiYWNrZ3JvdW5kLWNvbG9yXCIsIGJhY2tncm91bmRDb2xvciwgXCJpbXBvcnRhbnRcIik7XG4gIGlmICh3aWR0aClcbiAgICBjbG9uZWRTdHlsZS5zZXRQcm9wZXJ0eShcIndpZHRoXCIsIGAke3dpZHRofXB4YCwgXCJpbXBvcnRhbnRcIik7XG4gIGlmIChoZWlnaHQpXG4gICAgY2xvbmVkU3R5bGUuc2V0UHJvcGVydHkoXCJoZWlnaHRcIiwgYCR7aGVpZ2h0fXB4YCwgXCJpbXBvcnRhbnRcIik7XG4gIGlmIChzdHlsZXMpIHtcbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gc3R5bGVzKSBjbG9uZWRTdHlsZVtuYW1lXSA9IHN0eWxlc1tuYW1lXTtcbiAgfVxufVxuY29uc3QgTk9STUFMX0FUVFJJQlVURV9SRSA9IC9eW1xcdy06XSskLztcbmFzeW5jIGZ1bmN0aW9uIGNsb25lTm9kZShub2RlLCBjb250ZXh0LCBpc1Jvb3QgPSBmYWxzZSwgYWRkV29yZFRvRm9udEZhbWlsaWVzKSB7XG4gIGNvbnN0IHsgb3duZXJEb2N1bWVudCwgb3duZXJXaW5kb3csIGZvbnRGYW1pbGllcywgb25DbG9uZUVhY2hOb2RlIH0gPSBjb250ZXh0O1xuICBpZiAob3duZXJEb2N1bWVudCAmJiBpc1RleHROb2RlKG5vZGUpKSB7XG4gICAgaWYgKGFkZFdvcmRUb0ZvbnRGYW1pbGllcyAmJiAvXFxTLy50ZXN0KG5vZGUuZGF0YSkpIHtcbiAgICAgIGFkZFdvcmRUb0ZvbnRGYW1pbGllcyhub2RlLmRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gb3duZXJEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShub2RlLmRhdGEpO1xuICB9XG4gIGlmIChvd25lckRvY3VtZW50ICYmIG93bmVyV2luZG93ICYmIGlzRWxlbWVudE5vZGUobm9kZSkgJiYgKGlzSFRNTEVsZW1lbnROb2RlKG5vZGUpIHx8IGlzU1ZHRWxlbWVudE5vZGUobm9kZSkpKSB7XG4gICAgY29uc3QgY2xvbmVkMiA9IGF3YWl0IGNsb25lRWxlbWVudChub2RlLCBjb250ZXh0KTtcbiAgICBpZiAoY29udGV4dC5pc0VuYWJsZShcInJlbW92ZUFibm9ybWFsQXR0cmlidXRlc1wiKSkge1xuICAgICAgY29uc3QgbmFtZXMgPSBjbG9uZWQyLmdldEF0dHJpYnV0ZU5hbWVzKCk7XG4gICAgICBmb3IgKGxldCBsZW4gPSBuYW1lcy5sZW5ndGgsIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IG5hbWVzW2ldO1xuICAgICAgICBpZiAoIU5PUk1BTF9BVFRSSUJVVEVfUkUudGVzdChuYW1lKSkge1xuICAgICAgICAgIGNsb25lZDIucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHN0eWxlID0gY29udGV4dC5jdXJyZW50Tm9kZVN0eWxlID0gY29weUNzc1N0eWxlcyhub2RlLCBjbG9uZWQyLCBpc1Jvb3QsIGNvbnRleHQpO1xuICAgIGlmIChpc1Jvb3QpXG4gICAgICBhcHBseUNzc1N0eWxlV2l0aE9wdGlvbnMoY2xvbmVkMiwgY29udGV4dCk7XG4gICAgbGV0IGNvcHlTY3JvbGxiYXIgPSBmYWxzZTtcbiAgICBpZiAoY29udGV4dC5pc0VuYWJsZShcImNvcHlTY3JvbGxiYXJcIikpIHtcbiAgICAgIGNvbnN0IG92ZXJmbG93ID0gW1xuICAgICAgICBzdHlsZS5nZXQoXCJvdmVyZmxvdy14XCIpPy5bMF0sXG4gICAgICAgIHN0eWxlLmdldChcIm92ZXJmbG93LXlcIik/LlswXVxuICAgICAgXTtcbiAgICAgIGNvcHlTY3JvbGxiYXIgPSBvdmVyZmxvdy5pbmNsdWRlcyhcInNjcm9sbFwiKSB8fCAob3ZlcmZsb3cuaW5jbHVkZXMoXCJhdXRvXCIpIHx8IG92ZXJmbG93LmluY2x1ZGVzKFwib3ZlcmxheVwiKSkgJiYgKG5vZGUuc2Nyb2xsSGVpZ2h0ID4gbm9kZS5jbGllbnRIZWlnaHQgfHwgbm9kZS5zY3JvbGxXaWR0aCA+IG5vZGUuY2xpZW50V2lkdGgpO1xuICAgIH1cbiAgICBjb25zdCB0ZXh0VHJhbnNmb3JtID0gc3R5bGUuZ2V0KFwidGV4dC10cmFuc2Zvcm1cIik/LlswXTtcbiAgICBjb25zdCBmYW1pbGllcyA9IHNwbGl0Rm9udEZhbWlseShzdHlsZS5nZXQoXCJmb250LWZhbWlseVwiKT8uWzBdKTtcbiAgICBjb25zdCBhZGRXb3JkVG9Gb250RmFtaWxpZXMyID0gZmFtaWxpZXMgPyAod29yZCkgPT4ge1xuICAgICAgaWYgKHRleHRUcmFuc2Zvcm0gPT09IFwidXBwZXJjYXNlXCIpIHtcbiAgICAgICAgd29yZCA9IHdvcmQudG9VcHBlckNhc2UoKTtcbiAgICAgIH0gZWxzZSBpZiAodGV4dFRyYW5zZm9ybSA9PT0gXCJsb3dlcmNhc2VcIikge1xuICAgICAgICB3b3JkID0gd29yZC50b0xvd2VyQ2FzZSgpO1xuICAgICAgfSBlbHNlIGlmICh0ZXh0VHJhbnNmb3JtID09PSBcImNhcGl0YWxpemVcIikge1xuICAgICAgICB3b3JkID0gd29yZFswXS50b1VwcGVyQ2FzZSgpICsgd29yZC5zdWJzdHJpbmcoMSk7XG4gICAgICB9XG4gICAgICBmYW1pbGllcy5mb3JFYWNoKChmYW1pbHkpID0+IHtcbiAgICAgICAgbGV0IGZvbnRGYW1pbHkgPSBmb250RmFtaWxpZXMuZ2V0KGZhbWlseSk7XG4gICAgICAgIGlmICghZm9udEZhbWlseSkge1xuICAgICAgICAgIGZvbnRGYW1pbGllcy5zZXQoZmFtaWx5LCBmb250RmFtaWx5ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgd29yZC5zcGxpdChcIlwiKS5mb3JFYWNoKCh0ZXh0KSA9PiBmb250RmFtaWx5LmFkZCh0ZXh0KSk7XG4gICAgICB9KTtcbiAgICB9IDogdm9pZCAwO1xuICAgIGNvcHlQc2V1ZG9DbGFzcyhcbiAgICAgIG5vZGUsXG4gICAgICBjbG9uZWQyLFxuICAgICAgY29weVNjcm9sbGJhcixcbiAgICAgIGNvbnRleHQsXG4gICAgICBhZGRXb3JkVG9Gb250RmFtaWxpZXMyXG4gICAgKTtcbiAgICBjb3B5SW5wdXRWYWx1ZShub2RlLCBjbG9uZWQyKTtcbiAgICBpZiAoIWlzVmlkZW9FbGVtZW50KG5vZGUpKSB7XG4gICAgICBhd2FpdCBjbG9uZUNoaWxkTm9kZXMoXG4gICAgICAgIG5vZGUsXG4gICAgICAgIGNsb25lZDIsXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGFkZFdvcmRUb0ZvbnRGYW1pbGllczJcbiAgICAgICk7XG4gICAgfVxuICAgIGF3YWl0IG9uQ2xvbmVFYWNoTm9kZT8uKGNsb25lZDIpO1xuICAgIHJldHVybiBjbG9uZWQyO1xuICB9XG4gIGNvbnN0IGNsb25lZCA9IG5vZGUuY2xvbmVOb2RlKGZhbHNlKTtcbiAgYXdhaXQgY2xvbmVDaGlsZE5vZGVzKG5vZGUsIGNsb25lZCwgY29udGV4dCk7XG4gIGF3YWl0IG9uQ2xvbmVFYWNoTm9kZT8uKGNsb25lZCk7XG4gIHJldHVybiBjbG9uZWQ7XG59XG5cbmZ1bmN0aW9uIGRlc3Ryb3lDb250ZXh0KGNvbnRleHQpIHtcbiAgY29udGV4dC5vd25lckRvY3VtZW50ID0gdm9pZCAwO1xuICBjb250ZXh0Lm93bmVyV2luZG93ID0gdm9pZCAwO1xuICBjb250ZXh0LnN2Z1N0eWxlRWxlbWVudCA9IHZvaWQgMDtcbiAgY29udGV4dC5zdmdEZWZzRWxlbWVudCA9IHZvaWQgMDtcbiAgY29udGV4dC5zdmdTdHlsZXMuY2xlYXIoKTtcbiAgY29udGV4dC5kZWZhdWx0Q29tcHV0ZWRTdHlsZXMuY2xlYXIoKTtcbiAgaWYgKGNvbnRleHQuc2FuZGJveCkge1xuICAgIHRyeSB7XG4gICAgICBjb250ZXh0LnNhbmRib3gucmVtb3ZlKCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb250ZXh0LmxvZy53YXJuKFwiRmFpbGVkIHRvIGRlc3Ryb3lDb250ZXh0XCIsIGVycik7XG4gICAgfVxuICAgIGNvbnRleHQuc2FuZGJveCA9IHZvaWQgMDtcbiAgfVxuICBjb250ZXh0LndvcmtlcnMgPSBbXTtcbiAgY29udGV4dC5mb250RmFtaWxpZXMuY2xlYXIoKTtcbiAgY29udGV4dC5mb250Q3NzVGV4dHMuY2xlYXIoKTtcbiAgY29udGV4dC5yZXF1ZXN0cy5jbGVhcigpO1xuICBjb250ZXh0LnRhc2tzID0gW107XG4gIGNvbnRleHQuc2hhZG93Um9vdHMgPSBbXTtcbn1cblxuZnVuY3Rpb24gYmFzZUZldGNoKG9wdGlvbnMpIHtcbiAgY29uc3QgeyB1cmwsIHRpbWVvdXQsIHJlc3BvbnNlVHlwZSwgLi4ucmVxdWVzdEluaXQgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gIGNvbnN0IHRpbWVyID0gdGltZW91dCA/IHNldFRpbWVvdXQoKCkgPT4gY29udHJvbGxlci5hYm9ydCgpLCB0aW1lb3V0KSA6IHZvaWQgMDtcbiAgcmV0dXJuIGZldGNoKHVybCwgeyBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsLCAuLi5yZXF1ZXN0SW5pdCB9KS50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCBmZXRjaCwgbm90IDJ4eCByZXNwb25zZVwiLCB7IGNhdXNlOiByZXNwb25zZSB9KTtcbiAgICB9XG4gICAgc3dpdGNoIChyZXNwb25zZVR5cGUpIHtcbiAgICAgIGNhc2UgXCJhcnJheUJ1ZmZlclwiOlxuICAgICAgICByZXR1cm4gcmVzcG9uc2UuYXJyYXlCdWZmZXIoKTtcbiAgICAgIGNhc2UgXCJkYXRhVXJsXCI6XG4gICAgICAgIHJldHVybiByZXNwb25zZS5ibG9iKCkudGhlbihibG9iVG9EYXRhVXJsKTtcbiAgICAgIGNhc2UgXCJ0ZXh0XCI6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xuICAgIH1cbiAgfSkuZmluYWxseSgoKSA9PiBjbGVhclRpbWVvdXQodGltZXIpKTtcbn1cbmZ1bmN0aW9uIGNvbnRleHRGZXRjaChjb250ZXh0LCBvcHRpb25zKSB7XG4gIGNvbnN0IHsgdXJsOiByYXdVcmwsIHJlcXVlc3RUeXBlID0gXCJ0ZXh0XCIsIHJlc3BvbnNlVHlwZSA9IFwidGV4dFwiLCBpbWFnZURvbSB9ID0gb3B0aW9ucztcbiAgbGV0IHVybCA9IHJhd1VybDtcbiAgY29uc3Qge1xuICAgIHRpbWVvdXQsXG4gICAgYWNjZXB0T2ZJbWFnZSxcbiAgICByZXF1ZXN0cyxcbiAgICBmZXRjaEZuLFxuICAgIGZldGNoOiB7XG4gICAgICByZXF1ZXN0SW5pdCxcbiAgICAgIGJ5cGFzc2luZ0NhY2hlLFxuICAgICAgcGxhY2Vob2xkZXJJbWFnZVxuICAgIH0sXG4gICAgZm9udCxcbiAgICB3b3JrZXJzLFxuICAgIGZvbnRGYW1pbGllc1xuICB9ID0gY29udGV4dDtcbiAgaWYgKHJlcXVlc3RUeXBlID09PSBcImltYWdlXCIgJiYgKElOX1NBRkFSSSB8fCBJTl9GSVJFRk9YKSkge1xuICAgIGNvbnRleHQuZHJhd0ltYWdlQ291bnQrKztcbiAgfVxuICBsZXQgcmVxdWVzdCA9IHJlcXVlc3RzLmdldChyYXdVcmwpO1xuICBpZiAoIXJlcXVlc3QpIHtcbiAgICBpZiAoYnlwYXNzaW5nQ2FjaGUpIHtcbiAgICAgIGlmIChieXBhc3NpbmdDYWNoZSBpbnN0YW5jZW9mIFJlZ0V4cCAmJiBieXBhc3NpbmdDYWNoZS50ZXN0KHVybCkpIHtcbiAgICAgICAgdXJsICs9ICgvXFw/Ly50ZXN0KHVybCkgPyBcIiZcIiA6IFwiP1wiKSArICgvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBjYW5Gb250TWluaWZ5ID0gcmVxdWVzdFR5cGUuc3RhcnRzV2l0aChcImZvbnRcIikgJiYgZm9udCAmJiBmb250Lm1pbmlmeTtcbiAgICBjb25zdCBmb250VGV4dHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIGlmIChjYW5Gb250TWluaWZ5KSB7XG4gICAgICBjb25zdCBmYW1pbGllcyA9IHJlcXVlc3RUeXBlLnNwbGl0KFwiO1wiKVsxXS5zcGxpdChcIixcIik7XG4gICAgICBmYW1pbGllcy5mb3JFYWNoKChmYW1pbHkpID0+IHtcbiAgICAgICAgaWYgKCFmb250RmFtaWxpZXMuaGFzKGZhbWlseSkpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBmb250RmFtaWxpZXMuZ2V0KGZhbWlseSkuZm9yRWFjaCgodGV4dCkgPT4gZm9udFRleHRzLmFkZCh0ZXh0KSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgbmVlZEZvbnRNaW5pZnkgPSBjYW5Gb250TWluaWZ5ICYmIGZvbnRUZXh0cy5zaXplO1xuICAgIGNvbnN0IGJhc2VGZXRjaE9wdGlvbnMgPSB7XG4gICAgICB1cmwsXG4gICAgICB0aW1lb3V0LFxuICAgICAgcmVzcG9uc2VUeXBlOiBuZWVkRm9udE1pbmlmeSA/IFwiYXJyYXlCdWZmZXJcIiA6IHJlc3BvbnNlVHlwZSxcbiAgICAgIGhlYWRlcnM6IHJlcXVlc3RUeXBlID09PSBcImltYWdlXCIgPyB7IGFjY2VwdDogYWNjZXB0T2ZJbWFnZSB9IDogdm9pZCAwLFxuICAgICAgLi4ucmVxdWVzdEluaXRcbiAgICB9O1xuICAgIHJlcXVlc3QgPSB7XG4gICAgICB0eXBlOiByZXF1ZXN0VHlwZSxcbiAgICAgIHJlc29sdmU6IHZvaWQgMCxcbiAgICAgIHJlamVjdDogdm9pZCAwLFxuICAgICAgcmVzcG9uc2U6IG51bGxcbiAgICB9O1xuICAgIHJlcXVlc3QucmVzcG9uc2UgPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKGZldGNoRm4gJiYgcmVxdWVzdFR5cGUgPT09IFwiaW1hZ2VcIikge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBmZXRjaEZuKHJhd1VybCk7XG4gICAgICAgIGlmIChyZXN1bHQpXG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGlmICghSU5fU0FGQVJJICYmIHJhd1VybC5zdGFydHNXaXRoKFwiaHR0cFwiKSAmJiB3b3JrZXJzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHdvcmtlciA9IHdvcmtlcnNbcmVxdWVzdHMuc2l6ZSAmIHdvcmtlcnMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKHsgcmF3VXJsLCAuLi5iYXNlRmV0Y2hPcHRpb25zIH0pO1xuICAgICAgICAgIHJlcXVlc3QucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgICAgcmVxdWVzdC5yZWplY3QgPSByZWplY3Q7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VGZXRjaChiYXNlRmV0Y2hPcHRpb25zKTtcbiAgICB9KSgpLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgcmVxdWVzdHMuZGVsZXRlKHJhd1VybCk7XG4gICAgICBpZiAocmVxdWVzdFR5cGUgPT09IFwiaW1hZ2VcIiAmJiBwbGFjZWhvbGRlckltYWdlKSB7XG4gICAgICAgIGNvbnRleHQubG9nLndhcm4oXCJGYWlsZWQgdG8gZmV0Y2ggaW1hZ2UgYmFzZTY0LCB0cnlpbmcgdG8gdXNlIHBsYWNlaG9sZGVyIGltYWdlXCIsIHVybCk7XG4gICAgICAgIHJldHVybiB0eXBlb2YgcGxhY2Vob2xkZXJJbWFnZSA9PT0gXCJzdHJpbmdcIiA/IHBsYWNlaG9sZGVySW1hZ2UgOiBwbGFjZWhvbGRlckltYWdlKGltYWdlRG9tKTtcbiAgICAgIH1cbiAgICAgIHRocm93IGVycm9yO1xuICAgIH0pO1xuICAgIHJlcXVlc3RzLnNldChyYXdVcmwsIHJlcXVlc3QpO1xuICB9XG4gIHJldHVybiByZXF1ZXN0LnJlc3BvbnNlO1xufVxuXG5hc3luYyBmdW5jdGlvbiByZXBsYWNlQ3NzVXJsVG9EYXRhVXJsKGNzc1RleHQsIGJhc2VVcmwsIGNvbnRleHQsIGlzSW1hZ2UpIHtcbiAgaWYgKCFoYXNDc3NVcmwoY3NzVGV4dCkpXG4gICAgcmV0dXJuIGNzc1RleHQ7XG4gIGZvciAoY29uc3QgW3Jhd1VybCwgdXJsXSBvZiBwYXJzZUNzc1VybHMoY3NzVGV4dCwgYmFzZVVybCkpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZGF0YVVybCA9IGF3YWl0IGNvbnRleHRGZXRjaChcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAge1xuICAgICAgICAgIHVybCxcbiAgICAgICAgICByZXF1ZXN0VHlwZTogaXNJbWFnZSA/IFwiaW1hZ2VcIiA6IFwidGV4dFwiLFxuICAgICAgICAgIHJlc3BvbnNlVHlwZTogXCJkYXRhVXJsXCJcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIGNzc1RleHQgPSBjc3NUZXh0LnJlcGxhY2UodG9SRShyYXdVcmwpLCBgJDEke2RhdGFVcmx9JDNgKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29udGV4dC5sb2cud2FybihcIkZhaWxlZCB0byBmZXRjaCBjc3MgZGF0YSB1cmxcIiwgcmF3VXJsLCBlcnJvcik7XG4gICAgfVxuICB9XG4gIHJldHVybiBjc3NUZXh0O1xufVxuZnVuY3Rpb24gaGFzQ3NzVXJsKGNzc1RleHQpIHtcbiAgcmV0dXJuIC91cmxcXCgoWydcIl0/KShbXidcIl0rPylcXDFcXCkvLnRlc3QoY3NzVGV4dCk7XG59XG5jb25zdCBVUkxfUkUgPSAvdXJsXFwoKFsnXCJdPykoW14nXCJdKz8pXFwxXFwpL2c7XG5mdW5jdGlvbiBwYXJzZUNzc1VybHMoY3NzVGV4dCwgYmFzZVVybCkge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgY3NzVGV4dC5yZXBsYWNlKFVSTF9SRSwgKHJhdywgcXVvdGF0aW9uLCB1cmwpID0+IHtcbiAgICByZXN1bHQucHVzaChbdXJsLCByZXNvbHZlVXJsKHVybCwgYmFzZVVybCldKTtcbiAgICByZXR1cm4gcmF3O1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdC5maWx0ZXIoKFt1cmxdKSA9PiAhaXNEYXRhVXJsKHVybCkpO1xufVxuZnVuY3Rpb24gdG9SRSh1cmwpIHtcbiAgY29uc3QgZXNjYXBlZCA9IHVybC5yZXBsYWNlKC8oWy4qKz9eJHt9KCl8XFxbXFxdXFwvXFxcXF0pL2csIFwiXFxcXCQxXCIpO1xuICByZXR1cm4gbmV3IFJlZ0V4cChgKHVybFxcXFwoWydcIl0/KSgke2VzY2FwZWR9KShbJ1wiXT9cXFxcKSlgLCBcImdcIik7XG59XG5cbmNvbnN0IHByb3BlcnRpZXMgPSBbXG4gIFwiYmFja2dyb3VuZC1pbWFnZVwiLFxuICBcImJvcmRlci1pbWFnZS1zb3VyY2VcIixcbiAgXCItd2Via2l0LWJvcmRlci1pbWFnZVwiLFxuICBcIi13ZWJraXQtbWFzay1pbWFnZVwiLFxuICBcImxpc3Qtc3R5bGUtaW1hZ2VcIlxuXTtcbmZ1bmN0aW9uIGVtYmVkQ3NzU3R5bGVJbWFnZShzdHlsZSwgY29udGV4dCkge1xuICByZXR1cm4gcHJvcGVydGllcy5tYXAoKHByb3BlcnR5KSA9PiB7XG4gICAgY29uc3QgdmFsdWUgPSBzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKHByb3BlcnR5KTtcbiAgICBpZiAoIXZhbHVlIHx8IHZhbHVlID09PSBcIm5vbmVcIikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChJTl9TQUZBUkkgfHwgSU5fRklSRUZPWCkge1xuICAgICAgY29udGV4dC5kcmF3SW1hZ2VDb3VudCsrO1xuICAgIH1cbiAgICByZXR1cm4gcmVwbGFjZUNzc1VybFRvRGF0YVVybCh2YWx1ZSwgbnVsbCwgY29udGV4dCwgdHJ1ZSkudGhlbigobmV3VmFsdWUpID0+IHtcbiAgICAgIGlmICghbmV3VmFsdWUgfHwgdmFsdWUgPT09IG5ld1ZhbHVlKVxuICAgICAgICByZXR1cm47XG4gICAgICBzdHlsZS5zZXRQcm9wZXJ0eShcbiAgICAgICAgcHJvcGVydHksXG4gICAgICAgIG5ld1ZhbHVlLFxuICAgICAgICBzdHlsZS5nZXRQcm9wZXJ0eVByaW9yaXR5KHByb3BlcnR5KVxuICAgICAgKTtcbiAgICB9KTtcbiAgfSkuZmlsdGVyKEJvb2xlYW4pO1xufVxuXG5mdW5jdGlvbiBlbWJlZEltYWdlRWxlbWVudChjbG9uZWQsIGNvbnRleHQpIHtcbiAgaWYgKGlzSW1hZ2VFbGVtZW50KGNsb25lZCkpIHtcbiAgICBjb25zdCBvcmlnaW5hbFNyYyA9IGNsb25lZC5jdXJyZW50U3JjIHx8IGNsb25lZC5zcmM7XG4gICAgaWYgKCFpc0RhdGFVcmwob3JpZ2luYWxTcmMpKSB7XG4gICAgICByZXR1cm4gW1xuICAgICAgICBjb250ZXh0RmV0Y2goY29udGV4dCwge1xuICAgICAgICAgIHVybDogb3JpZ2luYWxTcmMsXG4gICAgICAgICAgaW1hZ2VEb206IGNsb25lZCxcbiAgICAgICAgICByZXF1ZXN0VHlwZTogXCJpbWFnZVwiLFxuICAgICAgICAgIHJlc3BvbnNlVHlwZTogXCJkYXRhVXJsXCJcbiAgICAgICAgfSkudGhlbigodXJsKSA9PiB7XG4gICAgICAgICAgaWYgKCF1cmwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgY2xvbmVkLnNyY3NldCA9IFwiXCI7XG4gICAgICAgICAgY2xvbmVkLmRhdGFzZXQub3JpZ2luYWxTcmMgPSBvcmlnaW5hbFNyYztcbiAgICAgICAgICBjbG9uZWQuc3JjID0gdXJsIHx8IFwiXCI7XG4gICAgICAgIH0pXG4gICAgICBdO1xuICAgIH1cbiAgICBpZiAoSU5fU0FGQVJJIHx8IElOX0ZJUkVGT1gpIHtcbiAgICAgIGNvbnRleHQuZHJhd0ltYWdlQ291bnQrKztcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNTVkdFbGVtZW50Tm9kZShjbG9uZWQpICYmICFpc0RhdGFVcmwoY2xvbmVkLmhyZWYuYmFzZVZhbCkpIHtcbiAgICBjb25zdCBvcmlnaW5hbFNyYyA9IGNsb25lZC5ocmVmLmJhc2VWYWw7XG4gICAgcmV0dXJuIFtcbiAgICAgIGNvbnRleHRGZXRjaChjb250ZXh0LCB7XG4gICAgICAgIHVybDogb3JpZ2luYWxTcmMsXG4gICAgICAgIGltYWdlRG9tOiBjbG9uZWQsXG4gICAgICAgIHJlcXVlc3RUeXBlOiBcImltYWdlXCIsXG4gICAgICAgIHJlc3BvbnNlVHlwZTogXCJkYXRhVXJsXCJcbiAgICAgIH0pLnRoZW4oKHVybCkgPT4ge1xuICAgICAgICBpZiAoIXVybClcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNsb25lZC5kYXRhc2V0Lm9yaWdpbmFsU3JjID0gb3JpZ2luYWxTcmM7XG4gICAgICAgIGNsb25lZC5ocmVmLmJhc2VWYWwgPSB1cmwgfHwgXCJcIjtcbiAgICAgIH0pXG4gICAgXTtcbiAgfVxuICByZXR1cm4gW107XG59XG5cbmZ1bmN0aW9uIGVtYmVkU3ZnVXNlKGNsb25lZCwgY29udGV4dCkge1xuICBjb25zdCB7IG93bmVyRG9jdW1lbnQsIHN2Z0RlZnNFbGVtZW50IH0gPSBjb250ZXh0O1xuICBjb25zdCBocmVmID0gY2xvbmVkLmdldEF0dHJpYnV0ZShcImhyZWZcIikgPz8gY2xvbmVkLmdldEF0dHJpYnV0ZShcInhsaW5rOmhyZWZcIik7XG4gIGlmICghaHJlZilcbiAgICByZXR1cm4gW107XG4gIGNvbnN0IFtzdmdVcmwsIGlkXSA9IGhyZWYuc3BsaXQoXCIjXCIpO1xuICBpZiAoaWQpIHtcbiAgICBjb25zdCBxdWVyeSA9IGAjJHtpZH1gO1xuICAgIGNvbnN0IGRlZmluaXRpb24gPSBjb250ZXh0LnNoYWRvd1Jvb3RzLnJlZHVjZShcbiAgICAgIChyZXMsIHJvb3QpID0+IHtcbiAgICAgICAgcmV0dXJuIHJlcyA/PyByb290LnF1ZXJ5U2VsZWN0b3IoYHN2ZyAke3F1ZXJ5fWApO1xuICAgICAgfSxcbiAgICAgIG93bmVyRG9jdW1lbnQ/LnF1ZXJ5U2VsZWN0b3IoYHN2ZyAke3F1ZXJ5fWApXG4gICAgKTtcbiAgICBpZiAoc3ZnVXJsKSB7XG4gICAgICBjbG9uZWQuc2V0QXR0cmlidXRlKFwiaHJlZlwiLCBxdWVyeSk7XG4gICAgfVxuICAgIGlmIChzdmdEZWZzRWxlbWVudD8ucXVlcnlTZWxlY3RvcihxdWVyeSkpXG4gICAgICByZXR1cm4gW107XG4gICAgaWYgKGRlZmluaXRpb24pIHtcbiAgICAgIHN2Z0RlZnNFbGVtZW50Py5hcHBlbmRDaGlsZChkZWZpbml0aW9uLmNsb25lTm9kZSh0cnVlKSk7XG4gICAgICByZXR1cm4gW107XG4gICAgfSBlbHNlIGlmIChzdmdVcmwpIHtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIGNvbnRleHRGZXRjaChjb250ZXh0LCB7XG4gICAgICAgICAgdXJsOiBzdmdVcmwsXG4gICAgICAgICAgcmVzcG9uc2VUeXBlOiBcInRleHRcIlxuICAgICAgICB9KS50aGVuKChzdmdEYXRhKSA9PiB7XG4gICAgICAgICAgc3ZnRGVmc0VsZW1lbnQ/Lmluc2VydEFkamFjZW50SFRNTChcImJlZm9yZWVuZFwiLCBzdmdEYXRhKTtcbiAgICAgICAgfSlcbiAgICAgIF07XG4gICAgfVxuICB9XG4gIHJldHVybiBbXTtcbn1cblxuZnVuY3Rpb24gZW1iZWROb2RlKGNsb25lZCwgY29udGV4dCkge1xuICBjb25zdCB7IHRhc2tzIH0gPSBjb250ZXh0O1xuICBpZiAoaXNFbGVtZW50Tm9kZShjbG9uZWQpKSB7XG4gICAgaWYgKGlzSW1hZ2VFbGVtZW50KGNsb25lZCkgfHwgaXNTVkdJbWFnZUVsZW1lbnROb2RlKGNsb25lZCkpIHtcbiAgICAgIHRhc2tzLnB1c2goLi4uZW1iZWRJbWFnZUVsZW1lbnQoY2xvbmVkLCBjb250ZXh0KSk7XG4gICAgfVxuICAgIGlmIChpc1NWR1VzZUVsZW1lbnROb2RlKGNsb25lZCkpIHtcbiAgICAgIHRhc2tzLnB1c2goLi4uZW1iZWRTdmdVc2UoY2xvbmVkLCBjb250ZXh0KSk7XG4gICAgfVxuICB9XG4gIGlmIChpc0hUTUxFbGVtZW50Tm9kZShjbG9uZWQpKSB7XG4gICAgdGFza3MucHVzaCguLi5lbWJlZENzc1N0eWxlSW1hZ2UoY2xvbmVkLnN0eWxlLCBjb250ZXh0KSk7XG4gIH1cbiAgY2xvbmVkLmNoaWxkTm9kZXMuZm9yRWFjaCgoY2hpbGQpID0+IHtcbiAgICBlbWJlZE5vZGUoY2hpbGQsIGNvbnRleHQpO1xuICB9KTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZW1iZWRXZWJGb250KGNsb25lLCBjb250ZXh0KSB7XG4gIGNvbnN0IHtcbiAgICBvd25lckRvY3VtZW50LFxuICAgIHN2Z1N0eWxlRWxlbWVudCxcbiAgICBmb250RmFtaWxpZXMsXG4gICAgZm9udENzc1RleHRzLFxuICAgIHRhc2tzLFxuICAgIGZvbnRcbiAgfSA9IGNvbnRleHQ7XG4gIGlmICghb3duZXJEb2N1bWVudCB8fCAhc3ZnU3R5bGVFbGVtZW50IHx8ICFmb250RmFtaWxpZXMuc2l6ZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZm9udCAmJiBmb250LmNzc1RleHQpIHtcbiAgICBjb25zdCBjc3NUZXh0ID0gZmlsdGVyUHJlZmVycmVkRm9ybWF0KGZvbnQuY3NzVGV4dCwgY29udGV4dCk7XG4gICAgc3ZnU3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKG93bmVyRG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoYCR7Y3NzVGV4dH1cbmApKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBzdHlsZVNoZWV0cyA9IEFycmF5LmZyb20ob3duZXJEb2N1bWVudC5zdHlsZVNoZWV0cykuZmlsdGVyKChzdHlsZVNoZWV0KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gXCJjc3NSdWxlc1wiIGluIHN0eWxlU2hlZXQgJiYgQm9vbGVhbihzdHlsZVNoZWV0LmNzc1J1bGVzLmxlbmd0aCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb250ZXh0LmxvZy53YXJuKGBFcnJvciB3aGlsZSByZWFkaW5nIENTUyBydWxlcyBmcm9tICR7c3R5bGVTaGVldC5ocmVmfWAsIGVycm9yKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgc3R5bGVTaGVldHMuZmxhdE1hcCgoc3R5bGVTaGVldCkgPT4ge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShzdHlsZVNoZWV0LmNzc1J1bGVzKS5tYXAoYXN5bmMgKGNzc1J1bGUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgaWYgKGlzQ1NTSW1wb3J0UnVsZShjc3NSdWxlKSkge1xuICAgICAgICAgICAgbGV0IGltcG9ydEluZGV4ID0gaW5kZXggKyAxO1xuICAgICAgICAgICAgY29uc3QgYmFzZVVybCA9IGNzc1J1bGUuaHJlZjtcbiAgICAgICAgICAgIGxldCBjc3NUZXh0ID0gXCJcIjtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNzc1RleHQgPSBhd2FpdCBjb250ZXh0RmV0Y2goY29udGV4dCwge1xuICAgICAgICAgICAgICAgIHVybDogYmFzZVVybCxcbiAgICAgICAgICAgICAgICByZXF1ZXN0VHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgICAgICAgcmVzcG9uc2VUeXBlOiBcInRleHRcIlxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIGNvbnRleHQubG9nLndhcm4oYEVycm9yIGZldGNoIHJlbW90ZSBjc3MgaW1wb3J0IGZyb20gJHtiYXNlVXJsfWAsIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlcGxhY2VkQ3NzVGV4dCA9IGNzc1RleHQucmVwbGFjZShcbiAgICAgICAgICAgICAgVVJMX1JFLFxuICAgICAgICAgICAgICAocmF3LCBxdW90YXRpb24sIHVybCkgPT4gcmF3LnJlcGxhY2UodXJsLCByZXNvbHZlVXJsKHVybCwgYmFzZVVybCkpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZm9yIChjb25zdCBydWxlIG9mIHBhcnNlQ3NzKHJlcGxhY2VkQ3NzVGV4dCkpIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzdHlsZVNoZWV0Lmluc2VydFJ1bGUoXG4gICAgICAgICAgICAgICAgICBydWxlLFxuICAgICAgICAgICAgICAgICAgcnVsZS5zdGFydHNXaXRoKFwiQGltcG9ydFwiKSA/IGltcG9ydEluZGV4ICs9IDEgOiBzdHlsZVNoZWV0LmNzc1J1bGVzLmxlbmd0aFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5sb2cud2FybihcIkVycm9yIGluc2VydGluZyBydWxlIGZyb20gcmVtb3RlIGNzcyBpbXBvcnRcIiwgeyBydWxlLCBlcnJvciB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KVxuICAgICk7XG4gICAgY29uc3QgY3NzUnVsZXMgPSBzdHlsZVNoZWV0cy5mbGF0TWFwKChzdHlsZVNoZWV0KSA9PiBBcnJheS5mcm9tKHN0eWxlU2hlZXQuY3NzUnVsZXMpKTtcbiAgICBjc3NSdWxlcy5maWx0ZXIoKGNzc1J1bGUpID0+IGlzQ3NzRm9udEZhY2VSdWxlKGNzc1J1bGUpICYmIGhhc0Nzc1VybChjc3NSdWxlLnN0eWxlLmdldFByb3BlcnR5VmFsdWUoXCJzcmNcIikpICYmIHNwbGl0Rm9udEZhbWlseShjc3NSdWxlLnN0eWxlLmdldFByb3BlcnR5VmFsdWUoXCJmb250LWZhbWlseVwiKSk/LnNvbWUoKHZhbCkgPT4gZm9udEZhbWlsaWVzLmhhcyh2YWwpKSkuZm9yRWFjaCgodmFsdWUpID0+IHtcbiAgICAgIGNvbnN0IHJ1bGUgPSB2YWx1ZTtcbiAgICAgIGNvbnN0IGNzc1RleHQgPSBmb250Q3NzVGV4dHMuZ2V0KHJ1bGUuY3NzVGV4dCk7XG4gICAgICBpZiAoY3NzVGV4dCkge1xuICAgICAgICBzdmdTdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQob3duZXJEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShgJHtjc3NUZXh0fVxuYCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFza3MucHVzaChcbiAgICAgICAgICByZXBsYWNlQ3NzVXJsVG9EYXRhVXJsKFxuICAgICAgICAgICAgcnVsZS5jc3NUZXh0LFxuICAgICAgICAgICAgcnVsZS5wYXJlbnRTdHlsZVNoZWV0ID8gcnVsZS5wYXJlbnRTdHlsZVNoZWV0LmhyZWYgOiBudWxsLFxuICAgICAgICAgICAgY29udGV4dFxuICAgICAgICAgICkudGhlbigoY3NzVGV4dDIpID0+IHtcbiAgICAgICAgICAgIGNzc1RleHQyID0gZmlsdGVyUHJlZmVycmVkRm9ybWF0KGNzc1RleHQyLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGZvbnRDc3NUZXh0cy5zZXQocnVsZS5jc3NUZXh0LCBjc3NUZXh0Mik7XG4gICAgICAgICAgICBzdmdTdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQob3duZXJEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShgJHtjc3NUZXh0Mn1cbmApKTtcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5jb25zdCBDT01NRU5UU19SRSA9IC8oXFwvXFwqW1xcc1xcU10qP1xcKlxcLykvZztcbmNvbnN0IEtFWUZSQU1FU19SRSA9IC8oKEAuKj9rZXlmcmFtZXMgW1xcc1xcU10qPyl7KFtcXHNcXFNdKj99XFxzKj8pfSkvZ2k7XG5mdW5jdGlvbiBwYXJzZUNzcyhzb3VyY2UpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKVxuICAgIHJldHVybiBbXTtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGxldCBjc3NUZXh0ID0gc291cmNlLnJlcGxhY2UoQ09NTUVOVFNfUkUsIFwiXCIpO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGNvbnN0IG1hdGNoZXMgPSBLRVlGUkFNRVNfUkUuZXhlYyhjc3NUZXh0KTtcbiAgICBpZiAoIW1hdGNoZXMpXG4gICAgICBicmVhaztcbiAgICByZXN1bHQucHVzaChtYXRjaGVzWzBdKTtcbiAgfVxuICBjc3NUZXh0ID0gY3NzVGV4dC5yZXBsYWNlKEtFWUZSQU1FU19SRSwgXCJcIik7XG4gIGNvbnN0IElNUE9SVF9SRSA9IC9AaW1wb3J0W1xcc1xcU10qP3VybFxcKFteKV0qXFwpW1xcc1xcU10qPzsvZ2k7XG4gIGNvbnN0IFVOSUZJRURfUkUgPSBuZXcgUmVnRXhwKFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgIFwiKChcXFxccyo/KD86XFxcXC9cXFxcKltcXFxcc1xcXFxTXSo/XFxcXCpcXFxcLyk/XFxcXHMqP0BtZWRpYVtcXFxcc1xcXFxTXSo/KXsoW1xcXFxzXFxcXFNdKj8pfVxcXFxzKj99KXwoKFtcXFxcc1xcXFxTXSo/KXsoW1xcXFxzXFxcXFNdKj8pfSlcIixcbiAgICBcImdpXCJcbiAgKTtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBsZXQgbWF0Y2hlcyA9IElNUE9SVF9SRS5leGVjKGNzc1RleHQpO1xuICAgIGlmICghbWF0Y2hlcykge1xuICAgICAgbWF0Y2hlcyA9IFVOSUZJRURfUkUuZXhlYyhjc3NUZXh0KTtcbiAgICAgIGlmICghbWF0Y2hlcykge1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIElNUE9SVF9SRS5sYXN0SW5kZXggPSBVTklGSUVEX1JFLmxhc3RJbmRleDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgVU5JRklFRF9SRS5sYXN0SW5kZXggPSBJTVBPUlRfUkUubGFzdEluZGV4O1xuICAgIH1cbiAgICByZXN1bHQucHVzaChtYXRjaGVzWzBdKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuY29uc3QgVVJMX1dJVEhfRk9STUFUX1JFID0gL3VybFxcKFteKV0rXFwpXFxzKmZvcm1hdFxcKChbXCInXT8pKFteXCInXSspXFwxXFwpL2c7XG5jb25zdCBGT05UX1NSQ19SRSA9IC9zcmM6XFxzKig/OnVybFxcKFteKV0rXFwpXFxzKmZvcm1hdFxcKFteKV0rXFwpWyw7XVxccyopKy9nO1xuZnVuY3Rpb24gZmlsdGVyUHJlZmVycmVkRm9ybWF0KHN0ciwgY29udGV4dCkge1xuICBjb25zdCB7IGZvbnQgfSA9IGNvbnRleHQ7XG4gIGNvbnN0IHByZWZlcnJlZEZvcm1hdCA9IGZvbnQgPyBmb250Py5wcmVmZXJyZWRGb3JtYXQgOiB2b2lkIDA7XG4gIHJldHVybiBwcmVmZXJyZWRGb3JtYXQgPyBzdHIucmVwbGFjZShGT05UX1NSQ19SRSwgKG1hdGNoKSA9PiB7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGNvbnN0IFtzcmMsICwgZm9ybWF0XSA9IFVSTF9XSVRIX0ZPUk1BVF9SRS5leGVjKG1hdGNoKSB8fCBbXTtcbiAgICAgIGlmICghZm9ybWF0KVxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIGlmIChmb3JtYXQgPT09IHByZWZlcnJlZEZvcm1hdClcbiAgICAgICAgcmV0dXJuIGBzcmM6ICR7c3JjfTtgO1xuICAgIH1cbiAgfSkgOiBzdHI7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGRvbVRvRm9yZWlnbk9iamVjdFN2Zyhub2RlLCBvcHRpb25zKSB7XG4gIGNvbnN0IGNvbnRleHQgPSBhd2FpdCBvckNyZWF0ZUNvbnRleHQobm9kZSwgb3B0aW9ucyk7XG4gIGlmIChpc0VsZW1lbnROb2RlKGNvbnRleHQubm9kZSkgJiYgaXNTVkdFbGVtZW50Tm9kZShjb250ZXh0Lm5vZGUpKVxuICAgIHJldHVybiBjb250ZXh0Lm5vZGU7XG4gIGNvbnN0IHtcbiAgICBvd25lckRvY3VtZW50LFxuICAgIGxvZyxcbiAgICB0YXNrcyxcbiAgICBzdmdTdHlsZUVsZW1lbnQsXG4gICAgc3ZnRGVmc0VsZW1lbnQsXG4gICAgc3ZnU3R5bGVzLFxuICAgIGZvbnQsXG4gICAgcHJvZ3Jlc3MsXG4gICAgYXV0b0Rlc3RydWN0LFxuICAgIG9uQ2xvbmVOb2RlLFxuICAgIG9uRW1iZWROb2RlLFxuICAgIG9uQ3JlYXRlRm9yZWlnbk9iamVjdFN2Z1xuICB9ID0gY29udGV4dDtcbiAgbG9nLnRpbWUoXCJjbG9uZSBub2RlXCIpO1xuICBjb25zdCBjbG9uZSA9IGF3YWl0IGNsb25lTm9kZShjb250ZXh0Lm5vZGUsIGNvbnRleHQsIHRydWUpO1xuICBpZiAoc3ZnU3R5bGVFbGVtZW50ICYmIG93bmVyRG9jdW1lbnQpIHtcbiAgICBsZXQgYWxsQ3NzVGV4dCA9IFwiXCI7XG4gICAgc3ZnU3R5bGVzLmZvckVhY2goKGtsYXNzZXMsIGNzc1RleHQpID0+IHtcbiAgICAgIGFsbENzc1RleHQgKz0gYCR7a2xhc3Nlcy5qb2luKFwiLFxcblwiKX0ge1xuICAke2Nzc1RleHR9XG59XG5gO1xuICAgIH0pO1xuICAgIHN2Z1N0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChvd25lckRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGFsbENzc1RleHQpKTtcbiAgfVxuICBsb2cudGltZUVuZChcImNsb25lIG5vZGVcIik7XG4gIGF3YWl0IG9uQ2xvbmVOb2RlPy4oY2xvbmUpO1xuICBpZiAoZm9udCAhPT0gZmFsc2UgJiYgaXNFbGVtZW50Tm9kZShjbG9uZSkpIHtcbiAgICBsb2cudGltZShcImVtYmVkIHdlYiBmb250XCIpO1xuICAgIGF3YWl0IGVtYmVkV2ViRm9udChjbG9uZSwgY29udGV4dCk7XG4gICAgbG9nLnRpbWVFbmQoXCJlbWJlZCB3ZWIgZm9udFwiKTtcbiAgfVxuICBsb2cudGltZShcImVtYmVkIG5vZGVcIik7XG4gIGVtYmVkTm9kZShjbG9uZSwgY29udGV4dCk7XG4gIGNvbnN0IGNvdW50ID0gdGFza3MubGVuZ3RoO1xuICBsZXQgY3VycmVudCA9IDA7XG4gIGNvbnN0IHJ1blRhc2sgPSBhc3luYyAoKSA9PiB7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGNvbnN0IHRhc2sgPSB0YXNrcy5wb3AoKTtcbiAgICAgIGlmICghdGFzaylcbiAgICAgICAgYnJlYWs7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCB0YXNrO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29udGV4dC5sb2cud2FybihcIkZhaWxlZCB0byBydW4gdGFza1wiLCBlcnJvcik7XG4gICAgICB9XG4gICAgICBwcm9ncmVzcz8uKCsrY3VycmVudCwgY291bnQpO1xuICAgIH1cbiAgfTtcbiAgcHJvZ3Jlc3M/LihjdXJyZW50LCBjb3VudCk7XG4gIGF3YWl0IFByb21pc2UuYWxsKFsuLi5BcnJheS5mcm9tKHsgbGVuZ3RoOiA0IH0pXS5tYXAocnVuVGFzaykpO1xuICBsb2cudGltZUVuZChcImVtYmVkIG5vZGVcIik7XG4gIGF3YWl0IG9uRW1iZWROb2RlPy4oY2xvbmUpO1xuICBjb25zdCBzdmcgPSBjcmVhdGVGb3JlaWduT2JqZWN0U3ZnKGNsb25lLCBjb250ZXh0KTtcbiAgc3ZnRGVmc0VsZW1lbnQgJiYgc3ZnLmluc2VydEJlZm9yZShzdmdEZWZzRWxlbWVudCwgc3ZnLmNoaWxkcmVuWzBdKTtcbiAgc3ZnU3R5bGVFbGVtZW50ICYmIHN2Zy5pbnNlcnRCZWZvcmUoc3ZnU3R5bGVFbGVtZW50LCBzdmcuY2hpbGRyZW5bMF0pO1xuICBhdXRvRGVzdHJ1Y3QgJiYgZGVzdHJveUNvbnRleHQoY29udGV4dCk7XG4gIGF3YWl0IG9uQ3JlYXRlRm9yZWlnbk9iamVjdFN2Zz8uKHN2Zyk7XG4gIHJldHVybiBzdmc7XG59XG5mdW5jdGlvbiBjcmVhdGVGb3JlaWduT2JqZWN0U3ZnKGNsb25lLCBjb250ZXh0KSB7XG4gIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gY29udGV4dDtcbiAgY29uc3Qgc3ZnID0gY3JlYXRlU3ZnKHdpZHRoLCBoZWlnaHQsIGNsb25lLm93bmVyRG9jdW1lbnQpO1xuICBjb25zdCBmb3JlaWduT2JqZWN0ID0gc3ZnLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHN2Zy5uYW1lc3BhY2VVUkksIFwiZm9yZWlnbk9iamVjdFwiKTtcbiAgZm9yZWlnbk9iamVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInhcIiwgXCIwJVwiKTtcbiAgZm9yZWlnbk9iamVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInlcIiwgXCIwJVwiKTtcbiAgZm9yZWlnbk9iamVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcIndpZHRoXCIsIFwiMTAwJVwiKTtcbiAgZm9yZWlnbk9iamVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImhlaWdodFwiLCBcIjEwMCVcIik7XG4gIGZvcmVpZ25PYmplY3QuYXBwZW5kKGNsb25lKTtcbiAgc3ZnLmFwcGVuZENoaWxkKGZvcmVpZ25PYmplY3QpO1xuICByZXR1cm4gc3ZnO1xufVxuXG5hc3luYyBmdW5jdGlvbiBkb21Ub0NhbnZhcyhub2RlLCBvcHRpb25zKSB7XG4gIGNvbnN0IGNvbnRleHQgPSBhd2FpdCBvckNyZWF0ZUNvbnRleHQobm9kZSwgb3B0aW9ucyk7XG4gIGNvbnN0IHN2ZyA9IGF3YWl0IGRvbVRvRm9yZWlnbk9iamVjdFN2Zyhjb250ZXh0KTtcbiAgY29uc3QgZGF0YVVybCA9IHN2Z1RvRGF0YVVybChzdmcsIGNvbnRleHQuaXNFbmFibGUoXCJyZW1vdmVDb250cm9sQ2hhcmFjdGVyXCIpKTtcbiAgaWYgKCFjb250ZXh0LmF1dG9EZXN0cnVjdCkge1xuICAgIGNvbnRleHQuc3ZnU3R5bGVFbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KGNvbnRleHQub3duZXJEb2N1bWVudCk7XG4gICAgY29udGV4dC5zdmdEZWZzRWxlbWVudCA9IGNvbnRleHQub3duZXJEb2N1bWVudD8uY3JlYXRlRWxlbWVudE5TKFhNTE5TLCBcImRlZnNcIik7XG4gICAgY29udGV4dC5zdmdTdHlsZXMuY2xlYXIoKTtcbiAgfVxuICBjb25zdCBpbWFnZSA9IGNyZWF0ZUltYWdlKGRhdGFVcmwsIHN2Zy5vd25lckRvY3VtZW50KTtcbiAgcmV0dXJuIGF3YWl0IGltYWdlVG9DYW52YXMoaW1hZ2UsIGNvbnRleHQpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBkb21Ub0Jsb2Iobm9kZSwgb3B0aW9ucykge1xuICBjb25zdCBjb250ZXh0ID0gYXdhaXQgb3JDcmVhdGVDb250ZXh0KG5vZGUsIG9wdGlvbnMpO1xuICBjb25zdCB7IGxvZywgdHlwZSwgcXVhbGl0eSwgZHBpIH0gPSBjb250ZXh0O1xuICBjb25zdCBjYW52YXMgPSBhd2FpdCBkb21Ub0NhbnZhcyhjb250ZXh0KTtcbiAgbG9nLnRpbWUoXCJjYW52YXMgdG8gYmxvYlwiKTtcbiAgY29uc3QgYmxvYiA9IGF3YWl0IGNhbnZhc1RvQmxvYihjYW52YXMsIHR5cGUsIHF1YWxpdHkpO1xuICBpZiAoW1wiaW1hZ2UvcG5nXCIsIFwiaW1hZ2UvanBlZ1wiXS5pbmNsdWRlcyh0eXBlKSAmJiBkcGkpIHtcbiAgICBjb25zdCBhcnJheUJ1ZmZlciA9IGF3YWl0IGJsb2JUb0FycmF5QnVmZmVyKGJsb2Iuc2xpY2UoMCwgMzMpKTtcbiAgICBsZXQgdWludDhBcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKTtcbiAgICBpZiAodHlwZSA9PT0gXCJpbWFnZS9wbmdcIikge1xuICAgICAgdWludDhBcnJheSA9IGNoYW5nZVBuZ0RwaSh1aW50OEFycmF5LCBkcGkpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJpbWFnZS9qcGVnXCIpIHtcbiAgICAgIHVpbnQ4QXJyYXkgPSBjaGFuZ2VKcGVnRHBpKHVpbnQ4QXJyYXksIGRwaSk7XG4gICAgfVxuICAgIGxvZy50aW1lRW5kKFwiY2FudmFzIHRvIGJsb2JcIik7XG4gICAgcmV0dXJuIG5ldyBCbG9iKFt1aW50OEFycmF5LCBibG9iLnNsaWNlKDMzKV0sIHsgdHlwZSB9KTtcbiAgfVxuICBsb2cudGltZUVuZChcImNhbnZhcyB0byBibG9iXCIpO1xuICByZXR1cm4gYmxvYjtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZG9tVG9EYXRhVXJsKG5vZGUsIG9wdGlvbnMpIHtcbiAgY29uc3QgY29udGV4dCA9IGF3YWl0IG9yQ3JlYXRlQ29udGV4dChub2RlLCBvcHRpb25zKTtcbiAgY29uc3QgeyBsb2csIHF1YWxpdHksIHR5cGUsIGRwaSB9ID0gY29udGV4dDtcbiAgY29uc3QgY2FudmFzID0gYXdhaXQgZG9tVG9DYW52YXMoY29udGV4dCk7XG4gIGxvZy50aW1lKFwiY2FudmFzIHRvIGRhdGEgdXJsXCIpO1xuICBsZXQgZGF0YVVybCA9IGNhbnZhcy50b0RhdGFVUkwodHlwZSwgcXVhbGl0eSk7XG4gIGlmIChbXCJpbWFnZS9wbmdcIiwgXCJpbWFnZS9qcGVnXCJdLmluY2x1ZGVzKHR5cGUpICYmIGRwaSAmJiBTVVBQT1JUX0FUT0IgJiYgU1VQUE9SVF9CVE9BKSB7XG4gICAgY29uc3QgW2Zvcm1hdCwgYm9keV0gPSBkYXRhVXJsLnNwbGl0KFwiLFwiKTtcbiAgICBsZXQgaGVhZGVyTGVuZ3RoID0gMDtcbiAgICBsZXQgb3ZlcndyaXRlcEhZcyA9IGZhbHNlO1xuICAgIGlmICh0eXBlID09PSBcImltYWdlL3BuZ1wiKSB7XG4gICAgICBjb25zdCBiNjRJbmRleCA9IGRldGVjdFBoeXNDaHVua0Zyb21EYXRhVXJsKGJvZHkpO1xuICAgICAgaWYgKGI2NEluZGV4ID49IDApIHtcbiAgICAgICAgaGVhZGVyTGVuZ3RoID0gTWF0aC5jZWlsKChiNjRJbmRleCArIDI4KSAvIDMpICogNDtcbiAgICAgICAgb3ZlcndyaXRlcEhZcyA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoZWFkZXJMZW5ndGggPSAzMyAvIDMgKiA0O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJpbWFnZS9qcGVnXCIpIHtcbiAgICAgIGhlYWRlckxlbmd0aCA9IDE4IC8gMyAqIDQ7XG4gICAgfVxuICAgIGNvbnN0IHN0cmluZ0hlYWRlciA9IGJvZHkuc3Vic3RyaW5nKDAsIGhlYWRlckxlbmd0aCk7XG4gICAgY29uc3QgcmVzdE9mRGF0YSA9IGJvZHkuc3Vic3RyaW5nKGhlYWRlckxlbmd0aCk7XG4gICAgY29uc3QgaGVhZGVyQnl0ZXMgPSB3aW5kb3cuYXRvYihzdHJpbmdIZWFkZXIpO1xuICAgIGNvbnN0IHVpbnQ4QXJyYXkgPSBuZXcgVWludDhBcnJheShoZWFkZXJCeXRlcy5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdWludDhBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgdWludDhBcnJheVtpXSA9IGhlYWRlckJ5dGVzLmNoYXJDb2RlQXQoaSk7XG4gICAgfVxuICAgIGNvbnN0IGZpbmFsQXJyYXkgPSB0eXBlID09PSBcImltYWdlL3BuZ1wiID8gY2hhbmdlUG5nRHBpKHVpbnQ4QXJyYXksIGRwaSwgb3ZlcndyaXRlcEhZcykgOiBjaGFuZ2VKcGVnRHBpKHVpbnQ4QXJyYXksIGRwaSk7XG4gICAgY29uc3QgYmFzZTY0SGVhZGVyID0gd2luZG93LmJ0b2EoU3RyaW5nLmZyb21DaGFyQ29kZSguLi5maW5hbEFycmF5KSk7XG4gICAgZGF0YVVybCA9IFtmb3JtYXQsIFwiLFwiLCBiYXNlNjRIZWFkZXIsIHJlc3RPZkRhdGFdLmpvaW4oXCJcIik7XG4gIH1cbiAgbG9nLnRpbWVFbmQoXCJjYW52YXMgdG8gZGF0YSB1cmxcIik7XG4gIHJldHVybiBkYXRhVXJsO1xufVxuXG5hc3luYyBmdW5jdGlvbiBkb21Ub1N2Zyhub2RlLCBvcHRpb25zKSB7XG4gIGNvbnN0IGNvbnRleHQgPSBhd2FpdCBvckNyZWF0ZUNvbnRleHQobm9kZSwgb3B0aW9ucyk7XG4gIGNvbnN0IHsgd2lkdGgsIGhlaWdodCwgb3duZXJEb2N1bWVudCB9ID0gY29udGV4dDtcbiAgY29uc3QgZGF0YVVybCA9IGF3YWl0IGRvbVRvRGF0YVVybChjb250ZXh0KTtcbiAgY29uc3Qgc3ZnID0gY3JlYXRlU3ZnKHdpZHRoLCBoZWlnaHQsIG93bmVyRG9jdW1lbnQpO1xuICBjb25zdCBzdmdJbWFnZSA9IHN2Zy5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhzdmcubmFtZXNwYWNlVVJJLCBcImltYWdlXCIpO1xuICBzdmdJbWFnZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImhyZWZcIiwgZGF0YVVybCk7XG4gIHN2Z0ltYWdlLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiaGVpZ2h0XCIsIFwiMTAwJVwiKTtcbiAgc3ZnSW1hZ2Uuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ3aWR0aFwiLCBcIjEwMCVcIik7XG4gIHN2Zy5hcHBlbmRDaGlsZChzdmdJbWFnZSk7XG4gIHJldHVybiBzdmdUb0RhdGFVcmwoc3ZnLCBjb250ZXh0LmlzRW5hYmxlKFwicmVtb3ZlQ29udHJvbENoYXJhY3RlclwiKSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGRvbVRvSW1hZ2Uobm9kZSwgb3B0aW9ucykge1xuICBjb25zdCBjb250ZXh0ID0gYXdhaXQgb3JDcmVhdGVDb250ZXh0KG5vZGUsIG9wdGlvbnMpO1xuICBjb25zdCB7IG93bmVyRG9jdW1lbnQsIHdpZHRoLCBoZWlnaHQsIHNjYWxlLCB0eXBlIH0gPSBjb250ZXh0O1xuICBjb25zdCB1cmwgPSB0eXBlID09PSBcImltYWdlL3N2Zyt4bWxcIiA/IGF3YWl0IGRvbVRvU3ZnKGNvbnRleHQpIDogYXdhaXQgZG9tVG9EYXRhVXJsKGNvbnRleHQpO1xuICBjb25zdCBpbWFnZSA9IGNyZWF0ZUltYWdlKHVybCwgb3duZXJEb2N1bWVudCk7XG4gIGltYWdlLndpZHRoID0gTWF0aC5mbG9vcih3aWR0aCAqIHNjYWxlKTtcbiAgaW1hZ2UuaGVpZ2h0ID0gTWF0aC5mbG9vcihoZWlnaHQgKiBzY2FsZSk7XG4gIGltYWdlLnN0eWxlLndpZHRoID0gYCR7d2lkdGh9cHhgO1xuICBpbWFnZS5zdHlsZS5oZWlnaHQgPSBgJHtoZWlnaHR9cHhgO1xuICByZXR1cm4gaW1hZ2U7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGRvbVRvSnBlZyhub2RlLCBvcHRpb25zKSB7XG4gIHJldHVybiBkb21Ub0RhdGFVcmwoXG4gICAgYXdhaXQgb3JDcmVhdGVDb250ZXh0KG5vZGUsIHsgLi4ub3B0aW9ucywgdHlwZTogXCJpbWFnZS9qcGVnXCIgfSlcbiAgKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZG9tVG9QaXhlbChub2RlLCBvcHRpb25zKSB7XG4gIGNvbnN0IGNvbnRleHQgPSBhd2FpdCBvckNyZWF0ZUNvbnRleHQobm9kZSwgb3B0aW9ucyk7XG4gIGNvbnN0IGNhbnZhcyA9IGF3YWl0IGRvbVRvQ2FudmFzKGNvbnRleHQpO1xuICByZXR1cm4gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKS5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KS5kYXRhO1xufVxuXG5hc3luYyBmdW5jdGlvbiBkb21Ub1BuZyhub2RlLCBvcHRpb25zKSB7XG4gIHJldHVybiBkb21Ub0RhdGFVcmwoXG4gICAgYXdhaXQgb3JDcmVhdGVDb250ZXh0KG5vZGUsIHsgLi4ub3B0aW9ucywgdHlwZTogXCJpbWFnZS9wbmdcIiB9KVxuICApO1xufVxuXG5hc3luYyBmdW5jdGlvbiBkb21Ub1dlYnAobm9kZSwgb3B0aW9ucykge1xuICByZXR1cm4gZG9tVG9EYXRhVXJsKFxuICAgIGF3YWl0IG9yQ3JlYXRlQ29udGV4dChub2RlLCB7IC4uLm9wdGlvbnMsIHR5cGU6IFwiaW1hZ2Uvd2VicFwiIH0pXG4gICk7XG59XG5cbmV4cG9ydCB7IGNyZWF0ZUNvbnRleHQsIGRlc3Ryb3lDb250ZXh0LCBkb21Ub0Jsb2IsIGRvbVRvQ2FudmFzLCBkb21Ub0RhdGFVcmwsIGRvbVRvRm9yZWlnbk9iamVjdFN2ZywgZG9tVG9JbWFnZSwgZG9tVG9KcGVnLCBkb21Ub1BpeGVsLCBkb21Ub1BuZywgZG9tVG9TdmcsIGRvbVRvV2VicCwgbG9hZE1lZGlhLCB3YWl0VW50aWxMb2FkIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/modern-screenshot/dist/index.mjs\n");

/***/ })

};
;