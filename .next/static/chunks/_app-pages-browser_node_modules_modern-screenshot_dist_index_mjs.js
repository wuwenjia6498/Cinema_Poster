"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_modern-screenshot_dist_index_mjs"],{

/***/ "(app-pages-browser)/./node_modules/modern-screenshot/dist/index.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/modern-screenshot/dist/index.mjs ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createContext: function() { return /* binding */ createContext; },\n/* harmony export */   destroyContext: function() { return /* binding */ destroyContext; },\n/* harmony export */   domToBlob: function() { return /* binding */ domToBlob; },\n/* harmony export */   domToCanvas: function() { return /* binding */ domToCanvas; },\n/* harmony export */   domToDataUrl: function() { return /* binding */ domToDataUrl; },\n/* harmony export */   domToForeignObjectSvg: function() { return /* binding */ domToForeignObjectSvg; },\n/* harmony export */   domToImage: function() { return /* binding */ domToImage; },\n/* harmony export */   domToJpeg: function() { return /* binding */ domToJpeg; },\n/* harmony export */   domToPixel: function() { return /* binding */ domToPixel; },\n/* harmony export */   domToPng: function() { return /* binding */ domToPng; },\n/* harmony export */   domToSvg: function() { return /* binding */ domToSvg; },\n/* harmony export */   domToWebp: function() { return /* binding */ domToWebp; },\n/* harmony export */   loadMedia: function() { return /* binding */ loadMedia; },\n/* harmony export */   waitUntilLoad: function() { return /* binding */ waitUntilLoad; }\n/* harmony export */ });\nfunction changeJpegDpi(uint8Array, dpi) {\n  uint8Array[13] = 1;\n  uint8Array[14] = dpi >> 8;\n  uint8Array[15] = dpi & 255;\n  uint8Array[16] = dpi >> 8;\n  uint8Array[17] = dpi & 255;\n  return uint8Array;\n}\n\nconst _P = \"p\".charCodeAt(0);\nconst _H = \"H\".charCodeAt(0);\nconst _Y = \"Y\".charCodeAt(0);\nconst _S = \"s\".charCodeAt(0);\nlet pngDataTable;\nfunction createPngDataTable() {\n  const crcTable = new Int32Array(256);\n  for (let n = 0; n < 256; n++) {\n    let c = n;\n    for (let k = 0; k < 8; k++) {\n      c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;\n    }\n    crcTable[n] = c;\n  }\n  return crcTable;\n}\nfunction calcCrc(uint8Array) {\n  let c = -1;\n  if (!pngDataTable)\n    pngDataTable = createPngDataTable();\n  for (let n = 0; n < uint8Array.length; n++) {\n    c = pngDataTable[(c ^ uint8Array[n]) & 255] ^ c >>> 8;\n  }\n  return c ^ -1;\n}\nfunction searchStartOfPhys(uint8Array) {\n  const length = uint8Array.length - 1;\n  for (let i = length; i >= 4; i--) {\n    if (uint8Array[i - 4] === 9 && uint8Array[i - 3] === _P && uint8Array[i - 2] === _H && uint8Array[i - 1] === _Y && uint8Array[i] === _S) {\n      return i - 3;\n    }\n  }\n  return 0;\n}\nfunction changePngDpi(uint8Array, dpi, overwritepHYs = false) {\n  const physChunk = new Uint8Array(13);\n  dpi *= 39.3701;\n  physChunk[0] = _P;\n  physChunk[1] = _H;\n  physChunk[2] = _Y;\n  physChunk[3] = _S;\n  physChunk[4] = dpi >>> 24;\n  physChunk[5] = dpi >>> 16;\n  physChunk[6] = dpi >>> 8;\n  physChunk[7] = dpi & 255;\n  physChunk[8] = physChunk[4];\n  physChunk[9] = physChunk[5];\n  physChunk[10] = physChunk[6];\n  physChunk[11] = physChunk[7];\n  physChunk[12] = 1;\n  const crc = calcCrc(physChunk);\n  const crcChunk = new Uint8Array(4);\n  crcChunk[0] = crc >>> 24;\n  crcChunk[1] = crc >>> 16;\n  crcChunk[2] = crc >>> 8;\n  crcChunk[3] = crc & 255;\n  if (overwritepHYs) {\n    const startingIndex = searchStartOfPhys(uint8Array);\n    uint8Array.set(physChunk, startingIndex);\n    uint8Array.set(crcChunk, startingIndex + 13);\n    return uint8Array;\n  } else {\n    const chunkLength = new Uint8Array(4);\n    chunkLength[0] = 0;\n    chunkLength[1] = 0;\n    chunkLength[2] = 0;\n    chunkLength[3] = 9;\n    const finalHeader = new Uint8Array(54);\n    finalHeader.set(uint8Array, 0);\n    finalHeader.set(chunkLength, 33);\n    finalHeader.set(physChunk, 37);\n    finalHeader.set(crcChunk, 50);\n    return finalHeader;\n  }\n}\nconst b64PhysSignature1 = \"AAlwSFlz\";\nconst b64PhysSignature2 = \"AAAJcEhZ\";\nconst b64PhysSignature3 = \"AAAACXBI\";\nfunction detectPhysChunkFromDataUrl(dataUrl) {\n  let b64index = dataUrl.indexOf(b64PhysSignature1);\n  if (b64index === -1) {\n    b64index = dataUrl.indexOf(b64PhysSignature2);\n  }\n  if (b64index === -1) {\n    b64index = dataUrl.indexOf(b64PhysSignature3);\n  }\n  return b64index;\n}\n\nconst PREFIX = \"[modern-screenshot]\";\nconst IN_BROWSER = typeof window !== \"undefined\";\nconst SUPPORT_WEB_WORKER = IN_BROWSER && \"Worker\" in window;\nconst SUPPORT_ATOB = IN_BROWSER && \"atob\" in window;\nconst SUPPORT_BTOA = IN_BROWSER && \"btoa\" in window;\nconst USER_AGENT = IN_BROWSER ? window.navigator?.userAgent : \"\";\nconst IN_CHROME = USER_AGENT.includes(\"Chrome\");\nconst IN_SAFARI = USER_AGENT.includes(\"AppleWebKit\") && !IN_CHROME;\nconst IN_FIREFOX = USER_AGENT.includes(\"Firefox\");\nconst isContext = (value) => value && \"__CONTEXT__\" in value;\nconst isCssFontFaceRule = (rule) => rule.constructor.name === \"CSSFontFaceRule\";\nconst isCSSImportRule = (rule) => rule.constructor.name === \"CSSImportRule\";\nconst isElementNode = (node) => node.nodeType === 1;\nconst isSVGElementNode = (node) => typeof node.className === \"object\";\nconst isSVGImageElementNode = (node) => node.tagName === \"image\";\nconst isSVGUseElementNode = (node) => node.tagName === \"use\";\nconst isHTMLElementNode = (node) => isElementNode(node) && typeof node.style !== \"undefined\" && !isSVGElementNode(node);\nconst isCommentNode = (node) => node.nodeType === 8;\nconst isTextNode = (node) => node.nodeType === 3;\nconst isImageElement = (node) => node.tagName === \"IMG\";\nconst isVideoElement = (node) => node.tagName === \"VIDEO\";\nconst isCanvasElement = (node) => node.tagName === \"CANVAS\";\nconst isTextareaElement = (node) => node.tagName === \"TEXTAREA\";\nconst isInputElement = (node) => node.tagName === \"INPUT\";\nconst isStyleElement = (node) => node.tagName === \"STYLE\";\nconst isScriptElement = (node) => node.tagName === \"SCRIPT\";\nconst isSelectElement = (node) => node.tagName === \"SELECT\";\nconst isSlotElement = (node) => node.tagName === \"SLOT\";\nconst isIFrameElement = (node) => node.tagName === \"IFRAME\";\nconst consoleWarn = (...args) => console.warn(PREFIX, ...args);\nfunction supportWebp(ownerDocument) {\n  const canvas = ownerDocument?.createElement?.(\"canvas\");\n  if (canvas) {\n    canvas.height = canvas.width = 1;\n  }\n  return Boolean(canvas) && \"toDataURL\" in canvas && Boolean(canvas.toDataURL(\"image/webp\").includes(\"image/webp\"));\n}\nconst isDataUrl = (url) => url.startsWith(\"data:\");\nfunction resolveUrl(url, baseUrl) {\n  if (url.match(/^[a-z]+:\\/\\//i))\n    return url;\n  if (IN_BROWSER && url.match(/^\\/\\//))\n    return window.location.protocol + url;\n  if (url.match(/^[a-z]+:/i))\n    return url;\n  if (!IN_BROWSER)\n    return url;\n  const doc = getDocument().implementation.createHTMLDocument();\n  const base = doc.createElement(\"base\");\n  const a = doc.createElement(\"a\");\n  doc.head.appendChild(base);\n  doc.body.appendChild(a);\n  if (baseUrl)\n    base.href = baseUrl;\n  a.href = url;\n  return a.href;\n}\nfunction getDocument(target) {\n  return (target && isElementNode(target) ? target?.ownerDocument : target) ?? window.document;\n}\nconst XMLNS = \"http://www.w3.org/2000/svg\";\nfunction createSvg(width, height, ownerDocument) {\n  const svg = getDocument(ownerDocument).createElementNS(XMLNS, \"svg\");\n  svg.setAttributeNS(null, \"width\", width.toString());\n  svg.setAttributeNS(null, \"height\", height.toString());\n  svg.setAttributeNS(null, \"viewBox\", `0 0 ${width} ${height}`);\n  return svg;\n}\nfunction svgToDataUrl(svg, removeControlCharacter) {\n  let xhtml = new XMLSerializer().serializeToString(svg);\n  if (removeControlCharacter) {\n    xhtml = xhtml.replace(/[\\u0000-\\u0008\\v\\f\\u000E-\\u001F\\uD800-\\uDFFF\\uFFFE\\uFFFF]/gu, \"\");\n  }\n  return `data:image/svg+xml;charset=utf-8,${encodeURIComponent(xhtml)}`;\n}\nasync function canvasToBlob(canvas, type = \"image/png\", quality = 1) {\n  try {\n    return await new Promise((resolve, reject) => {\n      canvas.toBlob((blob) => {\n        if (blob) {\n          resolve(blob);\n        } else {\n          reject(new Error(\"Blob is null\"));\n        }\n      }, type, quality);\n    });\n  } catch (error) {\n    if (SUPPORT_ATOB) {\n      return dataUrlToBlob(canvas.toDataURL(type, quality));\n    }\n    throw error;\n  }\n}\nfunction dataUrlToBlob(dataUrl) {\n  const [header, base64] = dataUrl.split(\",\");\n  const type = header.match(/data:(.+);/)?.[1] ?? void 0;\n  const decoded = window.atob(base64);\n  const length = decoded.length;\n  const buffer = new Uint8Array(length);\n  for (let i = 0; i < length; i += 1) {\n    buffer[i] = decoded.charCodeAt(i);\n  }\n  return new Blob([buffer], { type });\n}\nfunction readBlob(blob, type) {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onload = () => resolve(reader.result);\n    reader.onerror = () => reject(reader.error);\n    reader.onabort = () => reject(new Error(`Failed read blob to ${type}`));\n    if (type === \"dataUrl\") {\n      reader.readAsDataURL(blob);\n    } else if (type === \"arrayBuffer\") {\n      reader.readAsArrayBuffer(blob);\n    }\n  });\n}\nconst blobToDataUrl = (blob) => readBlob(blob, \"dataUrl\");\nconst blobToArrayBuffer = (blob) => readBlob(blob, \"arrayBuffer\");\nfunction createImage(url, ownerDocument) {\n  const img = getDocument(ownerDocument).createElement(\"img\");\n  img.decoding = \"sync\";\n  img.loading = \"eager\";\n  img.src = url;\n  return img;\n}\nfunction loadMedia(media, options) {\n  return new Promise((resolve) => {\n    const { timeout, ownerDocument, onError: userOnError, onWarn } = options ?? {};\n    const node = typeof media === \"string\" ? createImage(media, getDocument(ownerDocument)) : media;\n    let timer = null;\n    let removeEventListeners = null;\n    function onResolve() {\n      resolve(node);\n      timer && clearTimeout(timer);\n      removeEventListeners?.();\n    }\n    if (timeout) {\n      timer = setTimeout(onResolve, timeout);\n    }\n    if (isVideoElement(node)) {\n      const currentSrc = node.currentSrc || node.src;\n      if (!currentSrc) {\n        if (node.poster) {\n          return loadMedia(node.poster, options).then(resolve);\n        }\n        return onResolve();\n      }\n      if (node.readyState >= 2) {\n        return onResolve();\n      }\n      const onLoadeddata = onResolve;\n      const onError = (error) => {\n        onWarn?.(\n          \"Failed video load\",\n          currentSrc,\n          error\n        );\n        userOnError?.(error);\n        onResolve();\n      };\n      removeEventListeners = () => {\n        node.removeEventListener(\"loadeddata\", onLoadeddata);\n        node.removeEventListener(\"error\", onError);\n      };\n      node.addEventListener(\"loadeddata\", onLoadeddata, { once: true });\n      node.addEventListener(\"error\", onError, { once: true });\n    } else {\n      const currentSrc = isSVGImageElementNode(node) ? node.href.baseVal : node.currentSrc || node.src;\n      if (!currentSrc) {\n        return onResolve();\n      }\n      const onLoad = async () => {\n        if (isImageElement(node) && \"decode\" in node) {\n          try {\n            await node.decode();\n          } catch (error) {\n            onWarn?.(\n              \"Failed to decode image, trying to render anyway\",\n              node.dataset.originalSrc || currentSrc,\n              error\n            );\n          }\n        }\n        onResolve();\n      };\n      const onError = (error) => {\n        onWarn?.(\n          \"Failed image load\",\n          node.dataset.originalSrc || currentSrc,\n          error\n        );\n        onResolve();\n      };\n      if (isImageElement(node) && node.complete) {\n        return onLoad();\n      }\n      removeEventListeners = () => {\n        node.removeEventListener(\"load\", onLoad);\n        node.removeEventListener(\"error\", onError);\n      };\n      node.addEventListener(\"load\", onLoad, { once: true });\n      node.addEventListener(\"error\", onError, { once: true });\n    }\n  });\n}\nasync function waitUntilLoad(node, options) {\n  if (isHTMLElementNode(node)) {\n    if (isImageElement(node) || isVideoElement(node)) {\n      await loadMedia(node, options);\n    } else {\n      await Promise.all(\n        [\"img\", \"video\"].flatMap((selectors) => {\n          return Array.from(node.querySelectorAll(selectors)).map((el) => loadMedia(el, options));\n        })\n      );\n    }\n  }\n}\nconst uuid = /* @__PURE__ */ function uuid2() {\n  let counter = 0;\n  const random = () => `0000${(Math.random() * 36 ** 4 << 0).toString(36)}`.slice(-4);\n  return () => {\n    counter += 1;\n    return `u${random()}${counter}`;\n  };\n}();\nfunction splitFontFamily(fontFamily) {\n  return fontFamily?.split(\",\").map((val) => val.trim().replace(/\"|'/g, \"\").toLowerCase()).filter(Boolean);\n}\n\nlet uid = 0;\nfunction createLogger(debug) {\n  const prefix = `${PREFIX}[#${uid}]`;\n  uid++;\n  return {\n    // eslint-disable-next-line no-console\n    time: (label) => debug && console.time(`${prefix} ${label}`),\n    // eslint-disable-next-line no-console\n    timeEnd: (label) => debug && console.timeEnd(`${prefix} ${label}`),\n    warn: (...args) => debug && consoleWarn(...args)\n  };\n}\n\nfunction getDefaultRequestInit(bypassingCache) {\n  return {\n    cache: bypassingCache ? \"no-cache\" : \"force-cache\"\n  };\n}\n\nasync function orCreateContext(node, options) {\n  return isContext(node) ? node : createContext(node, { ...options, autoDestruct: true });\n}\nasync function createContext(node, options) {\n  const { scale = 1, workerUrl, workerNumber = 1 } = options || {};\n  const debug = Boolean(options?.debug);\n  const features = options?.features ?? true;\n  const ownerDocument = node.ownerDocument ?? (IN_BROWSER ? window.document : void 0);\n  const ownerWindow = node.ownerDocument?.defaultView ?? (IN_BROWSER ? window : void 0);\n  const requests = /* @__PURE__ */ new Map();\n  const context = {\n    // Options\n    width: 0,\n    height: 0,\n    quality: 1,\n    type: \"image/png\",\n    scale,\n    backgroundColor: null,\n    style: null,\n    filter: null,\n    maximumCanvasSize: 0,\n    timeout: 3e4,\n    progress: null,\n    debug,\n    fetch: {\n      requestInit: getDefaultRequestInit(options?.fetch?.bypassingCache),\n      placeholderImage: \"data:image/png;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\",\n      bypassingCache: false,\n      ...options?.fetch\n    },\n    fetchFn: null,\n    font: {},\n    drawImageInterval: 100,\n    workerUrl: null,\n    workerNumber,\n    onCloneEachNode: null,\n    onCloneNode: null,\n    onEmbedNode: null,\n    onCreateForeignObjectSvg: null,\n    includeStyleProperties: null,\n    autoDestruct: false,\n    ...options,\n    // InternalContext\n    __CONTEXT__: true,\n    log: createLogger(debug),\n    node,\n    ownerDocument,\n    ownerWindow,\n    dpi: scale === 1 ? null : 96 * scale,\n    svgStyleElement: createStyleElement(ownerDocument),\n    svgDefsElement: ownerDocument?.createElementNS(XMLNS, \"defs\"),\n    svgStyles: /* @__PURE__ */ new Map(),\n    defaultComputedStyles: /* @__PURE__ */ new Map(),\n    workers: [\n      ...Array.from({\n        length: SUPPORT_WEB_WORKER && workerUrl && workerNumber ? workerNumber : 0\n      })\n    ].map(() => {\n      try {\n        const worker = new Worker(workerUrl);\n        worker.onmessage = async (event) => {\n          const { url, result } = event.data;\n          if (result) {\n            requests.get(url)?.resolve?.(result);\n          } else {\n            requests.get(url)?.reject?.(new Error(`Error receiving message from worker: ${url}`));\n          }\n        };\n        worker.onmessageerror = (event) => {\n          const { url } = event.data;\n          requests.get(url)?.reject?.(new Error(`Error receiving message from worker: ${url}`));\n        };\n        return worker;\n      } catch (error) {\n        context.log.warn(\"Failed to new Worker\", error);\n        return null;\n      }\n    }).filter(Boolean),\n    fontFamilies: /* @__PURE__ */ new Map(),\n    fontCssTexts: /* @__PURE__ */ new Map(),\n    acceptOfImage: `${[\n      supportWebp(ownerDocument) && \"image/webp\",\n      \"image/svg+xml\",\n      \"image/*\",\n      \"*/*\"\n    ].filter(Boolean).join(\",\")};q=0.8`,\n    requests,\n    drawImageCount: 0,\n    tasks: [],\n    features,\n    isEnable: (key) => {\n      if (key === \"restoreScrollPosition\") {\n        return typeof features === \"boolean\" ? false : features[key] ?? false;\n      }\n      if (typeof features === \"boolean\") {\n        return features;\n      }\n      return features[key] ?? true;\n    },\n    shadowRoots: []\n  };\n  context.log.time(\"wait until load\");\n  await waitUntilLoad(node, { timeout: context.timeout, onWarn: context.log.warn });\n  context.log.timeEnd(\"wait until load\");\n  const { width, height } = resolveBoundingBox(node, context);\n  context.width = width;\n  context.height = height;\n  return context;\n}\nfunction createStyleElement(ownerDocument) {\n  if (!ownerDocument)\n    return void 0;\n  const style = ownerDocument.createElement(\"style\");\n  const cssText = style.ownerDocument.createTextNode(`\n.______background-clip--text {\n  background-clip: text;\n  -webkit-background-clip: text;\n}\n`);\n  style.appendChild(cssText);\n  return style;\n}\nfunction resolveBoundingBox(node, context) {\n  let { width, height } = context;\n  if (isElementNode(node) && (!width || !height)) {\n    const box = node.getBoundingClientRect();\n    width = width || box.width || Number(node.getAttribute(\"width\")) || 0;\n    height = height || box.height || Number(node.getAttribute(\"height\")) || 0;\n  }\n  return { width, height };\n}\n\nasync function imageToCanvas(image, context) {\n  const {\n    log,\n    timeout,\n    drawImageCount,\n    drawImageInterval\n  } = context;\n  log.time(\"image to canvas\");\n  const loaded = await loadMedia(image, { timeout, onWarn: context.log.warn });\n  const { canvas, context2d } = createCanvas(image.ownerDocument, context);\n  const drawImage = () => {\n    try {\n      context2d?.drawImage(loaded, 0, 0, canvas.width, canvas.height);\n    } catch (error) {\n      context.log.warn(\"Failed to drawImage\", error);\n    }\n  };\n  drawImage();\n  if (context.isEnable(\"fixSvgXmlDecode\")) {\n    for (let i = 0; i < drawImageCount; i++) {\n      await new Promise((resolve) => {\n        setTimeout(() => {\n          context2d?.clearRect(0, 0, canvas.width, canvas.height);\n          drawImage();\n          resolve();\n        }, i + drawImageInterval);\n      });\n    }\n  }\n  context.drawImageCount = 0;\n  log.timeEnd(\"image to canvas\");\n  return canvas;\n}\nfunction createCanvas(ownerDocument, context) {\n  const { width, height, scale, backgroundColor, maximumCanvasSize: max } = context;\n  const canvas = ownerDocument.createElement(\"canvas\");\n  canvas.width = Math.floor(width * scale);\n  canvas.height = Math.floor(height * scale);\n  canvas.style.width = `${width}px`;\n  canvas.style.height = `${height}px`;\n  if (max) {\n    if (canvas.width > max || canvas.height > max) {\n      if (canvas.width > max && canvas.height > max) {\n        if (canvas.width > canvas.height) {\n          canvas.height *= max / canvas.width;\n          canvas.width = max;\n        } else {\n          canvas.width *= max / canvas.height;\n          canvas.height = max;\n        }\n      } else if (canvas.width > max) {\n        canvas.height *= max / canvas.width;\n        canvas.width = max;\n      } else {\n        canvas.width *= max / canvas.height;\n        canvas.height = max;\n      }\n    }\n  }\n  const context2d = canvas.getContext(\"2d\");\n  if (context2d && backgroundColor) {\n    context2d.fillStyle = backgroundColor;\n    context2d.fillRect(0, 0, canvas.width, canvas.height);\n  }\n  return { canvas, context2d };\n}\n\nfunction cloneCanvas(canvas, context) {\n  if (canvas.ownerDocument) {\n    try {\n      const dataURL = canvas.toDataURL();\n      if (dataURL !== \"data:,\") {\n        return createImage(dataURL, canvas.ownerDocument);\n      }\n    } catch (error) {\n      context.log.warn(\"Failed to clone canvas\", error);\n    }\n  }\n  const cloned = canvas.cloneNode(false);\n  const ctx = canvas.getContext(\"2d\");\n  const clonedCtx = cloned.getContext(\"2d\");\n  try {\n    if (ctx && clonedCtx) {\n      clonedCtx.putImageData(\n        ctx.getImageData(0, 0, canvas.width, canvas.height),\n        0,\n        0\n      );\n    }\n    return cloned;\n  } catch (error) {\n    context.log.warn(\"Failed to clone canvas\", error);\n  }\n  return cloned;\n}\n\nfunction cloneIframe(iframe, context) {\n  try {\n    if (iframe?.contentDocument?.body) {\n      return cloneNode(iframe.contentDocument.body, context);\n    }\n  } catch (error) {\n    context.log.warn(\"Failed to clone iframe\", error);\n  }\n  return iframe.cloneNode(false);\n}\n\nfunction cloneImage(image) {\n  const cloned = image.cloneNode(false);\n  if (image.currentSrc && image.currentSrc !== image.src) {\n    cloned.src = image.currentSrc;\n    cloned.srcset = \"\";\n  }\n  if (cloned.loading === \"lazy\") {\n    cloned.loading = \"eager\";\n  }\n  return cloned;\n}\n\nasync function cloneVideo(video, context) {\n  if (video.ownerDocument && !video.currentSrc && video.poster) {\n    return createImage(video.poster, video.ownerDocument);\n  }\n  const cloned = video.cloneNode(false);\n  cloned.crossOrigin = \"anonymous\";\n  if (video.currentSrc && video.currentSrc !== video.src) {\n    cloned.src = video.currentSrc;\n  }\n  const ownerDocument = cloned.ownerDocument;\n  if (ownerDocument) {\n    let canPlay = true;\n    await loadMedia(cloned, { onError: () => canPlay = false, onWarn: context.log.warn });\n    if (!canPlay) {\n      if (video.poster) {\n        return createImage(video.poster, video.ownerDocument);\n      }\n      return cloned;\n    }\n    cloned.currentTime = video.currentTime;\n    await new Promise((resolve) => {\n      cloned.addEventListener(\"seeked\", resolve, { once: true });\n    });\n    const canvas = ownerDocument.createElement(\"canvas\");\n    canvas.width = video.offsetWidth;\n    canvas.height = video.offsetHeight;\n    try {\n      const ctx = canvas.getContext(\"2d\");\n      if (ctx)\n        ctx.drawImage(cloned, 0, 0, canvas.width, canvas.height);\n    } catch (error) {\n      context.log.warn(\"Failed to clone video\", error);\n      if (video.poster) {\n        return createImage(video.poster, video.ownerDocument);\n      }\n      return cloned;\n    }\n    return cloneCanvas(canvas, context);\n  }\n  return cloned;\n}\n\nfunction cloneElement(node, context) {\n  if (isCanvasElement(node)) {\n    return cloneCanvas(node, context);\n  }\n  if (isIFrameElement(node)) {\n    return cloneIframe(node, context);\n  }\n  if (isImageElement(node)) {\n    return cloneImage(node);\n  }\n  if (isVideoElement(node)) {\n    return cloneVideo(node, context);\n  }\n  return node.cloneNode(false);\n}\n\nfunction getSandBox(context) {\n  let sandbox = context.sandbox;\n  if (!sandbox) {\n    const { ownerDocument } = context;\n    try {\n      if (ownerDocument) {\n        sandbox = ownerDocument.createElement(\"iframe\");\n        sandbox.id = `__SANDBOX__${uuid()}`;\n        sandbox.width = \"0\";\n        sandbox.height = \"0\";\n        sandbox.style.visibility = \"hidden\";\n        sandbox.style.position = \"fixed\";\n        ownerDocument.body.appendChild(sandbox);\n        sandbox.srcdoc = '<!DOCTYPE html><meta charset=\"UTF-8\"><title></title><body>';\n        context.sandbox = sandbox;\n      }\n    } catch (error) {\n      context.log.warn(\"Failed to getSandBox\", error);\n    }\n  }\n  return sandbox;\n}\n\nconst ignoredStyles = [\n  \"width\",\n  \"height\",\n  \"-webkit-text-fill-color\"\n];\nconst includedAttributes = [\n  \"stroke\",\n  \"fill\"\n];\nfunction getDefaultStyle(node, pseudoElement, context) {\n  const { defaultComputedStyles } = context;\n  const nodeName = node.nodeName.toLowerCase();\n  const isSvgNode = isSVGElementNode(node) && nodeName !== \"svg\";\n  const attributes = isSvgNode ? includedAttributes.map((name) => [name, node.getAttribute(name)]).filter(([, value]) => value !== null) : [];\n  const key = [\n    isSvgNode && \"svg\",\n    nodeName,\n    attributes.map((name, value) => `${name}=${value}`).join(\",\"),\n    pseudoElement\n  ].filter(Boolean).join(\":\");\n  if (defaultComputedStyles.has(key))\n    return defaultComputedStyles.get(key);\n  const sandbox = getSandBox(context);\n  const sandboxWindow = sandbox?.contentWindow;\n  if (!sandboxWindow)\n    return /* @__PURE__ */ new Map();\n  const sandboxDocument = sandboxWindow?.document;\n  let root;\n  let el;\n  if (isSvgNode) {\n    root = sandboxDocument.createElementNS(XMLNS, \"svg\");\n    el = root.ownerDocument.createElementNS(root.namespaceURI, nodeName);\n    attributes.forEach(([name, value]) => {\n      el.setAttributeNS(null, name, value);\n    });\n    root.appendChild(el);\n  } else {\n    root = el = sandboxDocument.createElement(nodeName);\n  }\n  el.textContent = \" \";\n  sandboxDocument.body.appendChild(root);\n  const computedStyle = sandboxWindow.getComputedStyle(el, pseudoElement);\n  const styles = /* @__PURE__ */ new Map();\n  for (let len = computedStyle.length, i = 0; i < len; i++) {\n    const name = computedStyle.item(i);\n    if (ignoredStyles.includes(name))\n      continue;\n    styles.set(name, computedStyle.getPropertyValue(name));\n  }\n  sandboxDocument.body.removeChild(root);\n  defaultComputedStyles.set(key, styles);\n  return styles;\n}\n\nfunction getDiffStyle(style, defaultStyle, includeStyleProperties) {\n  const diffStyle = /* @__PURE__ */ new Map();\n  const prefixs = [];\n  const prefixTree = /* @__PURE__ */ new Map();\n  if (includeStyleProperties) {\n    for (const name of includeStyleProperties) {\n      applyTo(name);\n    }\n  } else {\n    for (let len = style.length, i = 0; i < len; i++) {\n      const name = style.item(i);\n      applyTo(name);\n    }\n  }\n  for (let len = prefixs.length, i = 0; i < len; i++) {\n    prefixTree.get(prefixs[i])?.forEach((value, name) => diffStyle.set(name, value));\n  }\n  function applyTo(name) {\n    const value = style.getPropertyValue(name);\n    const priority = style.getPropertyPriority(name);\n    const subIndex = name.lastIndexOf(\"-\");\n    const prefix = subIndex > -1 ? name.substring(0, subIndex) : void 0;\n    if (prefix) {\n      let map = prefixTree.get(prefix);\n      if (!map) {\n        map = /* @__PURE__ */ new Map();\n        prefixTree.set(prefix, map);\n      }\n      map.set(name, [value, priority]);\n    }\n    if (defaultStyle.get(name) === value && !priority)\n      return;\n    if (prefix) {\n      prefixs.push(prefix);\n    } else {\n      diffStyle.set(name, [value, priority]);\n    }\n  }\n  return diffStyle;\n}\n\nfunction copyCssStyles(node, cloned, isRoot, context) {\n  const { ownerWindow, includeStyleProperties, currentParentNodeStyle } = context;\n  const clonedStyle = cloned.style;\n  const computedStyle = ownerWindow.getComputedStyle(node);\n  const defaultStyle = getDefaultStyle(node, null, context);\n  currentParentNodeStyle?.forEach((_, key) => {\n    defaultStyle.delete(key);\n  });\n  const style = getDiffStyle(computedStyle, defaultStyle, includeStyleProperties);\n  style.delete(\"transition-property\");\n  style.delete(\"all\");\n  style.delete(\"d\");\n  style.delete(\"content\");\n  if (isRoot) {\n    style.delete(\"margin-top\");\n    style.delete(\"margin-right\");\n    style.delete(\"margin-bottom\");\n    style.delete(\"margin-left\");\n    style.delete(\"margin-block-start\");\n    style.delete(\"margin-block-end\");\n    style.delete(\"margin-inline-start\");\n    style.delete(\"margin-inline-end\");\n    style.set(\"box-sizing\", [\"border-box\", \"\"]);\n  }\n  if (style.get(\"background-clip\")?.[0] === \"text\") {\n    cloned.classList.add(\"______background-clip--text\");\n  }\n  if (IN_CHROME) {\n    if (!style.has(\"font-kerning\"))\n      style.set(\"font-kerning\", [\"normal\", \"\"]);\n    if ((style.get(\"overflow-x\")?.[0] === \"hidden\" || style.get(\"overflow-y\")?.[0] === \"hidden\") && style.get(\"text-overflow\")?.[0] === \"ellipsis\" && node.scrollWidth === node.clientWidth) {\n      style.set(\"text-overflow\", [\"clip\", \"\"]);\n    }\n  }\n  for (let len = clonedStyle.length, i = 0; i < len; i++) {\n    clonedStyle.removeProperty(clonedStyle.item(i));\n  }\n  style.forEach(([value, priority], name) => {\n    clonedStyle.setProperty(name, value, priority);\n  });\n  return style;\n}\n\nfunction copyInputValue(node, cloned) {\n  if (isTextareaElement(node) || isInputElement(node) || isSelectElement(node)) {\n    cloned.setAttribute(\"value\", node.value);\n  }\n}\n\nconst pseudoClasses = [\n  \"::before\",\n  \"::after\"\n  // '::placeholder', TODO\n];\nconst scrollbarPseudoClasses = [\n  \"::-webkit-scrollbar\",\n  \"::-webkit-scrollbar-button\",\n  // '::-webkit-scrollbar:horizontal', TODO\n  \"::-webkit-scrollbar-thumb\",\n  \"::-webkit-scrollbar-track\",\n  \"::-webkit-scrollbar-track-piece\",\n  // '::-webkit-scrollbar:vertical', TODO\n  \"::-webkit-scrollbar-corner\",\n  \"::-webkit-resizer\"\n];\nfunction copyPseudoClass(node, cloned, copyScrollbar, context, addWordToFontFamilies) {\n  const { ownerWindow, svgStyleElement, svgStyles, currentNodeStyle } = context;\n  if (!svgStyleElement || !ownerWindow)\n    return;\n  function copyBy(pseudoClass) {\n    const computedStyle = ownerWindow.getComputedStyle(node, pseudoClass);\n    let content = computedStyle.getPropertyValue(\"content\");\n    if (!content || content === \"none\")\n      return;\n    addWordToFontFamilies?.(content);\n    content = content.replace(/(')|(\")|(counter\\(.+\\))/g, \"\");\n    const klasses = [uuid()];\n    const defaultStyle = getDefaultStyle(node, pseudoClass, context);\n    currentNodeStyle?.forEach((_, key) => {\n      defaultStyle.delete(key);\n    });\n    const style = getDiffStyle(computedStyle, defaultStyle, context.includeStyleProperties);\n    style.delete(\"content\");\n    style.delete(\"-webkit-locale\");\n    if (style.get(\"background-clip\")?.[0] === \"text\") {\n      cloned.classList.add(\"______background-clip--text\");\n    }\n    const cloneStyle = [\n      `content: '${content}';`\n    ];\n    style.forEach(([value, priority], name) => {\n      cloneStyle.push(`${name}: ${value}${priority ? \" !important\" : \"\"};`);\n    });\n    if (cloneStyle.length === 1)\n      return;\n    try {\n      cloned.className = [cloned.className, ...klasses].join(\" \");\n    } catch (err) {\n      context.log.warn(\"Failed to copyPseudoClass\", err);\n      return;\n    }\n    const cssText = cloneStyle.join(\"\\n  \");\n    let allClasses = svgStyles.get(cssText);\n    if (!allClasses) {\n      allClasses = [];\n      svgStyles.set(cssText, allClasses);\n    }\n    allClasses.push(`.${klasses[0]}${pseudoClass}`);\n  }\n  pseudoClasses.forEach(copyBy);\n  if (copyScrollbar)\n    scrollbarPseudoClasses.forEach(copyBy);\n}\n\nconst excludeParentNodes = /* @__PURE__ */ new Set([\n  \"symbol\"\n  // test/fixtures/svg.symbol.html\n]);\nasync function appendChildNode(node, cloned, child, context, addWordToFontFamilies) {\n  if (isElementNode(child) && (isStyleElement(child) || isScriptElement(child)))\n    return;\n  if (context.filter && !context.filter(child))\n    return;\n  if (excludeParentNodes.has(cloned.nodeName) || excludeParentNodes.has(child.nodeName)) {\n    context.currentParentNodeStyle = void 0;\n  } else {\n    context.currentParentNodeStyle = context.currentNodeStyle;\n  }\n  const childCloned = await cloneNode(child, context, false, addWordToFontFamilies);\n  if (context.isEnable(\"restoreScrollPosition\")) {\n    restoreScrollPosition(node, childCloned);\n  }\n  cloned.appendChild(childCloned);\n}\nasync function cloneChildNodes(node, cloned, context, addWordToFontFamilies) {\n  let firstChild = node.firstChild;\n  if (isElementNode(node)) {\n    if (node.shadowRoot) {\n      firstChild = node.shadowRoot?.firstChild;\n      context.shadowRoots.push(node.shadowRoot);\n    }\n  }\n  for (let child = firstChild; child; child = child.nextSibling) {\n    if (isCommentNode(child))\n      continue;\n    if (isElementNode(child) && isSlotElement(child) && typeof child.assignedNodes === \"function\") {\n      const nodes = child.assignedNodes();\n      for (let i = 0; i < nodes.length; i++) {\n        await appendChildNode(node, cloned, nodes[i], context, addWordToFontFamilies);\n      }\n    } else {\n      await appendChildNode(node, cloned, child, context, addWordToFontFamilies);\n    }\n  }\n}\nfunction restoreScrollPosition(node, chlidCloned) {\n  if (!isHTMLElementNode(node) || !isHTMLElementNode(chlidCloned))\n    return;\n  const { scrollTop, scrollLeft } = node;\n  if (!scrollTop && !scrollLeft) {\n    return;\n  }\n  const { transform } = chlidCloned.style;\n  const matrix = new DOMMatrix(transform);\n  const { a, b, c, d } = matrix;\n  matrix.a = 1;\n  matrix.b = 0;\n  matrix.c = 0;\n  matrix.d = 1;\n  matrix.translateSelf(-scrollLeft, -scrollTop);\n  matrix.a = a;\n  matrix.b = b;\n  matrix.c = c;\n  matrix.d = d;\n  chlidCloned.style.transform = matrix.toString();\n}\nfunction applyCssStyleWithOptions(cloned, context) {\n  const { backgroundColor, width, height, style: styles } = context;\n  const clonedStyle = cloned.style;\n  if (backgroundColor)\n    clonedStyle.setProperty(\"background-color\", backgroundColor, \"important\");\n  if (width)\n    clonedStyle.setProperty(\"width\", `${width}px`, \"important\");\n  if (height)\n    clonedStyle.setProperty(\"height\", `${height}px`, \"important\");\n  if (styles) {\n    for (const name in styles) clonedStyle[name] = styles[name];\n  }\n}\nconst NORMAL_ATTRIBUTE_RE = /^[\\w-:]+$/;\nasync function cloneNode(node, context, isRoot = false, addWordToFontFamilies) {\n  const { ownerDocument, ownerWindow, fontFamilies, onCloneEachNode } = context;\n  if (ownerDocument && isTextNode(node)) {\n    if (addWordToFontFamilies && /\\S/.test(node.data)) {\n      addWordToFontFamilies(node.data);\n    }\n    return ownerDocument.createTextNode(node.data);\n  }\n  if (ownerDocument && ownerWindow && isElementNode(node) && (isHTMLElementNode(node) || isSVGElementNode(node))) {\n    const cloned2 = await cloneElement(node, context);\n    if (context.isEnable(\"removeAbnormalAttributes\")) {\n      const names = cloned2.getAttributeNames();\n      for (let len = names.length, i = 0; i < len; i++) {\n        const name = names[i];\n        if (!NORMAL_ATTRIBUTE_RE.test(name)) {\n          cloned2.removeAttribute(name);\n        }\n      }\n    }\n    const style = context.currentNodeStyle = copyCssStyles(node, cloned2, isRoot, context);\n    if (isRoot)\n      applyCssStyleWithOptions(cloned2, context);\n    let copyScrollbar = false;\n    if (context.isEnable(\"copyScrollbar\")) {\n      const overflow = [\n        style.get(\"overflow-x\")?.[0],\n        style.get(\"overflow-y\")?.[0]\n      ];\n      copyScrollbar = overflow.includes(\"scroll\") || (overflow.includes(\"auto\") || overflow.includes(\"overlay\")) && (node.scrollHeight > node.clientHeight || node.scrollWidth > node.clientWidth);\n    }\n    const textTransform = style.get(\"text-transform\")?.[0];\n    const families = splitFontFamily(style.get(\"font-family\")?.[0]);\n    const addWordToFontFamilies2 = families ? (word) => {\n      if (textTransform === \"uppercase\") {\n        word = word.toUpperCase();\n      } else if (textTransform === \"lowercase\") {\n        word = word.toLowerCase();\n      } else if (textTransform === \"capitalize\") {\n        word = word[0].toUpperCase() + word.substring(1);\n      }\n      families.forEach((family) => {\n        let fontFamily = fontFamilies.get(family);\n        if (!fontFamily) {\n          fontFamilies.set(family, fontFamily = /* @__PURE__ */ new Set());\n        }\n        word.split(\"\").forEach((text) => fontFamily.add(text));\n      });\n    } : void 0;\n    copyPseudoClass(\n      node,\n      cloned2,\n      copyScrollbar,\n      context,\n      addWordToFontFamilies2\n    );\n    copyInputValue(node, cloned2);\n    if (!isVideoElement(node)) {\n      await cloneChildNodes(\n        node,\n        cloned2,\n        context,\n        addWordToFontFamilies2\n      );\n    }\n    await onCloneEachNode?.(cloned2);\n    return cloned2;\n  }\n  const cloned = node.cloneNode(false);\n  await cloneChildNodes(node, cloned, context);\n  await onCloneEachNode?.(cloned);\n  return cloned;\n}\n\nfunction destroyContext(context) {\n  context.ownerDocument = void 0;\n  context.ownerWindow = void 0;\n  context.svgStyleElement = void 0;\n  context.svgDefsElement = void 0;\n  context.svgStyles.clear();\n  context.defaultComputedStyles.clear();\n  if (context.sandbox) {\n    try {\n      context.sandbox.remove();\n    } catch (err) {\n      context.log.warn(\"Failed to destroyContext\", err);\n    }\n    context.sandbox = void 0;\n  }\n  context.workers = [];\n  context.fontFamilies.clear();\n  context.fontCssTexts.clear();\n  context.requests.clear();\n  context.tasks = [];\n  context.shadowRoots = [];\n}\n\nfunction baseFetch(options) {\n  const { url, timeout, responseType, ...requestInit } = options;\n  const controller = new AbortController();\n  const timer = timeout ? setTimeout(() => controller.abort(), timeout) : void 0;\n  return fetch(url, { signal: controller.signal, ...requestInit }).then((response) => {\n    if (!response.ok) {\n      throw new Error(\"Failed fetch, not 2xx response\", { cause: response });\n    }\n    switch (responseType) {\n      case \"arrayBuffer\":\n        return response.arrayBuffer();\n      case \"dataUrl\":\n        return response.blob().then(blobToDataUrl);\n      case \"text\":\n      default:\n        return response.text();\n    }\n  }).finally(() => clearTimeout(timer));\n}\nfunction contextFetch(context, options) {\n  const { url: rawUrl, requestType = \"text\", responseType = \"text\", imageDom } = options;\n  let url = rawUrl;\n  const {\n    timeout,\n    acceptOfImage,\n    requests,\n    fetchFn,\n    fetch: {\n      requestInit,\n      bypassingCache,\n      placeholderImage\n    },\n    font,\n    workers,\n    fontFamilies\n  } = context;\n  if (requestType === \"image\" && (IN_SAFARI || IN_FIREFOX)) {\n    context.drawImageCount++;\n  }\n  let request = requests.get(rawUrl);\n  if (!request) {\n    if (bypassingCache) {\n      if (bypassingCache instanceof RegExp && bypassingCache.test(url)) {\n        url += (/\\?/.test(url) ? \"&\" : \"?\") + (/* @__PURE__ */ new Date()).getTime();\n      }\n    }\n    const canFontMinify = requestType.startsWith(\"font\") && font && font.minify;\n    const fontTexts = /* @__PURE__ */ new Set();\n    if (canFontMinify) {\n      const families = requestType.split(\";\")[1].split(\",\");\n      families.forEach((family) => {\n        if (!fontFamilies.has(family))\n          return;\n        fontFamilies.get(family).forEach((text) => fontTexts.add(text));\n      });\n    }\n    const needFontMinify = canFontMinify && fontTexts.size;\n    const baseFetchOptions = {\n      url,\n      timeout,\n      responseType: needFontMinify ? \"arrayBuffer\" : responseType,\n      headers: requestType === \"image\" ? { accept: acceptOfImage } : void 0,\n      ...requestInit\n    };\n    request = {\n      type: requestType,\n      resolve: void 0,\n      reject: void 0,\n      response: null\n    };\n    request.response = (async () => {\n      if (fetchFn && requestType === \"image\") {\n        const result = await fetchFn(rawUrl);\n        if (result)\n          return result;\n      }\n      if (!IN_SAFARI && rawUrl.startsWith(\"http\") && workers.length) {\n        return new Promise((resolve, reject) => {\n          const worker = workers[requests.size & workers.length - 1];\n          worker.postMessage({ rawUrl, ...baseFetchOptions });\n          request.resolve = resolve;\n          request.reject = reject;\n        });\n      }\n      return baseFetch(baseFetchOptions);\n    })().catch((error) => {\n      requests.delete(rawUrl);\n      if (requestType === \"image\" && placeholderImage) {\n        context.log.warn(\"Failed to fetch image base64, trying to use placeholder image\", url);\n        return typeof placeholderImage === \"string\" ? placeholderImage : placeholderImage(imageDom);\n      }\n      throw error;\n    });\n    requests.set(rawUrl, request);\n  }\n  return request.response;\n}\n\nasync function replaceCssUrlToDataUrl(cssText, baseUrl, context, isImage) {\n  if (!hasCssUrl(cssText))\n    return cssText;\n  for (const [rawUrl, url] of parseCssUrls(cssText, baseUrl)) {\n    try {\n      const dataUrl = await contextFetch(\n        context,\n        {\n          url,\n          requestType: isImage ? \"image\" : \"text\",\n          responseType: \"dataUrl\"\n        }\n      );\n      cssText = cssText.replace(toRE(rawUrl), `$1${dataUrl}$3`);\n    } catch (error) {\n      context.log.warn(\"Failed to fetch css data url\", rawUrl, error);\n    }\n  }\n  return cssText;\n}\nfunction hasCssUrl(cssText) {\n  return /url\\((['\"]?)([^'\"]+?)\\1\\)/.test(cssText);\n}\nconst URL_RE = /url\\((['\"]?)([^'\"]+?)\\1\\)/g;\nfunction parseCssUrls(cssText, baseUrl) {\n  const result = [];\n  cssText.replace(URL_RE, (raw, quotation, url) => {\n    result.push([url, resolveUrl(url, baseUrl)]);\n    return raw;\n  });\n  return result.filter(([url]) => !isDataUrl(url));\n}\nfunction toRE(url) {\n  const escaped = url.replace(/([.*+?^${}()|\\[\\]\\/\\\\])/g, \"\\\\$1\");\n  return new RegExp(`(url\\\\(['\"]?)(${escaped})(['\"]?\\\\))`, \"g\");\n}\n\nconst properties = [\n  \"background-image\",\n  \"border-image-source\",\n  \"-webkit-border-image\",\n  \"-webkit-mask-image\",\n  \"list-style-image\"\n];\nfunction embedCssStyleImage(style, context) {\n  return properties.map((property) => {\n    const value = style.getPropertyValue(property);\n    if (!value || value === \"none\") {\n      return null;\n    }\n    if (IN_SAFARI || IN_FIREFOX) {\n      context.drawImageCount++;\n    }\n    return replaceCssUrlToDataUrl(value, null, context, true).then((newValue) => {\n      if (!newValue || value === newValue)\n        return;\n      style.setProperty(\n        property,\n        newValue,\n        style.getPropertyPriority(property)\n      );\n    });\n  }).filter(Boolean);\n}\n\nfunction embedImageElement(cloned, context) {\n  if (isImageElement(cloned)) {\n    const originalSrc = cloned.currentSrc || cloned.src;\n    if (!isDataUrl(originalSrc)) {\n      return [\n        contextFetch(context, {\n          url: originalSrc,\n          imageDom: cloned,\n          requestType: \"image\",\n          responseType: \"dataUrl\"\n        }).then((url) => {\n          if (!url)\n            return;\n          cloned.srcset = \"\";\n          cloned.dataset.originalSrc = originalSrc;\n          cloned.src = url || \"\";\n        })\n      ];\n    }\n    if (IN_SAFARI || IN_FIREFOX) {\n      context.drawImageCount++;\n    }\n  } else if (isSVGElementNode(cloned) && !isDataUrl(cloned.href.baseVal)) {\n    const originalSrc = cloned.href.baseVal;\n    return [\n      contextFetch(context, {\n        url: originalSrc,\n        imageDom: cloned,\n        requestType: \"image\",\n        responseType: \"dataUrl\"\n      }).then((url) => {\n        if (!url)\n          return;\n        cloned.dataset.originalSrc = originalSrc;\n        cloned.href.baseVal = url || \"\";\n      })\n    ];\n  }\n  return [];\n}\n\nfunction embedSvgUse(cloned, context) {\n  const { ownerDocument, svgDefsElement } = context;\n  const href = cloned.getAttribute(\"href\") ?? cloned.getAttribute(\"xlink:href\");\n  if (!href)\n    return [];\n  const [svgUrl, id] = href.split(\"#\");\n  if (id) {\n    const query = `#${id}`;\n    const definition = context.shadowRoots.reduce(\n      (res, root) => {\n        return res ?? root.querySelector(`svg ${query}`);\n      },\n      ownerDocument?.querySelector(`svg ${query}`)\n    );\n    if (svgUrl) {\n      cloned.setAttribute(\"href\", query);\n    }\n    if (svgDefsElement?.querySelector(query))\n      return [];\n    if (definition) {\n      svgDefsElement?.appendChild(definition.cloneNode(true));\n      return [];\n    } else if (svgUrl) {\n      return [\n        contextFetch(context, {\n          url: svgUrl,\n          responseType: \"text\"\n        }).then((svgData) => {\n          svgDefsElement?.insertAdjacentHTML(\"beforeend\", svgData);\n        })\n      ];\n    }\n  }\n  return [];\n}\n\nfunction embedNode(cloned, context) {\n  const { tasks } = context;\n  if (isElementNode(cloned)) {\n    if (isImageElement(cloned) || isSVGImageElementNode(cloned)) {\n      tasks.push(...embedImageElement(cloned, context));\n    }\n    if (isSVGUseElementNode(cloned)) {\n      tasks.push(...embedSvgUse(cloned, context));\n    }\n  }\n  if (isHTMLElementNode(cloned)) {\n    tasks.push(...embedCssStyleImage(cloned.style, context));\n  }\n  cloned.childNodes.forEach((child) => {\n    embedNode(child, context);\n  });\n}\n\nasync function embedWebFont(clone, context) {\n  const {\n    ownerDocument,\n    svgStyleElement,\n    fontFamilies,\n    fontCssTexts,\n    tasks,\n    font\n  } = context;\n  if (!ownerDocument || !svgStyleElement || !fontFamilies.size) {\n    return;\n  }\n  if (font && font.cssText) {\n    const cssText = filterPreferredFormat(font.cssText, context);\n    svgStyleElement.appendChild(ownerDocument.createTextNode(`${cssText}\n`));\n  } else {\n    const styleSheets = Array.from(ownerDocument.styleSheets).filter((styleSheet) => {\n      try {\n        return \"cssRules\" in styleSheet && Boolean(styleSheet.cssRules.length);\n      } catch (error) {\n        context.log.warn(`Error while reading CSS rules from ${styleSheet.href}`, error);\n        return false;\n      }\n    });\n    await Promise.all(\n      styleSheets.flatMap((styleSheet) => {\n        return Array.from(styleSheet.cssRules).map(async (cssRule, index) => {\n          if (isCSSImportRule(cssRule)) {\n            let importIndex = index + 1;\n            const baseUrl = cssRule.href;\n            let cssText = \"\";\n            try {\n              cssText = await contextFetch(context, {\n                url: baseUrl,\n                requestType: \"text\",\n                responseType: \"text\"\n              });\n            } catch (error) {\n              context.log.warn(`Error fetch remote css import from ${baseUrl}`, error);\n            }\n            const replacedCssText = cssText.replace(\n              URL_RE,\n              (raw, quotation, url) => raw.replace(url, resolveUrl(url, baseUrl))\n            );\n            for (const rule of parseCss(replacedCssText)) {\n              try {\n                styleSheet.insertRule(\n                  rule,\n                  rule.startsWith(\"@import\") ? importIndex += 1 : styleSheet.cssRules.length\n                );\n              } catch (error) {\n                context.log.warn(\"Error inserting rule from remote css import\", { rule, error });\n              }\n            }\n          }\n        });\n      })\n    );\n    const cssRules = styleSheets.flatMap((styleSheet) => Array.from(styleSheet.cssRules));\n    cssRules.filter((cssRule) => isCssFontFaceRule(cssRule) && hasCssUrl(cssRule.style.getPropertyValue(\"src\")) && splitFontFamily(cssRule.style.getPropertyValue(\"font-family\"))?.some((val) => fontFamilies.has(val))).forEach((value) => {\n      const rule = value;\n      const cssText = fontCssTexts.get(rule.cssText);\n      if (cssText) {\n        svgStyleElement.appendChild(ownerDocument.createTextNode(`${cssText}\n`));\n      } else {\n        tasks.push(\n          replaceCssUrlToDataUrl(\n            rule.cssText,\n            rule.parentStyleSheet ? rule.parentStyleSheet.href : null,\n            context\n          ).then((cssText2) => {\n            cssText2 = filterPreferredFormat(cssText2, context);\n            fontCssTexts.set(rule.cssText, cssText2);\n            svgStyleElement.appendChild(ownerDocument.createTextNode(`${cssText2}\n`));\n          })\n        );\n      }\n    });\n  }\n}\nconst COMMENTS_RE = /(\\/\\*[\\s\\S]*?\\*\\/)/g;\nconst KEYFRAMES_RE = /((@.*?keyframes [\\s\\S]*?){([\\s\\S]*?}\\s*?)})/gi;\nfunction parseCss(source) {\n  if (source == null)\n    return [];\n  const result = [];\n  let cssText = source.replace(COMMENTS_RE, \"\");\n  while (true) {\n    const matches = KEYFRAMES_RE.exec(cssText);\n    if (!matches)\n      break;\n    result.push(matches[0]);\n  }\n  cssText = cssText.replace(KEYFRAMES_RE, \"\");\n  const IMPORT_RE = /@import[\\s\\S]*?url\\([^)]*\\)[\\s\\S]*?;/gi;\n  const UNIFIED_RE = new RegExp(\n    // eslint-disable-next-line\n    \"((\\\\s*?(?:\\\\/\\\\*[\\\\s\\\\S]*?\\\\*\\\\/)?\\\\s*?@media[\\\\s\\\\S]*?){([\\\\s\\\\S]*?)}\\\\s*?})|(([\\\\s\\\\S]*?){([\\\\s\\\\S]*?)})\",\n    \"gi\"\n  );\n  while (true) {\n    let matches = IMPORT_RE.exec(cssText);\n    if (!matches) {\n      matches = UNIFIED_RE.exec(cssText);\n      if (!matches) {\n        break;\n      } else {\n        IMPORT_RE.lastIndex = UNIFIED_RE.lastIndex;\n      }\n    } else {\n      UNIFIED_RE.lastIndex = IMPORT_RE.lastIndex;\n    }\n    result.push(matches[0]);\n  }\n  return result;\n}\nconst URL_WITH_FORMAT_RE = /url\\([^)]+\\)\\s*format\\(([\"']?)([^\"']+)\\1\\)/g;\nconst FONT_SRC_RE = /src:\\s*(?:url\\([^)]+\\)\\s*format\\([^)]+\\)[,;]\\s*)+/g;\nfunction filterPreferredFormat(str, context) {\n  const { font } = context;\n  const preferredFormat = font ? font?.preferredFormat : void 0;\n  return preferredFormat ? str.replace(FONT_SRC_RE, (match) => {\n    while (true) {\n      const [src, , format] = URL_WITH_FORMAT_RE.exec(match) || [];\n      if (!format)\n        return \"\";\n      if (format === preferredFormat)\n        return `src: ${src};`;\n    }\n  }) : str;\n}\n\nasync function domToForeignObjectSvg(node, options) {\n  const context = await orCreateContext(node, options);\n  if (isElementNode(context.node) && isSVGElementNode(context.node))\n    return context.node;\n  const {\n    ownerDocument,\n    log,\n    tasks,\n    svgStyleElement,\n    svgDefsElement,\n    svgStyles,\n    font,\n    progress,\n    autoDestruct,\n    onCloneNode,\n    onEmbedNode,\n    onCreateForeignObjectSvg\n  } = context;\n  log.time(\"clone node\");\n  const clone = await cloneNode(context.node, context, true);\n  if (svgStyleElement && ownerDocument) {\n    let allCssText = \"\";\n    svgStyles.forEach((klasses, cssText) => {\n      allCssText += `${klasses.join(\",\\n\")} {\n  ${cssText}\n}\n`;\n    });\n    svgStyleElement.appendChild(ownerDocument.createTextNode(allCssText));\n  }\n  log.timeEnd(\"clone node\");\n  await onCloneNode?.(clone);\n  if (font !== false && isElementNode(clone)) {\n    log.time(\"embed web font\");\n    await embedWebFont(clone, context);\n    log.timeEnd(\"embed web font\");\n  }\n  log.time(\"embed node\");\n  embedNode(clone, context);\n  const count = tasks.length;\n  let current = 0;\n  const runTask = async () => {\n    while (true) {\n      const task = tasks.pop();\n      if (!task)\n        break;\n      try {\n        await task;\n      } catch (error) {\n        context.log.warn(\"Failed to run task\", error);\n      }\n      progress?.(++current, count);\n    }\n  };\n  progress?.(current, count);\n  await Promise.all([...Array.from({ length: 4 })].map(runTask));\n  log.timeEnd(\"embed node\");\n  await onEmbedNode?.(clone);\n  const svg = createForeignObjectSvg(clone, context);\n  svgDefsElement && svg.insertBefore(svgDefsElement, svg.children[0]);\n  svgStyleElement && svg.insertBefore(svgStyleElement, svg.children[0]);\n  autoDestruct && destroyContext(context);\n  await onCreateForeignObjectSvg?.(svg);\n  return svg;\n}\nfunction createForeignObjectSvg(clone, context) {\n  const { width, height } = context;\n  const svg = createSvg(width, height, clone.ownerDocument);\n  const foreignObject = svg.ownerDocument.createElementNS(svg.namespaceURI, \"foreignObject\");\n  foreignObject.setAttributeNS(null, \"x\", \"0%\");\n  foreignObject.setAttributeNS(null, \"y\", \"0%\");\n  foreignObject.setAttributeNS(null, \"width\", \"100%\");\n  foreignObject.setAttributeNS(null, \"height\", \"100%\");\n  foreignObject.append(clone);\n  svg.appendChild(foreignObject);\n  return svg;\n}\n\nasync function domToCanvas(node, options) {\n  const context = await orCreateContext(node, options);\n  const svg = await domToForeignObjectSvg(context);\n  const dataUrl = svgToDataUrl(svg, context.isEnable(\"removeControlCharacter\"));\n  if (!context.autoDestruct) {\n    context.svgStyleElement = createStyleElement(context.ownerDocument);\n    context.svgDefsElement = context.ownerDocument?.createElementNS(XMLNS, \"defs\");\n    context.svgStyles.clear();\n  }\n  const image = createImage(dataUrl, svg.ownerDocument);\n  return await imageToCanvas(image, context);\n}\n\nasync function domToBlob(node, options) {\n  const context = await orCreateContext(node, options);\n  const { log, type, quality, dpi } = context;\n  const canvas = await domToCanvas(context);\n  log.time(\"canvas to blob\");\n  const blob = await canvasToBlob(canvas, type, quality);\n  if ([\"image/png\", \"image/jpeg\"].includes(type) && dpi) {\n    const arrayBuffer = await blobToArrayBuffer(blob.slice(0, 33));\n    let uint8Array = new Uint8Array(arrayBuffer);\n    if (type === \"image/png\") {\n      uint8Array = changePngDpi(uint8Array, dpi);\n    } else if (type === \"image/jpeg\") {\n      uint8Array = changeJpegDpi(uint8Array, dpi);\n    }\n    log.timeEnd(\"canvas to blob\");\n    return new Blob([uint8Array, blob.slice(33)], { type });\n  }\n  log.timeEnd(\"canvas to blob\");\n  return blob;\n}\n\nasync function domToDataUrl(node, options) {\n  const context = await orCreateContext(node, options);\n  const { log, quality, type, dpi } = context;\n  const canvas = await domToCanvas(context);\n  log.time(\"canvas to data url\");\n  let dataUrl = canvas.toDataURL(type, quality);\n  if ([\"image/png\", \"image/jpeg\"].includes(type) && dpi && SUPPORT_ATOB && SUPPORT_BTOA) {\n    const [format, body] = dataUrl.split(\",\");\n    let headerLength = 0;\n    let overwritepHYs = false;\n    if (type === \"image/png\") {\n      const b64Index = detectPhysChunkFromDataUrl(body);\n      if (b64Index >= 0) {\n        headerLength = Math.ceil((b64Index + 28) / 3) * 4;\n        overwritepHYs = true;\n      } else {\n        headerLength = 33 / 3 * 4;\n      }\n    } else if (type === \"image/jpeg\") {\n      headerLength = 18 / 3 * 4;\n    }\n    const stringHeader = body.substring(0, headerLength);\n    const restOfData = body.substring(headerLength);\n    const headerBytes = window.atob(stringHeader);\n    const uint8Array = new Uint8Array(headerBytes.length);\n    for (let i = 0; i < uint8Array.length; i++) {\n      uint8Array[i] = headerBytes.charCodeAt(i);\n    }\n    const finalArray = type === \"image/png\" ? changePngDpi(uint8Array, dpi, overwritepHYs) : changeJpegDpi(uint8Array, dpi);\n    const base64Header = window.btoa(String.fromCharCode(...finalArray));\n    dataUrl = [format, \",\", base64Header, restOfData].join(\"\");\n  }\n  log.timeEnd(\"canvas to data url\");\n  return dataUrl;\n}\n\nasync function domToSvg(node, options) {\n  const context = await orCreateContext(node, options);\n  const { width, height, ownerDocument } = context;\n  const dataUrl = await domToDataUrl(context);\n  const svg = createSvg(width, height, ownerDocument);\n  const svgImage = svg.ownerDocument.createElementNS(svg.namespaceURI, \"image\");\n  svgImage.setAttributeNS(null, \"href\", dataUrl);\n  svgImage.setAttributeNS(null, \"height\", \"100%\");\n  svgImage.setAttributeNS(null, \"width\", \"100%\");\n  svg.appendChild(svgImage);\n  return svgToDataUrl(svg, context.isEnable(\"removeControlCharacter\"));\n}\n\nasync function domToImage(node, options) {\n  const context = await orCreateContext(node, options);\n  const { ownerDocument, width, height, scale, type } = context;\n  const url = type === \"image/svg+xml\" ? await domToSvg(context) : await domToDataUrl(context);\n  const image = createImage(url, ownerDocument);\n  image.width = Math.floor(width * scale);\n  image.height = Math.floor(height * scale);\n  image.style.width = `${width}px`;\n  image.style.height = `${height}px`;\n  return image;\n}\n\nasync function domToJpeg(node, options) {\n  return domToDataUrl(\n    await orCreateContext(node, { ...options, type: \"image/jpeg\" })\n  );\n}\n\nasync function domToPixel(node, options) {\n  const context = await orCreateContext(node, options);\n  const canvas = await domToCanvas(context);\n  return canvas.getContext(\"2d\").getImageData(0, 0, canvas.width, canvas.height).data;\n}\n\nasync function domToPng(node, options) {\n  return domToDataUrl(\n    await orCreateContext(node, { ...options, type: \"image/png\" })\n  );\n}\n\nasync function domToWebp(node, options) {\n  return domToDataUrl(\n    await orCreateContext(node, { ...options, type: \"image/webp\" })\n  );\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9tb2Rlcm4tc2NyZWVuc2hvdC9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHVCQUF1QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsUUFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLE9BQU8sRUFBRSxPQUFPO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGdCQUFnQiwwQkFBMEI7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBLDhCQUE4QixNQUFNO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxLQUFLO0FBQ3hFO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHVEQUF1RDtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsWUFBWTtBQUN0RSxnREFBZ0QsWUFBWTtBQUM1RCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsWUFBWTtBQUMxRCxnREFBZ0QsWUFBWTtBQUM1RDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsNENBQTRDO0FBQzFFO0FBQ0E7QUFDQSxlQUFlLFNBQVMsRUFBRSxRQUFRO0FBQ2xDO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU8sSUFBSSxJQUFJO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxRQUFRLEVBQUUsTUFBTTtBQUM5RDtBQUNBLG9EQUFvRCxRQUFRLEVBQUUsTUFBTTtBQUNwRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdEQUF3RCxnQ0FBZ0M7QUFDeEY7QUFDQTtBQUNBLFVBQVUseUNBQXlDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQSxZQUFZO0FBQ1osMEZBQTBGLElBQUk7QUFDOUY7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE1BQU07QUFDeEIsd0ZBQXdGLElBQUk7QUFDNUY7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLG9EQUFvRDtBQUNsRjtBQUNBLFVBQVUsZ0JBQWdCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsZ0JBQWdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsMENBQTBDLG1DQUFtQztBQUM3RSxVQUFVLG9CQUFvQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGdFQUFnRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsTUFBTTtBQUNoQywyQkFBMkIsT0FBTztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsMERBQTBEO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsWUFBWTtBQUMvRCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxPQUFPO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsd0JBQXdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxLQUFLLEdBQUcsTUFBTTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsU0FBUztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSix3Q0FBd0MsU0FBUztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxTQUFTO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLDhEQUE4RDtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsU0FBUztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsNERBQTREO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVEsRUFBRTtBQUM3QjtBQUNBO0FBQ0EseUJBQXlCLEtBQUssSUFBSSxNQUFNLEVBQUUsK0JBQStCO0FBQ3pFLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsV0FBVyxFQUFFLFlBQVk7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE9BQU87QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHdCQUF3QjtBQUNsQztBQUNBO0FBQ0E7QUFDQSxVQUFVLFlBQVk7QUFDdEI7QUFDQSxVQUFVLGFBQWE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxnREFBZ0Q7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsTUFBTTtBQUM5QztBQUNBLHlDQUF5QyxPQUFPO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsNERBQTREO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFNBQVM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLDZDQUE2QztBQUN2RDtBQUNBO0FBQ0Esc0JBQXNCLDJDQUEyQztBQUNqRTtBQUNBLDBEQUEwRCxpQkFBaUI7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLFVBQVUscUVBQXFFO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsd0JBQXdCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsNkJBQTZCO0FBQzVEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsUUFBUTtBQUMzRCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekMscUNBQXFDLFFBQVE7QUFDN0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLGdDQUFnQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLEdBQUc7QUFDekI7QUFDQTtBQUNBLGdEQUFnRCxNQUFNO0FBQ3RELE9BQU87QUFDUCwwQ0FBMEMsTUFBTTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVUsUUFBUTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLCtEQUErRCxnQkFBZ0I7QUFDL0U7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsY0FBYztBQUNkLHFFQUFxRSxRQUFRO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsa0ZBQWtGLGFBQWE7QUFDL0Y7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RTtBQUN4RTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxVQUFVLE1BQU07QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQSw4REFBOEQsYUFBYSxNQUFNLGdCQUFnQixhQUFhO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBLFVBQVUsT0FBTztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixLQUFLO0FBQzVCO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixJQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxXQUFXO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxnQkFBZ0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLDBCQUEwQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxNQUFNO0FBQzFEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLDBCQUEwQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSwrQkFBK0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLDRDQUE0QztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixNQUFNO0FBQy9CLDBCQUEwQixPQUFPO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQyxnQ0FBZ0M7QUFDbEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0MsK0JBQStCO0FBQ2pFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQyxnQ0FBZ0M7QUFDbEU7QUFDQTs7QUFFa00iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL21vZGVybi1zY3JlZW5zaG90L2Rpc3QvaW5kZXgubWpzP2RmZmYiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gY2hhbmdlSnBlZ0RwaSh1aW50OEFycmF5LCBkcGkpIHtcbiAgdWludDhBcnJheVsxM10gPSAxO1xuICB1aW50OEFycmF5WzE0XSA9IGRwaSA+PiA4O1xuICB1aW50OEFycmF5WzE1XSA9IGRwaSAmIDI1NTtcbiAgdWludDhBcnJheVsxNl0gPSBkcGkgPj4gODtcbiAgdWludDhBcnJheVsxN10gPSBkcGkgJiAyNTU7XG4gIHJldHVybiB1aW50OEFycmF5O1xufVxuXG5jb25zdCBfUCA9IFwicFwiLmNoYXJDb2RlQXQoMCk7XG5jb25zdCBfSCA9IFwiSFwiLmNoYXJDb2RlQXQoMCk7XG5jb25zdCBfWSA9IFwiWVwiLmNoYXJDb2RlQXQoMCk7XG5jb25zdCBfUyA9IFwic1wiLmNoYXJDb2RlQXQoMCk7XG5sZXQgcG5nRGF0YVRhYmxlO1xuZnVuY3Rpb24gY3JlYXRlUG5nRGF0YVRhYmxlKCkge1xuICBjb25zdCBjcmNUYWJsZSA9IG5ldyBJbnQzMkFycmF5KDI1Nik7XG4gIGZvciAobGV0IG4gPSAwOyBuIDwgMjU2OyBuKyspIHtcbiAgICBsZXQgYyA9IG47XG4gICAgZm9yIChsZXQgayA9IDA7IGsgPCA4OyBrKyspIHtcbiAgICAgIGMgPSBjICYgMSA/IDM5ODgyOTIzODQgXiBjID4+PiAxIDogYyA+Pj4gMTtcbiAgICB9XG4gICAgY3JjVGFibGVbbl0gPSBjO1xuICB9XG4gIHJldHVybiBjcmNUYWJsZTtcbn1cbmZ1bmN0aW9uIGNhbGNDcmModWludDhBcnJheSkge1xuICBsZXQgYyA9IC0xO1xuICBpZiAoIXBuZ0RhdGFUYWJsZSlcbiAgICBwbmdEYXRhVGFibGUgPSBjcmVhdGVQbmdEYXRhVGFibGUoKTtcbiAgZm9yIChsZXQgbiA9IDA7IG4gPCB1aW50OEFycmF5Lmxlbmd0aDsgbisrKSB7XG4gICAgYyA9IHBuZ0RhdGFUYWJsZVsoYyBeIHVpbnQ4QXJyYXlbbl0pICYgMjU1XSBeIGMgPj4+IDg7XG4gIH1cbiAgcmV0dXJuIGMgXiAtMTtcbn1cbmZ1bmN0aW9uIHNlYXJjaFN0YXJ0T2ZQaHlzKHVpbnQ4QXJyYXkpIHtcbiAgY29uc3QgbGVuZ3RoID0gdWludDhBcnJheS5sZW5ndGggLSAxO1xuICBmb3IgKGxldCBpID0gbGVuZ3RoOyBpID49IDQ7IGktLSkge1xuICAgIGlmICh1aW50OEFycmF5W2kgLSA0XSA9PT0gOSAmJiB1aW50OEFycmF5W2kgLSAzXSA9PT0gX1AgJiYgdWludDhBcnJheVtpIC0gMl0gPT09IF9IICYmIHVpbnQ4QXJyYXlbaSAtIDFdID09PSBfWSAmJiB1aW50OEFycmF5W2ldID09PSBfUykge1xuICAgICAgcmV0dXJuIGkgLSAzO1xuICAgIH1cbiAgfVxuICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIGNoYW5nZVBuZ0RwaSh1aW50OEFycmF5LCBkcGksIG92ZXJ3cml0ZXBIWXMgPSBmYWxzZSkge1xuICBjb25zdCBwaHlzQ2h1bmsgPSBuZXcgVWludDhBcnJheSgxMyk7XG4gIGRwaSAqPSAzOS4zNzAxO1xuICBwaHlzQ2h1bmtbMF0gPSBfUDtcbiAgcGh5c0NodW5rWzFdID0gX0g7XG4gIHBoeXNDaHVua1syXSA9IF9ZO1xuICBwaHlzQ2h1bmtbM10gPSBfUztcbiAgcGh5c0NodW5rWzRdID0gZHBpID4+PiAyNDtcbiAgcGh5c0NodW5rWzVdID0gZHBpID4+PiAxNjtcbiAgcGh5c0NodW5rWzZdID0gZHBpID4+PiA4O1xuICBwaHlzQ2h1bmtbN10gPSBkcGkgJiAyNTU7XG4gIHBoeXNDaHVua1s4XSA9IHBoeXNDaHVua1s0XTtcbiAgcGh5c0NodW5rWzldID0gcGh5c0NodW5rWzVdO1xuICBwaHlzQ2h1bmtbMTBdID0gcGh5c0NodW5rWzZdO1xuICBwaHlzQ2h1bmtbMTFdID0gcGh5c0NodW5rWzddO1xuICBwaHlzQ2h1bmtbMTJdID0gMTtcbiAgY29uc3QgY3JjID0gY2FsY0NyYyhwaHlzQ2h1bmspO1xuICBjb25zdCBjcmNDaHVuayA9IG5ldyBVaW50OEFycmF5KDQpO1xuICBjcmNDaHVua1swXSA9IGNyYyA+Pj4gMjQ7XG4gIGNyY0NodW5rWzFdID0gY3JjID4+PiAxNjtcbiAgY3JjQ2h1bmtbMl0gPSBjcmMgPj4+IDg7XG4gIGNyY0NodW5rWzNdID0gY3JjICYgMjU1O1xuICBpZiAob3ZlcndyaXRlcEhZcykge1xuICAgIGNvbnN0IHN0YXJ0aW5nSW5kZXggPSBzZWFyY2hTdGFydE9mUGh5cyh1aW50OEFycmF5KTtcbiAgICB1aW50OEFycmF5LnNldChwaHlzQ2h1bmssIHN0YXJ0aW5nSW5kZXgpO1xuICAgIHVpbnQ4QXJyYXkuc2V0KGNyY0NodW5rLCBzdGFydGluZ0luZGV4ICsgMTMpO1xuICAgIHJldHVybiB1aW50OEFycmF5O1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGNodW5rTGVuZ3RoID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gICAgY2h1bmtMZW5ndGhbMF0gPSAwO1xuICAgIGNodW5rTGVuZ3RoWzFdID0gMDtcbiAgICBjaHVua0xlbmd0aFsyXSA9IDA7XG4gICAgY2h1bmtMZW5ndGhbM10gPSA5O1xuICAgIGNvbnN0IGZpbmFsSGVhZGVyID0gbmV3IFVpbnQ4QXJyYXkoNTQpO1xuICAgIGZpbmFsSGVhZGVyLnNldCh1aW50OEFycmF5LCAwKTtcbiAgICBmaW5hbEhlYWRlci5zZXQoY2h1bmtMZW5ndGgsIDMzKTtcbiAgICBmaW5hbEhlYWRlci5zZXQocGh5c0NodW5rLCAzNyk7XG4gICAgZmluYWxIZWFkZXIuc2V0KGNyY0NodW5rLCA1MCk7XG4gICAgcmV0dXJuIGZpbmFsSGVhZGVyO1xuICB9XG59XG5jb25zdCBiNjRQaHlzU2lnbmF0dXJlMSA9IFwiQUFsd1NGbHpcIjtcbmNvbnN0IGI2NFBoeXNTaWduYXR1cmUyID0gXCJBQUFKY0VoWlwiO1xuY29uc3QgYjY0UGh5c1NpZ25hdHVyZTMgPSBcIkFBQUFDWEJJXCI7XG5mdW5jdGlvbiBkZXRlY3RQaHlzQ2h1bmtGcm9tRGF0YVVybChkYXRhVXJsKSB7XG4gIGxldCBiNjRpbmRleCA9IGRhdGFVcmwuaW5kZXhPZihiNjRQaHlzU2lnbmF0dXJlMSk7XG4gIGlmIChiNjRpbmRleCA9PT0gLTEpIHtcbiAgICBiNjRpbmRleCA9IGRhdGFVcmwuaW5kZXhPZihiNjRQaHlzU2lnbmF0dXJlMik7XG4gIH1cbiAgaWYgKGI2NGluZGV4ID09PSAtMSkge1xuICAgIGI2NGluZGV4ID0gZGF0YVVybC5pbmRleE9mKGI2NFBoeXNTaWduYXR1cmUzKTtcbiAgfVxuICByZXR1cm4gYjY0aW5kZXg7XG59XG5cbmNvbnN0IFBSRUZJWCA9IFwiW21vZGVybi1zY3JlZW5zaG90XVwiO1xuY29uc3QgSU5fQlJPV1NFUiA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCI7XG5jb25zdCBTVVBQT1JUX1dFQl9XT1JLRVIgPSBJTl9CUk9XU0VSICYmIFwiV29ya2VyXCIgaW4gd2luZG93O1xuY29uc3QgU1VQUE9SVF9BVE9CID0gSU5fQlJPV1NFUiAmJiBcImF0b2JcIiBpbiB3aW5kb3c7XG5jb25zdCBTVVBQT1JUX0JUT0EgPSBJTl9CUk9XU0VSICYmIFwiYnRvYVwiIGluIHdpbmRvdztcbmNvbnN0IFVTRVJfQUdFTlQgPSBJTl9CUk9XU0VSID8gd2luZG93Lm5hdmlnYXRvcj8udXNlckFnZW50IDogXCJcIjtcbmNvbnN0IElOX0NIUk9NRSA9IFVTRVJfQUdFTlQuaW5jbHVkZXMoXCJDaHJvbWVcIik7XG5jb25zdCBJTl9TQUZBUkkgPSBVU0VSX0FHRU5ULmluY2x1ZGVzKFwiQXBwbGVXZWJLaXRcIikgJiYgIUlOX0NIUk9NRTtcbmNvbnN0IElOX0ZJUkVGT1ggPSBVU0VSX0FHRU5ULmluY2x1ZGVzKFwiRmlyZWZveFwiKTtcbmNvbnN0IGlzQ29udGV4dCA9ICh2YWx1ZSkgPT4gdmFsdWUgJiYgXCJfX0NPTlRFWFRfX1wiIGluIHZhbHVlO1xuY29uc3QgaXNDc3NGb250RmFjZVJ1bGUgPSAocnVsZSkgPT4gcnVsZS5jb25zdHJ1Y3Rvci5uYW1lID09PSBcIkNTU0ZvbnRGYWNlUnVsZVwiO1xuY29uc3QgaXNDU1NJbXBvcnRSdWxlID0gKHJ1bGUpID0+IHJ1bGUuY29uc3RydWN0b3IubmFtZSA9PT0gXCJDU1NJbXBvcnRSdWxlXCI7XG5jb25zdCBpc0VsZW1lbnROb2RlID0gKG5vZGUpID0+IG5vZGUubm9kZVR5cGUgPT09IDE7XG5jb25zdCBpc1NWR0VsZW1lbnROb2RlID0gKG5vZGUpID0+IHR5cGVvZiBub2RlLmNsYXNzTmFtZSA9PT0gXCJvYmplY3RcIjtcbmNvbnN0IGlzU1ZHSW1hZ2VFbGVtZW50Tm9kZSA9IChub2RlKSA9PiBub2RlLnRhZ05hbWUgPT09IFwiaW1hZ2VcIjtcbmNvbnN0IGlzU1ZHVXNlRWxlbWVudE5vZGUgPSAobm9kZSkgPT4gbm9kZS50YWdOYW1lID09PSBcInVzZVwiO1xuY29uc3QgaXNIVE1MRWxlbWVudE5vZGUgPSAobm9kZSkgPT4gaXNFbGVtZW50Tm9kZShub2RlKSAmJiB0eXBlb2Ygbm9kZS5zdHlsZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiAhaXNTVkdFbGVtZW50Tm9kZShub2RlKTtcbmNvbnN0IGlzQ29tbWVudE5vZGUgPSAobm9kZSkgPT4gbm9kZS5ub2RlVHlwZSA9PT0gODtcbmNvbnN0IGlzVGV4dE5vZGUgPSAobm9kZSkgPT4gbm9kZS5ub2RlVHlwZSA9PT0gMztcbmNvbnN0IGlzSW1hZ2VFbGVtZW50ID0gKG5vZGUpID0+IG5vZGUudGFnTmFtZSA9PT0gXCJJTUdcIjtcbmNvbnN0IGlzVmlkZW9FbGVtZW50ID0gKG5vZGUpID0+IG5vZGUudGFnTmFtZSA9PT0gXCJWSURFT1wiO1xuY29uc3QgaXNDYW52YXNFbGVtZW50ID0gKG5vZGUpID0+IG5vZGUudGFnTmFtZSA9PT0gXCJDQU5WQVNcIjtcbmNvbnN0IGlzVGV4dGFyZWFFbGVtZW50ID0gKG5vZGUpID0+IG5vZGUudGFnTmFtZSA9PT0gXCJURVhUQVJFQVwiO1xuY29uc3QgaXNJbnB1dEVsZW1lbnQgPSAobm9kZSkgPT4gbm9kZS50YWdOYW1lID09PSBcIklOUFVUXCI7XG5jb25zdCBpc1N0eWxlRWxlbWVudCA9IChub2RlKSA9PiBub2RlLnRhZ05hbWUgPT09IFwiU1RZTEVcIjtcbmNvbnN0IGlzU2NyaXB0RWxlbWVudCA9IChub2RlKSA9PiBub2RlLnRhZ05hbWUgPT09IFwiU0NSSVBUXCI7XG5jb25zdCBpc1NlbGVjdEVsZW1lbnQgPSAobm9kZSkgPT4gbm9kZS50YWdOYW1lID09PSBcIlNFTEVDVFwiO1xuY29uc3QgaXNTbG90RWxlbWVudCA9IChub2RlKSA9PiBub2RlLnRhZ05hbWUgPT09IFwiU0xPVFwiO1xuY29uc3QgaXNJRnJhbWVFbGVtZW50ID0gKG5vZGUpID0+IG5vZGUudGFnTmFtZSA9PT0gXCJJRlJBTUVcIjtcbmNvbnN0IGNvbnNvbGVXYXJuID0gKC4uLmFyZ3MpID0+IGNvbnNvbGUud2FybihQUkVGSVgsIC4uLmFyZ3MpO1xuZnVuY3Rpb24gc3VwcG9ydFdlYnAob3duZXJEb2N1bWVudCkge1xuICBjb25zdCBjYW52YXMgPSBvd25lckRvY3VtZW50Py5jcmVhdGVFbGVtZW50Py4oXCJjYW52YXNcIik7XG4gIGlmIChjYW52YXMpIHtcbiAgICBjYW52YXMuaGVpZ2h0ID0gY2FudmFzLndpZHRoID0gMTtcbiAgfVxuICByZXR1cm4gQm9vbGVhbihjYW52YXMpICYmIFwidG9EYXRhVVJMXCIgaW4gY2FudmFzICYmIEJvb2xlYW4oY2FudmFzLnRvRGF0YVVSTChcImltYWdlL3dlYnBcIikuaW5jbHVkZXMoXCJpbWFnZS93ZWJwXCIpKTtcbn1cbmNvbnN0IGlzRGF0YVVybCA9ICh1cmwpID0+IHVybC5zdGFydHNXaXRoKFwiZGF0YTpcIik7XG5mdW5jdGlvbiByZXNvbHZlVXJsKHVybCwgYmFzZVVybCkge1xuICBpZiAodXJsLm1hdGNoKC9eW2Etel0rOlxcL1xcLy9pKSlcbiAgICByZXR1cm4gdXJsO1xuICBpZiAoSU5fQlJPV1NFUiAmJiB1cmwubWF0Y2goL15cXC9cXC8vKSlcbiAgICByZXR1cm4gd2luZG93LmxvY2F0aW9uLnByb3RvY29sICsgdXJsO1xuICBpZiAodXJsLm1hdGNoKC9eW2Etel0rOi9pKSlcbiAgICByZXR1cm4gdXJsO1xuICBpZiAoIUlOX0JST1dTRVIpXG4gICAgcmV0dXJuIHVybDtcbiAgY29uc3QgZG9jID0gZ2V0RG9jdW1lbnQoKS5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoKTtcbiAgY29uc3QgYmFzZSA9IGRvYy5jcmVhdGVFbGVtZW50KFwiYmFzZVwiKTtcbiAgY29uc3QgYSA9IGRvYy5jcmVhdGVFbGVtZW50KFwiYVwiKTtcbiAgZG9jLmhlYWQuYXBwZW5kQ2hpbGQoYmFzZSk7XG4gIGRvYy5ib2R5LmFwcGVuZENoaWxkKGEpO1xuICBpZiAoYmFzZVVybClcbiAgICBiYXNlLmhyZWYgPSBiYXNlVXJsO1xuICBhLmhyZWYgPSB1cmw7XG4gIHJldHVybiBhLmhyZWY7XG59XG5mdW5jdGlvbiBnZXREb2N1bWVudCh0YXJnZXQpIHtcbiAgcmV0dXJuICh0YXJnZXQgJiYgaXNFbGVtZW50Tm9kZSh0YXJnZXQpID8gdGFyZ2V0Py5vd25lckRvY3VtZW50IDogdGFyZ2V0KSA/PyB3aW5kb3cuZG9jdW1lbnQ7XG59XG5jb25zdCBYTUxOUyA9IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIjtcbmZ1bmN0aW9uIGNyZWF0ZVN2Zyh3aWR0aCwgaGVpZ2h0LCBvd25lckRvY3VtZW50KSB7XG4gIGNvbnN0IHN2ZyA9IGdldERvY3VtZW50KG93bmVyRG9jdW1lbnQpLmNyZWF0ZUVsZW1lbnROUyhYTUxOUywgXCJzdmdcIik7XG4gIHN2Zy5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcIndpZHRoXCIsIHdpZHRoLnRvU3RyaW5nKCkpO1xuICBzdmcuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJoZWlnaHRcIiwgaGVpZ2h0LnRvU3RyaW5nKCkpO1xuICBzdmcuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ2aWV3Qm94XCIsIGAwIDAgJHt3aWR0aH0gJHtoZWlnaHR9YCk7XG4gIHJldHVybiBzdmc7XG59XG5mdW5jdGlvbiBzdmdUb0RhdGFVcmwoc3ZnLCByZW1vdmVDb250cm9sQ2hhcmFjdGVyKSB7XG4gIGxldCB4aHRtbCA9IG5ldyBYTUxTZXJpYWxpemVyKCkuc2VyaWFsaXplVG9TdHJpbmcoc3ZnKTtcbiAgaWYgKHJlbW92ZUNvbnRyb2xDaGFyYWN0ZXIpIHtcbiAgICB4aHRtbCA9IHhodG1sLnJlcGxhY2UoL1tcXHUwMDAwLVxcdTAwMDhcXHZcXGZcXHUwMDBFLVxcdTAwMUZcXHVEODAwLVxcdURGRkZcXHVGRkZFXFx1RkZGRl0vZ3UsIFwiXCIpO1xuICB9XG4gIHJldHVybiBgZGF0YTppbWFnZS9zdmcreG1sO2NoYXJzZXQ9dXRmLTgsJHtlbmNvZGVVUklDb21wb25lbnQoeGh0bWwpfWA7XG59XG5hc3luYyBmdW5jdGlvbiBjYW52YXNUb0Jsb2IoY2FudmFzLCB0eXBlID0gXCJpbWFnZS9wbmdcIiwgcXVhbGl0eSA9IDEpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY2FudmFzLnRvQmxvYigoYmxvYikgPT4ge1xuICAgICAgICBpZiAoYmxvYikge1xuICAgICAgICAgIHJlc29sdmUoYmxvYik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIkJsb2IgaXMgbnVsbFwiKSk7XG4gICAgICAgIH1cbiAgICAgIH0sIHR5cGUsIHF1YWxpdHkpO1xuICAgIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChTVVBQT1JUX0FUT0IpIHtcbiAgICAgIHJldHVybiBkYXRhVXJsVG9CbG9iKGNhbnZhcy50b0RhdGFVUkwodHlwZSwgcXVhbGl0eSkpO1xuICAgIH1cbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuZnVuY3Rpb24gZGF0YVVybFRvQmxvYihkYXRhVXJsKSB7XG4gIGNvbnN0IFtoZWFkZXIsIGJhc2U2NF0gPSBkYXRhVXJsLnNwbGl0KFwiLFwiKTtcbiAgY29uc3QgdHlwZSA9IGhlYWRlci5tYXRjaCgvZGF0YTooLispOy8pPy5bMV0gPz8gdm9pZCAwO1xuICBjb25zdCBkZWNvZGVkID0gd2luZG93LmF0b2IoYmFzZTY0KTtcbiAgY29uc3QgbGVuZ3RoID0gZGVjb2RlZC5sZW5ndGg7XG4gIGNvbnN0IGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICBidWZmZXJbaV0gPSBkZWNvZGVkLmNoYXJDb2RlQXQoaSk7XG4gIH1cbiAgcmV0dXJuIG5ldyBCbG9iKFtidWZmZXJdLCB7IHR5cGUgfSk7XG59XG5mdW5jdGlvbiByZWFkQmxvYihibG9iLCB0eXBlKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICByZWFkZXIub25sb2FkID0gKCkgPT4gcmVzb2x2ZShyZWFkZXIucmVzdWx0KTtcbiAgICByZWFkZXIub25lcnJvciA9ICgpID0+IHJlamVjdChyZWFkZXIuZXJyb3IpO1xuICAgIHJlYWRlci5vbmFib3J0ID0gKCkgPT4gcmVqZWN0KG5ldyBFcnJvcihgRmFpbGVkIHJlYWQgYmxvYiB0byAke3R5cGV9YCkpO1xuICAgIGlmICh0eXBlID09PSBcImRhdGFVcmxcIikge1xuICAgICAgcmVhZGVyLnJlYWRBc0RhdGFVUkwoYmxvYik7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBcImFycmF5QnVmZmVyXCIpIHtcbiAgICAgIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihibG9iKTtcbiAgICB9XG4gIH0pO1xufVxuY29uc3QgYmxvYlRvRGF0YVVybCA9IChibG9iKSA9PiByZWFkQmxvYihibG9iLCBcImRhdGFVcmxcIik7XG5jb25zdCBibG9iVG9BcnJheUJ1ZmZlciA9IChibG9iKSA9PiByZWFkQmxvYihibG9iLCBcImFycmF5QnVmZmVyXCIpO1xuZnVuY3Rpb24gY3JlYXRlSW1hZ2UodXJsLCBvd25lckRvY3VtZW50KSB7XG4gIGNvbnN0IGltZyA9IGdldERvY3VtZW50KG93bmVyRG9jdW1lbnQpLmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7XG4gIGltZy5kZWNvZGluZyA9IFwic3luY1wiO1xuICBpbWcubG9hZGluZyA9IFwiZWFnZXJcIjtcbiAgaW1nLnNyYyA9IHVybDtcbiAgcmV0dXJuIGltZztcbn1cbmZ1bmN0aW9uIGxvYWRNZWRpYShtZWRpYSwgb3B0aW9ucykge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBjb25zdCB7IHRpbWVvdXQsIG93bmVyRG9jdW1lbnQsIG9uRXJyb3I6IHVzZXJPbkVycm9yLCBvbldhcm4gfSA9IG9wdGlvbnMgPz8ge307XG4gICAgY29uc3Qgbm9kZSA9IHR5cGVvZiBtZWRpYSA9PT0gXCJzdHJpbmdcIiA/IGNyZWF0ZUltYWdlKG1lZGlhLCBnZXREb2N1bWVudChvd25lckRvY3VtZW50KSkgOiBtZWRpYTtcbiAgICBsZXQgdGltZXIgPSBudWxsO1xuICAgIGxldCByZW1vdmVFdmVudExpc3RlbmVycyA9IG51bGw7XG4gICAgZnVuY3Rpb24gb25SZXNvbHZlKCkge1xuICAgICAgcmVzb2x2ZShub2RlKTtcbiAgICAgIHRpbWVyICYmIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICByZW1vdmVFdmVudExpc3RlbmVycz8uKCk7XG4gICAgfVxuICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICB0aW1lciA9IHNldFRpbWVvdXQob25SZXNvbHZlLCB0aW1lb3V0KTtcbiAgICB9XG4gICAgaWYgKGlzVmlkZW9FbGVtZW50KG5vZGUpKSB7XG4gICAgICBjb25zdCBjdXJyZW50U3JjID0gbm9kZS5jdXJyZW50U3JjIHx8IG5vZGUuc3JjO1xuICAgICAgaWYgKCFjdXJyZW50U3JjKSB7XG4gICAgICAgIGlmIChub2RlLnBvc3Rlcikge1xuICAgICAgICAgIHJldHVybiBsb2FkTWVkaWEobm9kZS5wb3N0ZXIsIG9wdGlvbnMpLnRoZW4ocmVzb2x2ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9uUmVzb2x2ZSgpO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUucmVhZHlTdGF0ZSA+PSAyKSB7XG4gICAgICAgIHJldHVybiBvblJlc29sdmUoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9uTG9hZGVkZGF0YSA9IG9uUmVzb2x2ZTtcbiAgICAgIGNvbnN0IG9uRXJyb3IgPSAoZXJyb3IpID0+IHtcbiAgICAgICAgb25XYXJuPy4oXG4gICAgICAgICAgXCJGYWlsZWQgdmlkZW8gbG9hZFwiLFxuICAgICAgICAgIGN1cnJlbnRTcmMsXG4gICAgICAgICAgZXJyb3JcbiAgICAgICAgKTtcbiAgICAgICAgdXNlck9uRXJyb3I/LihlcnJvcik7XG4gICAgICAgIG9uUmVzb2x2ZSgpO1xuICAgICAgfTtcbiAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXJzID0gKCkgPT4ge1xuICAgICAgICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJsb2FkZWRkYXRhXCIsIG9uTG9hZGVkZGF0YSk7XG4gICAgICAgIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIG9uRXJyb3IpO1xuICAgICAgfTtcbiAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRlZGRhdGFcIiwgb25Mb2FkZWRkYXRhLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCBvbkVycm9yLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRTcmMgPSBpc1NWR0ltYWdlRWxlbWVudE5vZGUobm9kZSkgPyBub2RlLmhyZWYuYmFzZVZhbCA6IG5vZGUuY3VycmVudFNyYyB8fCBub2RlLnNyYztcbiAgICAgIGlmICghY3VycmVudFNyYykge1xuICAgICAgICByZXR1cm4gb25SZXNvbHZlKCk7XG4gICAgICB9XG4gICAgICBjb25zdCBvbkxvYWQgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIGlmIChpc0ltYWdlRWxlbWVudChub2RlKSAmJiBcImRlY29kZVwiIGluIG5vZGUpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgbm9kZS5kZWNvZGUoKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgb25XYXJuPy4oXG4gICAgICAgICAgICAgIFwiRmFpbGVkIHRvIGRlY29kZSBpbWFnZSwgdHJ5aW5nIHRvIHJlbmRlciBhbnl3YXlcIixcbiAgICAgICAgICAgICAgbm9kZS5kYXRhc2V0Lm9yaWdpbmFsU3JjIHx8IGN1cnJlbnRTcmMsXG4gICAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvblJlc29sdmUoKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBvbkVycm9yID0gKGVycm9yKSA9PiB7XG4gICAgICAgIG9uV2Fybj8uKFxuICAgICAgICAgIFwiRmFpbGVkIGltYWdlIGxvYWRcIixcbiAgICAgICAgICBub2RlLmRhdGFzZXQub3JpZ2luYWxTcmMgfHwgY3VycmVudFNyYyxcbiAgICAgICAgICBlcnJvclxuICAgICAgICApO1xuICAgICAgICBvblJlc29sdmUoKTtcbiAgICAgIH07XG4gICAgICBpZiAoaXNJbWFnZUVsZW1lbnQobm9kZSkgJiYgbm9kZS5jb21wbGV0ZSkge1xuICAgICAgICByZXR1cm4gb25Mb2FkKCk7XG4gICAgICB9XG4gICAgICByZW1vdmVFdmVudExpc3RlbmVycyA9ICgpID0+IHtcbiAgICAgICAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKFwibG9hZFwiLCBvbkxvYWQpO1xuICAgICAgICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCBvbkVycm9yKTtcbiAgICAgIH07XG4gICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIG9uTG9hZCwgeyBvbmNlOiB0cnVlIH0pO1xuICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgb25FcnJvciwgeyBvbmNlOiB0cnVlIH0pO1xuICAgIH1cbiAgfSk7XG59XG5hc3luYyBmdW5jdGlvbiB3YWl0VW50aWxMb2FkKG5vZGUsIG9wdGlvbnMpIHtcbiAgaWYgKGlzSFRNTEVsZW1lbnROb2RlKG5vZGUpKSB7XG4gICAgaWYgKGlzSW1hZ2VFbGVtZW50KG5vZGUpIHx8IGlzVmlkZW9FbGVtZW50KG5vZGUpKSB7XG4gICAgICBhd2FpdCBsb2FkTWVkaWEobm9kZSwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICBbXCJpbWdcIiwgXCJ2aWRlb1wiXS5mbGF0TWFwKChzZWxlY3RvcnMpID0+IHtcbiAgICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShub2RlLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3JzKSkubWFwKChlbCkgPT4gbG9hZE1lZGlhKGVsLCBvcHRpb25zKSk7XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuY29uc3QgdXVpZCA9IC8qIEBfX1BVUkVfXyAqLyBmdW5jdGlvbiB1dWlkMigpIHtcbiAgbGV0IGNvdW50ZXIgPSAwO1xuICBjb25zdCByYW5kb20gPSAoKSA9PiBgMDAwMCR7KE1hdGgucmFuZG9tKCkgKiAzNiAqKiA0IDw8IDApLnRvU3RyaW5nKDM2KX1gLnNsaWNlKC00KTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBjb3VudGVyICs9IDE7XG4gICAgcmV0dXJuIGB1JHtyYW5kb20oKX0ke2NvdW50ZXJ9YDtcbiAgfTtcbn0oKTtcbmZ1bmN0aW9uIHNwbGl0Rm9udEZhbWlseShmb250RmFtaWx5KSB7XG4gIHJldHVybiBmb250RmFtaWx5Py5zcGxpdChcIixcIikubWFwKCh2YWwpID0+IHZhbC50cmltKCkucmVwbGFjZSgvXCJ8Jy9nLCBcIlwiKS50b0xvd2VyQ2FzZSgpKS5maWx0ZXIoQm9vbGVhbik7XG59XG5cbmxldCB1aWQgPSAwO1xuZnVuY3Rpb24gY3JlYXRlTG9nZ2VyKGRlYnVnKSB7XG4gIGNvbnN0IHByZWZpeCA9IGAke1BSRUZJWH1bIyR7dWlkfV1gO1xuICB1aWQrKztcbiAgcmV0dXJuIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgIHRpbWU6IChsYWJlbCkgPT4gZGVidWcgJiYgY29uc29sZS50aW1lKGAke3ByZWZpeH0gJHtsYWJlbH1gKSxcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgIHRpbWVFbmQ6IChsYWJlbCkgPT4gZGVidWcgJiYgY29uc29sZS50aW1lRW5kKGAke3ByZWZpeH0gJHtsYWJlbH1gKSxcbiAgICB3YXJuOiAoLi4uYXJncykgPT4gZGVidWcgJiYgY29uc29sZVdhcm4oLi4uYXJncylcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0RGVmYXVsdFJlcXVlc3RJbml0KGJ5cGFzc2luZ0NhY2hlKSB7XG4gIHJldHVybiB7XG4gICAgY2FjaGU6IGJ5cGFzc2luZ0NhY2hlID8gXCJuby1jYWNoZVwiIDogXCJmb3JjZS1jYWNoZVwiXG4gIH07XG59XG5cbmFzeW5jIGZ1bmN0aW9uIG9yQ3JlYXRlQ29udGV4dChub2RlLCBvcHRpb25zKSB7XG4gIHJldHVybiBpc0NvbnRleHQobm9kZSkgPyBub2RlIDogY3JlYXRlQ29udGV4dChub2RlLCB7IC4uLm9wdGlvbnMsIGF1dG9EZXN0cnVjdDogdHJ1ZSB9KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUNvbnRleHQobm9kZSwgb3B0aW9ucykge1xuICBjb25zdCB7IHNjYWxlID0gMSwgd29ya2VyVXJsLCB3b3JrZXJOdW1iZXIgPSAxIH0gPSBvcHRpb25zIHx8IHt9O1xuICBjb25zdCBkZWJ1ZyA9IEJvb2xlYW4ob3B0aW9ucz8uZGVidWcpO1xuICBjb25zdCBmZWF0dXJlcyA9IG9wdGlvbnM/LmZlYXR1cmVzID8/IHRydWU7XG4gIGNvbnN0IG93bmVyRG9jdW1lbnQgPSBub2RlLm93bmVyRG9jdW1lbnQgPz8gKElOX0JST1dTRVIgPyB3aW5kb3cuZG9jdW1lbnQgOiB2b2lkIDApO1xuICBjb25zdCBvd25lcldpbmRvdyA9IG5vZGUub3duZXJEb2N1bWVudD8uZGVmYXVsdFZpZXcgPz8gKElOX0JST1dTRVIgPyB3aW5kb3cgOiB2b2lkIDApO1xuICBjb25zdCByZXF1ZXN0cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgLy8gT3B0aW9uc1xuICAgIHdpZHRoOiAwLFxuICAgIGhlaWdodDogMCxcbiAgICBxdWFsaXR5OiAxLFxuICAgIHR5cGU6IFwiaW1hZ2UvcG5nXCIsXG4gICAgc2NhbGUsXG4gICAgYmFja2dyb3VuZENvbG9yOiBudWxsLFxuICAgIHN0eWxlOiBudWxsLFxuICAgIGZpbHRlcjogbnVsbCxcbiAgICBtYXhpbXVtQ2FudmFzU2l6ZTogMCxcbiAgICB0aW1lb3V0OiAzZTQsXG4gICAgcHJvZ3Jlc3M6IG51bGwsXG4gICAgZGVidWcsXG4gICAgZmV0Y2g6IHtcbiAgICAgIHJlcXVlc3RJbml0OiBnZXREZWZhdWx0UmVxdWVzdEluaXQob3B0aW9ucz8uZmV0Y2g/LmJ5cGFzc2luZ0NhY2hlKSxcbiAgICAgIHBsYWNlaG9sZGVySW1hZ2U6IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LFIwbEdPRGxoQVFBQkFJQUFBQUFBQVAvLy95SDVCQUVBQUFBQUxBQUFBQUFCQUFFQUFBSUJSQUE3XCIsXG4gICAgICBieXBhc3NpbmdDYWNoZTogZmFsc2UsXG4gICAgICAuLi5vcHRpb25zPy5mZXRjaFxuICAgIH0sXG4gICAgZmV0Y2hGbjogbnVsbCxcbiAgICBmb250OiB7fSxcbiAgICBkcmF3SW1hZ2VJbnRlcnZhbDogMTAwLFxuICAgIHdvcmtlclVybDogbnVsbCxcbiAgICB3b3JrZXJOdW1iZXIsXG4gICAgb25DbG9uZUVhY2hOb2RlOiBudWxsLFxuICAgIG9uQ2xvbmVOb2RlOiBudWxsLFxuICAgIG9uRW1iZWROb2RlOiBudWxsLFxuICAgIG9uQ3JlYXRlRm9yZWlnbk9iamVjdFN2ZzogbnVsbCxcbiAgICBpbmNsdWRlU3R5bGVQcm9wZXJ0aWVzOiBudWxsLFxuICAgIGF1dG9EZXN0cnVjdDogZmFsc2UsXG4gICAgLi4ub3B0aW9ucyxcbiAgICAvLyBJbnRlcm5hbENvbnRleHRcbiAgICBfX0NPTlRFWFRfXzogdHJ1ZSxcbiAgICBsb2c6IGNyZWF0ZUxvZ2dlcihkZWJ1ZyksXG4gICAgbm9kZSxcbiAgICBvd25lckRvY3VtZW50LFxuICAgIG93bmVyV2luZG93LFxuICAgIGRwaTogc2NhbGUgPT09IDEgPyBudWxsIDogOTYgKiBzY2FsZSxcbiAgICBzdmdTdHlsZUVsZW1lbnQ6IGNyZWF0ZVN0eWxlRWxlbWVudChvd25lckRvY3VtZW50KSxcbiAgICBzdmdEZWZzRWxlbWVudDogb3duZXJEb2N1bWVudD8uY3JlYXRlRWxlbWVudE5TKFhNTE5TLCBcImRlZnNcIiksXG4gICAgc3ZnU3R5bGVzOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLFxuICAgIGRlZmF1bHRDb21wdXRlZFN0eWxlczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSxcbiAgICB3b3JrZXJzOiBbXG4gICAgICAuLi5BcnJheS5mcm9tKHtcbiAgICAgICAgbGVuZ3RoOiBTVVBQT1JUX1dFQl9XT1JLRVIgJiYgd29ya2VyVXJsICYmIHdvcmtlck51bWJlciA/IHdvcmtlck51bWJlciA6IDBcbiAgICAgIH0pXG4gICAgXS5tYXAoKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgd29ya2VyID0gbmV3IFdvcmtlcih3b3JrZXJVcmwpO1xuICAgICAgICB3b3JrZXIub25tZXNzYWdlID0gYXN5bmMgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgY29uc3QgeyB1cmwsIHJlc3VsdCB9ID0gZXZlbnQuZGF0YTtcbiAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICByZXF1ZXN0cy5nZXQodXJsKT8ucmVzb2x2ZT8uKHJlc3VsdCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlcXVlc3RzLmdldCh1cmwpPy5yZWplY3Q/LihuZXcgRXJyb3IoYEVycm9yIHJlY2VpdmluZyBtZXNzYWdlIGZyb20gd29ya2VyOiAke3VybH1gKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB3b3JrZXIub25tZXNzYWdlZXJyb3IgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICBjb25zdCB7IHVybCB9ID0gZXZlbnQuZGF0YTtcbiAgICAgICAgICByZXF1ZXN0cy5nZXQodXJsKT8ucmVqZWN0Py4obmV3IEVycm9yKGBFcnJvciByZWNlaXZpbmcgbWVzc2FnZSBmcm9tIHdvcmtlcjogJHt1cmx9YCkpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gd29ya2VyO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29udGV4dC5sb2cud2FybihcIkZhaWxlZCB0byBuZXcgV29ya2VyXCIsIGVycm9yKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfSkuZmlsdGVyKEJvb2xlYW4pLFxuICAgIGZvbnRGYW1pbGllczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSxcbiAgICBmb250Q3NzVGV4dHM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksXG4gICAgYWNjZXB0T2ZJbWFnZTogYCR7W1xuICAgICAgc3VwcG9ydFdlYnAob3duZXJEb2N1bWVudCkgJiYgXCJpbWFnZS93ZWJwXCIsXG4gICAgICBcImltYWdlL3N2Zyt4bWxcIixcbiAgICAgIFwiaW1hZ2UvKlwiLFxuICAgICAgXCIqLypcIlxuICAgIF0uZmlsdGVyKEJvb2xlYW4pLmpvaW4oXCIsXCIpfTtxPTAuOGAsXG4gICAgcmVxdWVzdHMsXG4gICAgZHJhd0ltYWdlQ291bnQ6IDAsXG4gICAgdGFza3M6IFtdLFxuICAgIGZlYXR1cmVzLFxuICAgIGlzRW5hYmxlOiAoa2V5KSA9PiB7XG4gICAgICBpZiAoa2V5ID09PSBcInJlc3RvcmVTY3JvbGxQb3NpdGlvblwiKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgZmVhdHVyZXMgPT09IFwiYm9vbGVhblwiID8gZmFsc2UgOiBmZWF0dXJlc1trZXldID8/IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBmZWF0dXJlcyA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgcmV0dXJuIGZlYXR1cmVzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZlYXR1cmVzW2tleV0gPz8gdHJ1ZTtcbiAgICB9LFxuICAgIHNoYWRvd1Jvb3RzOiBbXVxuICB9O1xuICBjb250ZXh0LmxvZy50aW1lKFwid2FpdCB1bnRpbCBsb2FkXCIpO1xuICBhd2FpdCB3YWl0VW50aWxMb2FkKG5vZGUsIHsgdGltZW91dDogY29udGV4dC50aW1lb3V0LCBvbldhcm46IGNvbnRleHQubG9nLndhcm4gfSk7XG4gIGNvbnRleHQubG9nLnRpbWVFbmQoXCJ3YWl0IHVudGlsIGxvYWRcIik7XG4gIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gcmVzb2x2ZUJvdW5kaW5nQm94KG5vZGUsIGNvbnRleHQpO1xuICBjb250ZXh0LndpZHRoID0gd2lkdGg7XG4gIGNvbnRleHQuaGVpZ2h0ID0gaGVpZ2h0O1xuICByZXR1cm4gY29udGV4dDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVN0eWxlRWxlbWVudChvd25lckRvY3VtZW50KSB7XG4gIGlmICghb3duZXJEb2N1bWVudClcbiAgICByZXR1cm4gdm9pZCAwO1xuICBjb25zdCBzdHlsZSA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICBjb25zdCBjc3NUZXh0ID0gc3R5bGUub3duZXJEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShgXG4uX19fX19fYmFja2dyb3VuZC1jbGlwLS10ZXh0IHtcbiAgYmFja2dyb3VuZC1jbGlwOiB0ZXh0O1xuICAtd2Via2l0LWJhY2tncm91bmQtY2xpcDogdGV4dDtcbn1cbmApO1xuICBzdHlsZS5hcHBlbmRDaGlsZChjc3NUZXh0KTtcbiAgcmV0dXJuIHN0eWxlO1xufVxuZnVuY3Rpb24gcmVzb2x2ZUJvdW5kaW5nQm94KG5vZGUsIGNvbnRleHQpIHtcbiAgbGV0IHsgd2lkdGgsIGhlaWdodCB9ID0gY29udGV4dDtcbiAgaWYgKGlzRWxlbWVudE5vZGUobm9kZSkgJiYgKCF3aWR0aCB8fCAhaGVpZ2h0KSkge1xuICAgIGNvbnN0IGJveCA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgd2lkdGggPSB3aWR0aCB8fCBib3gud2lkdGggfHwgTnVtYmVyKG5vZGUuZ2V0QXR0cmlidXRlKFwid2lkdGhcIikpIHx8IDA7XG4gICAgaGVpZ2h0ID0gaGVpZ2h0IHx8IGJveC5oZWlnaHQgfHwgTnVtYmVyKG5vZGUuZ2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIpKSB8fCAwO1xuICB9XG4gIHJldHVybiB7IHdpZHRoLCBoZWlnaHQgfTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gaW1hZ2VUb0NhbnZhcyhpbWFnZSwgY29udGV4dCkge1xuICBjb25zdCB7XG4gICAgbG9nLFxuICAgIHRpbWVvdXQsXG4gICAgZHJhd0ltYWdlQ291bnQsXG4gICAgZHJhd0ltYWdlSW50ZXJ2YWxcbiAgfSA9IGNvbnRleHQ7XG4gIGxvZy50aW1lKFwiaW1hZ2UgdG8gY2FudmFzXCIpO1xuICBjb25zdCBsb2FkZWQgPSBhd2FpdCBsb2FkTWVkaWEoaW1hZ2UsIHsgdGltZW91dCwgb25XYXJuOiBjb250ZXh0LmxvZy53YXJuIH0pO1xuICBjb25zdCB7IGNhbnZhcywgY29udGV4dDJkIH0gPSBjcmVhdGVDYW52YXMoaW1hZ2Uub3duZXJEb2N1bWVudCwgY29udGV4dCk7XG4gIGNvbnN0IGRyYXdJbWFnZSA9ICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29udGV4dDJkPy5kcmF3SW1hZ2UobG9hZGVkLCAwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb250ZXh0LmxvZy53YXJuKFwiRmFpbGVkIHRvIGRyYXdJbWFnZVwiLCBlcnJvcik7XG4gICAgfVxuICB9O1xuICBkcmF3SW1hZ2UoKTtcbiAgaWYgKGNvbnRleHQuaXNFbmFibGUoXCJmaXhTdmdYbWxEZWNvZGVcIikpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRyYXdJbWFnZUNvdW50OyBpKyspIHtcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGNvbnRleHQyZD8uY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgICAgZHJhd0ltYWdlKCk7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9LCBpICsgZHJhd0ltYWdlSW50ZXJ2YWwpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGNvbnRleHQuZHJhd0ltYWdlQ291bnQgPSAwO1xuICBsb2cudGltZUVuZChcImltYWdlIHRvIGNhbnZhc1wiKTtcbiAgcmV0dXJuIGNhbnZhcztcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNhbnZhcyhvd25lckRvY3VtZW50LCBjb250ZXh0KSB7XG4gIGNvbnN0IHsgd2lkdGgsIGhlaWdodCwgc2NhbGUsIGJhY2tncm91bmRDb2xvciwgbWF4aW11bUNhbnZhc1NpemU6IG1heCB9ID0gY29udGV4dDtcbiAgY29uc3QgY2FudmFzID0gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICBjYW52YXMud2lkdGggPSBNYXRoLmZsb29yKHdpZHRoICogc2NhbGUpO1xuICBjYW52YXMuaGVpZ2h0ID0gTWF0aC5mbG9vcihoZWlnaHQgKiBzY2FsZSk7XG4gIGNhbnZhcy5zdHlsZS53aWR0aCA9IGAke3dpZHRofXB4YDtcbiAgY2FudmFzLnN0eWxlLmhlaWdodCA9IGAke2hlaWdodH1weGA7XG4gIGlmIChtYXgpIHtcbiAgICBpZiAoY2FudmFzLndpZHRoID4gbWF4IHx8IGNhbnZhcy5oZWlnaHQgPiBtYXgpIHtcbiAgICAgIGlmIChjYW52YXMud2lkdGggPiBtYXggJiYgY2FudmFzLmhlaWdodCA+IG1heCkge1xuICAgICAgICBpZiAoY2FudmFzLndpZHRoID4gY2FudmFzLmhlaWdodCkge1xuICAgICAgICAgIGNhbnZhcy5oZWlnaHQgKj0gbWF4IC8gY2FudmFzLndpZHRoO1xuICAgICAgICAgIGNhbnZhcy53aWR0aCA9IG1heDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYW52YXMud2lkdGggKj0gbWF4IC8gY2FudmFzLmhlaWdodDtcbiAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gbWF4O1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNhbnZhcy53aWR0aCA+IG1heCkge1xuICAgICAgICBjYW52YXMuaGVpZ2h0ICo9IG1heCAvIGNhbnZhcy53aWR0aDtcbiAgICAgICAgY2FudmFzLndpZHRoID0gbWF4O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FudmFzLndpZHRoICo9IG1heCAvIGNhbnZhcy5oZWlnaHQ7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBtYXg7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbnN0IGNvbnRleHQyZCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gIGlmIChjb250ZXh0MmQgJiYgYmFja2dyb3VuZENvbG9yKSB7XG4gICAgY29udGV4dDJkLmZpbGxTdHlsZSA9IGJhY2tncm91bmRDb2xvcjtcbiAgICBjb250ZXh0MmQuZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgfVxuICByZXR1cm4geyBjYW52YXMsIGNvbnRleHQyZCB9O1xufVxuXG5mdW5jdGlvbiBjbG9uZUNhbnZhcyhjYW52YXMsIGNvbnRleHQpIHtcbiAgaWYgKGNhbnZhcy5vd25lckRvY3VtZW50KSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGRhdGFVUkwgPSBjYW52YXMudG9EYXRhVVJMKCk7XG4gICAgICBpZiAoZGF0YVVSTCAhPT0gXCJkYXRhOixcIikge1xuICAgICAgICByZXR1cm4gY3JlYXRlSW1hZ2UoZGF0YVVSTCwgY2FudmFzLm93bmVyRG9jdW1lbnQpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb250ZXh0LmxvZy53YXJuKFwiRmFpbGVkIHRvIGNsb25lIGNhbnZhc1wiLCBlcnJvcik7XG4gICAgfVxuICB9XG4gIGNvbnN0IGNsb25lZCA9IGNhbnZhcy5jbG9uZU5vZGUoZmFsc2UpO1xuICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICBjb25zdCBjbG9uZWRDdHggPSBjbG9uZWQuZ2V0Q29udGV4dChcIjJkXCIpO1xuICB0cnkge1xuICAgIGlmIChjdHggJiYgY2xvbmVkQ3R4KSB7XG4gICAgICBjbG9uZWRDdHgucHV0SW1hZ2VEYXRhKFxuICAgICAgICBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCksXG4gICAgICAgIDAsXG4gICAgICAgIDBcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBjbG9uZWQ7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29udGV4dC5sb2cud2FybihcIkZhaWxlZCB0byBjbG9uZSBjYW52YXNcIiwgZXJyb3IpO1xuICB9XG4gIHJldHVybiBjbG9uZWQ7XG59XG5cbmZ1bmN0aW9uIGNsb25lSWZyYW1lKGlmcmFtZSwgY29udGV4dCkge1xuICB0cnkge1xuICAgIGlmIChpZnJhbWU/LmNvbnRlbnREb2N1bWVudD8uYm9keSkge1xuICAgICAgcmV0dXJuIGNsb25lTm9kZShpZnJhbWUuY29udGVudERvY3VtZW50LmJvZHksIGNvbnRleHQpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb250ZXh0LmxvZy53YXJuKFwiRmFpbGVkIHRvIGNsb25lIGlmcmFtZVwiLCBlcnJvcik7XG4gIH1cbiAgcmV0dXJuIGlmcmFtZS5jbG9uZU5vZGUoZmFsc2UpO1xufVxuXG5mdW5jdGlvbiBjbG9uZUltYWdlKGltYWdlKSB7XG4gIGNvbnN0IGNsb25lZCA9IGltYWdlLmNsb25lTm9kZShmYWxzZSk7XG4gIGlmIChpbWFnZS5jdXJyZW50U3JjICYmIGltYWdlLmN1cnJlbnRTcmMgIT09IGltYWdlLnNyYykge1xuICAgIGNsb25lZC5zcmMgPSBpbWFnZS5jdXJyZW50U3JjO1xuICAgIGNsb25lZC5zcmNzZXQgPSBcIlwiO1xuICB9XG4gIGlmIChjbG9uZWQubG9hZGluZyA9PT0gXCJsYXp5XCIpIHtcbiAgICBjbG9uZWQubG9hZGluZyA9IFwiZWFnZXJcIjtcbiAgfVxuICByZXR1cm4gY2xvbmVkO1xufVxuXG5hc3luYyBmdW5jdGlvbiBjbG9uZVZpZGVvKHZpZGVvLCBjb250ZXh0KSB7XG4gIGlmICh2aWRlby5vd25lckRvY3VtZW50ICYmICF2aWRlby5jdXJyZW50U3JjICYmIHZpZGVvLnBvc3Rlcikge1xuICAgIHJldHVybiBjcmVhdGVJbWFnZSh2aWRlby5wb3N0ZXIsIHZpZGVvLm93bmVyRG9jdW1lbnQpO1xuICB9XG4gIGNvbnN0IGNsb25lZCA9IHZpZGVvLmNsb25lTm9kZShmYWxzZSk7XG4gIGNsb25lZC5jcm9zc09yaWdpbiA9IFwiYW5vbnltb3VzXCI7XG4gIGlmICh2aWRlby5jdXJyZW50U3JjICYmIHZpZGVvLmN1cnJlbnRTcmMgIT09IHZpZGVvLnNyYykge1xuICAgIGNsb25lZC5zcmMgPSB2aWRlby5jdXJyZW50U3JjO1xuICB9XG4gIGNvbnN0IG93bmVyRG9jdW1lbnQgPSBjbG9uZWQub3duZXJEb2N1bWVudDtcbiAgaWYgKG93bmVyRG9jdW1lbnQpIHtcbiAgICBsZXQgY2FuUGxheSA9IHRydWU7XG4gICAgYXdhaXQgbG9hZE1lZGlhKGNsb25lZCwgeyBvbkVycm9yOiAoKSA9PiBjYW5QbGF5ID0gZmFsc2UsIG9uV2FybjogY29udGV4dC5sb2cud2FybiB9KTtcbiAgICBpZiAoIWNhblBsYXkpIHtcbiAgICAgIGlmICh2aWRlby5wb3N0ZXIpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUltYWdlKHZpZGVvLnBvc3RlciwgdmlkZW8ub3duZXJEb2N1bWVudCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2xvbmVkO1xuICAgIH1cbiAgICBjbG9uZWQuY3VycmVudFRpbWUgPSB2aWRlby5jdXJyZW50VGltZTtcbiAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgY2xvbmVkLmFkZEV2ZW50TGlzdGVuZXIoXCJzZWVrZWRcIiwgcmVzb2x2ZSwgeyBvbmNlOiB0cnVlIH0pO1xuICAgIH0pO1xuICAgIGNvbnN0IGNhbnZhcyA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICBjYW52YXMud2lkdGggPSB2aWRlby5vZmZzZXRXaWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gdmlkZW8ub2Zmc2V0SGVpZ2h0O1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgaWYgKGN0eClcbiAgICAgICAgY3R4LmRyYXdJbWFnZShjbG9uZWQsIDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnRleHQubG9nLndhcm4oXCJGYWlsZWQgdG8gY2xvbmUgdmlkZW9cIiwgZXJyb3IpO1xuICAgICAgaWYgKHZpZGVvLnBvc3Rlcikge1xuICAgICAgICByZXR1cm4gY3JlYXRlSW1hZ2UodmlkZW8ucG9zdGVyLCB2aWRlby5vd25lckRvY3VtZW50KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjbG9uZWQ7XG4gICAgfVxuICAgIHJldHVybiBjbG9uZUNhbnZhcyhjYW52YXMsIGNvbnRleHQpO1xuICB9XG4gIHJldHVybiBjbG9uZWQ7XG59XG5cbmZ1bmN0aW9uIGNsb25lRWxlbWVudChub2RlLCBjb250ZXh0KSB7XG4gIGlmIChpc0NhbnZhc0VsZW1lbnQobm9kZSkpIHtcbiAgICByZXR1cm4gY2xvbmVDYW52YXMobm9kZSwgY29udGV4dCk7XG4gIH1cbiAgaWYgKGlzSUZyYW1lRWxlbWVudChub2RlKSkge1xuICAgIHJldHVybiBjbG9uZUlmcmFtZShub2RlLCBjb250ZXh0KTtcbiAgfVxuICBpZiAoaXNJbWFnZUVsZW1lbnQobm9kZSkpIHtcbiAgICByZXR1cm4gY2xvbmVJbWFnZShub2RlKTtcbiAgfVxuICBpZiAoaXNWaWRlb0VsZW1lbnQobm9kZSkpIHtcbiAgICByZXR1cm4gY2xvbmVWaWRlbyhub2RlLCBjb250ZXh0KTtcbiAgfVxuICByZXR1cm4gbm9kZS5jbG9uZU5vZGUoZmFsc2UpO1xufVxuXG5mdW5jdGlvbiBnZXRTYW5kQm94KGNvbnRleHQpIHtcbiAgbGV0IHNhbmRib3ggPSBjb250ZXh0LnNhbmRib3g7XG4gIGlmICghc2FuZGJveCkge1xuICAgIGNvbnN0IHsgb3duZXJEb2N1bWVudCB9ID0gY29udGV4dDtcbiAgICB0cnkge1xuICAgICAgaWYgKG93bmVyRG9jdW1lbnQpIHtcbiAgICAgICAgc2FuZGJveCA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlmcmFtZVwiKTtcbiAgICAgICAgc2FuZGJveC5pZCA9IGBfX1NBTkRCT1hfXyR7dXVpZCgpfWA7XG4gICAgICAgIHNhbmRib3gud2lkdGggPSBcIjBcIjtcbiAgICAgICAgc2FuZGJveC5oZWlnaHQgPSBcIjBcIjtcbiAgICAgICAgc2FuZGJveC5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcbiAgICAgICAgc2FuZGJveC5zdHlsZS5wb3NpdGlvbiA9IFwiZml4ZWRcIjtcbiAgICAgICAgb3duZXJEb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHNhbmRib3gpO1xuICAgICAgICBzYW5kYm94LnNyY2RvYyA9ICc8IURPQ1RZUEUgaHRtbD48bWV0YSBjaGFyc2V0PVwiVVRGLThcIj48dGl0bGU+PC90aXRsZT48Ym9keT4nO1xuICAgICAgICBjb250ZXh0LnNhbmRib3ggPSBzYW5kYm94O1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb250ZXh0LmxvZy53YXJuKFwiRmFpbGVkIHRvIGdldFNhbmRCb3hcIiwgZXJyb3IpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2FuZGJveDtcbn1cblxuY29uc3QgaWdub3JlZFN0eWxlcyA9IFtcbiAgXCJ3aWR0aFwiLFxuICBcImhlaWdodFwiLFxuICBcIi13ZWJraXQtdGV4dC1maWxsLWNvbG9yXCJcbl07XG5jb25zdCBpbmNsdWRlZEF0dHJpYnV0ZXMgPSBbXG4gIFwic3Ryb2tlXCIsXG4gIFwiZmlsbFwiXG5dO1xuZnVuY3Rpb24gZ2V0RGVmYXVsdFN0eWxlKG5vZGUsIHBzZXVkb0VsZW1lbnQsIGNvbnRleHQpIHtcbiAgY29uc3QgeyBkZWZhdWx0Q29tcHV0ZWRTdHlsZXMgfSA9IGNvbnRleHQ7XG4gIGNvbnN0IG5vZGVOYW1lID0gbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICBjb25zdCBpc1N2Z05vZGUgPSBpc1NWR0VsZW1lbnROb2RlKG5vZGUpICYmIG5vZGVOYW1lICE9PSBcInN2Z1wiO1xuICBjb25zdCBhdHRyaWJ1dGVzID0gaXNTdmdOb2RlID8gaW5jbHVkZWRBdHRyaWJ1dGVzLm1hcCgobmFtZSkgPT4gW25hbWUsIG5vZGUuZ2V0QXR0cmlidXRlKG5hbWUpXSkuZmlsdGVyKChbLCB2YWx1ZV0pID0+IHZhbHVlICE9PSBudWxsKSA6IFtdO1xuICBjb25zdCBrZXkgPSBbXG4gICAgaXNTdmdOb2RlICYmIFwic3ZnXCIsXG4gICAgbm9kZU5hbWUsXG4gICAgYXR0cmlidXRlcy5tYXAoKG5hbWUsIHZhbHVlKSA9PiBgJHtuYW1lfT0ke3ZhbHVlfWApLmpvaW4oXCIsXCIpLFxuICAgIHBzZXVkb0VsZW1lbnRcbiAgXS5maWx0ZXIoQm9vbGVhbikuam9pbihcIjpcIik7XG4gIGlmIChkZWZhdWx0Q29tcHV0ZWRTdHlsZXMuaGFzKGtleSkpXG4gICAgcmV0dXJuIGRlZmF1bHRDb21wdXRlZFN0eWxlcy5nZXQoa2V5KTtcbiAgY29uc3Qgc2FuZGJveCA9IGdldFNhbmRCb3goY29udGV4dCk7XG4gIGNvbnN0IHNhbmRib3hXaW5kb3cgPSBzYW5kYm94Py5jb250ZW50V2luZG93O1xuICBpZiAoIXNhbmRib3hXaW5kb3cpXG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNvbnN0IHNhbmRib3hEb2N1bWVudCA9IHNhbmRib3hXaW5kb3c/LmRvY3VtZW50O1xuICBsZXQgcm9vdDtcbiAgbGV0IGVsO1xuICBpZiAoaXNTdmdOb2RlKSB7XG4gICAgcm9vdCA9IHNhbmRib3hEb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoWE1MTlMsIFwic3ZnXCIpO1xuICAgIGVsID0gcm9vdC5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhyb290Lm5hbWVzcGFjZVVSSSwgbm9kZU5hbWUpO1xuICAgIGF0dHJpYnV0ZXMuZm9yRWFjaCgoW25hbWUsIHZhbHVlXSkgPT4ge1xuICAgICAgZWwuc2V0QXR0cmlidXRlTlMobnVsbCwgbmFtZSwgdmFsdWUpO1xuICAgIH0pO1xuICAgIHJvb3QuYXBwZW5kQ2hpbGQoZWwpO1xuICB9IGVsc2Uge1xuICAgIHJvb3QgPSBlbCA9IHNhbmRib3hEb2N1bWVudC5jcmVhdGVFbGVtZW50KG5vZGVOYW1lKTtcbiAgfVxuICBlbC50ZXh0Q29udGVudCA9IFwiIFwiO1xuICBzYW5kYm94RG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChyb290KTtcbiAgY29uc3QgY29tcHV0ZWRTdHlsZSA9IHNhbmRib3hXaW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCwgcHNldWRvRWxlbWVudCk7XG4gIGNvbnN0IHN0eWxlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGZvciAobGV0IGxlbiA9IGNvbXB1dGVkU3R5bGUubGVuZ3RoLCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgY29uc3QgbmFtZSA9IGNvbXB1dGVkU3R5bGUuaXRlbShpKTtcbiAgICBpZiAoaWdub3JlZFN0eWxlcy5pbmNsdWRlcyhuYW1lKSlcbiAgICAgIGNvbnRpbnVlO1xuICAgIHN0eWxlcy5zZXQobmFtZSwgY29tcHV0ZWRTdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKG5hbWUpKTtcbiAgfVxuICBzYW5kYm94RG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChyb290KTtcbiAgZGVmYXVsdENvbXB1dGVkU3R5bGVzLnNldChrZXksIHN0eWxlcyk7XG4gIHJldHVybiBzdHlsZXM7XG59XG5cbmZ1bmN0aW9uIGdldERpZmZTdHlsZShzdHlsZSwgZGVmYXVsdFN0eWxlLCBpbmNsdWRlU3R5bGVQcm9wZXJ0aWVzKSB7XG4gIGNvbnN0IGRpZmZTdHlsZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNvbnN0IHByZWZpeHMgPSBbXTtcbiAgY29uc3QgcHJlZml4VHJlZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGlmIChpbmNsdWRlU3R5bGVQcm9wZXJ0aWVzKSB7XG4gICAgZm9yIChjb25zdCBuYW1lIG9mIGluY2x1ZGVTdHlsZVByb3BlcnRpZXMpIHtcbiAgICAgIGFwcGx5VG8obmFtZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAobGV0IGxlbiA9IHN0eWxlLmxlbmd0aCwgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgY29uc3QgbmFtZSA9IHN0eWxlLml0ZW0oaSk7XG4gICAgICBhcHBseVRvKG5hbWUpO1xuICAgIH1cbiAgfVxuICBmb3IgKGxldCBsZW4gPSBwcmVmaXhzLmxlbmd0aCwgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHByZWZpeFRyZWUuZ2V0KHByZWZpeHNbaV0pPy5mb3JFYWNoKCh2YWx1ZSwgbmFtZSkgPT4gZGlmZlN0eWxlLnNldChuYW1lLCB2YWx1ZSkpO1xuICB9XG4gIGZ1bmN0aW9uIGFwcGx5VG8obmFtZSkge1xuICAgIGNvbnN0IHZhbHVlID0gc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShuYW1lKTtcbiAgICBjb25zdCBwcmlvcml0eSA9IHN0eWxlLmdldFByb3BlcnR5UHJpb3JpdHkobmFtZSk7XG4gICAgY29uc3Qgc3ViSW5kZXggPSBuYW1lLmxhc3RJbmRleE9mKFwiLVwiKTtcbiAgICBjb25zdCBwcmVmaXggPSBzdWJJbmRleCA+IC0xID8gbmFtZS5zdWJzdHJpbmcoMCwgc3ViSW5kZXgpIDogdm9pZCAwO1xuICAgIGlmIChwcmVmaXgpIHtcbiAgICAgIGxldCBtYXAgPSBwcmVmaXhUcmVlLmdldChwcmVmaXgpO1xuICAgICAgaWYgKCFtYXApIHtcbiAgICAgICAgbWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgICAgcHJlZml4VHJlZS5zZXQocHJlZml4LCBtYXApO1xuICAgICAgfVxuICAgICAgbWFwLnNldChuYW1lLCBbdmFsdWUsIHByaW9yaXR5XSk7XG4gICAgfVxuICAgIGlmIChkZWZhdWx0U3R5bGUuZ2V0KG5hbWUpID09PSB2YWx1ZSAmJiAhcHJpb3JpdHkpXG4gICAgICByZXR1cm47XG4gICAgaWYgKHByZWZpeCkge1xuICAgICAgcHJlZml4cy5wdXNoKHByZWZpeCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpZmZTdHlsZS5zZXQobmFtZSwgW3ZhbHVlLCBwcmlvcml0eV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGlmZlN0eWxlO1xufVxuXG5mdW5jdGlvbiBjb3B5Q3NzU3R5bGVzKG5vZGUsIGNsb25lZCwgaXNSb290LCBjb250ZXh0KSB7XG4gIGNvbnN0IHsgb3duZXJXaW5kb3csIGluY2x1ZGVTdHlsZVByb3BlcnRpZXMsIGN1cnJlbnRQYXJlbnROb2RlU3R5bGUgfSA9IGNvbnRleHQ7XG4gIGNvbnN0IGNsb25lZFN0eWxlID0gY2xvbmVkLnN0eWxlO1xuICBjb25zdCBjb21wdXRlZFN0eWxlID0gb3duZXJXaW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgY29uc3QgZGVmYXVsdFN0eWxlID0gZ2V0RGVmYXVsdFN0eWxlKG5vZGUsIG51bGwsIGNvbnRleHQpO1xuICBjdXJyZW50UGFyZW50Tm9kZVN0eWxlPy5mb3JFYWNoKChfLCBrZXkpID0+IHtcbiAgICBkZWZhdWx0U3R5bGUuZGVsZXRlKGtleSk7XG4gIH0pO1xuICBjb25zdCBzdHlsZSA9IGdldERpZmZTdHlsZShjb21wdXRlZFN0eWxlLCBkZWZhdWx0U3R5bGUsIGluY2x1ZGVTdHlsZVByb3BlcnRpZXMpO1xuICBzdHlsZS5kZWxldGUoXCJ0cmFuc2l0aW9uLXByb3BlcnR5XCIpO1xuICBzdHlsZS5kZWxldGUoXCJhbGxcIik7XG4gIHN0eWxlLmRlbGV0ZShcImRcIik7XG4gIHN0eWxlLmRlbGV0ZShcImNvbnRlbnRcIik7XG4gIGlmIChpc1Jvb3QpIHtcbiAgICBzdHlsZS5kZWxldGUoXCJtYXJnaW4tdG9wXCIpO1xuICAgIHN0eWxlLmRlbGV0ZShcIm1hcmdpbi1yaWdodFwiKTtcbiAgICBzdHlsZS5kZWxldGUoXCJtYXJnaW4tYm90dG9tXCIpO1xuICAgIHN0eWxlLmRlbGV0ZShcIm1hcmdpbi1sZWZ0XCIpO1xuICAgIHN0eWxlLmRlbGV0ZShcIm1hcmdpbi1ibG9jay1zdGFydFwiKTtcbiAgICBzdHlsZS5kZWxldGUoXCJtYXJnaW4tYmxvY2stZW5kXCIpO1xuICAgIHN0eWxlLmRlbGV0ZShcIm1hcmdpbi1pbmxpbmUtc3RhcnRcIik7XG4gICAgc3R5bGUuZGVsZXRlKFwibWFyZ2luLWlubGluZS1lbmRcIik7XG4gICAgc3R5bGUuc2V0KFwiYm94LXNpemluZ1wiLCBbXCJib3JkZXItYm94XCIsIFwiXCJdKTtcbiAgfVxuICBpZiAoc3R5bGUuZ2V0KFwiYmFja2dyb3VuZC1jbGlwXCIpPy5bMF0gPT09IFwidGV4dFwiKSB7XG4gICAgY2xvbmVkLmNsYXNzTGlzdC5hZGQoXCJfX19fX19iYWNrZ3JvdW5kLWNsaXAtLXRleHRcIik7XG4gIH1cbiAgaWYgKElOX0NIUk9NRSkge1xuICAgIGlmICghc3R5bGUuaGFzKFwiZm9udC1rZXJuaW5nXCIpKVxuICAgICAgc3R5bGUuc2V0KFwiZm9udC1rZXJuaW5nXCIsIFtcIm5vcm1hbFwiLCBcIlwiXSk7XG4gICAgaWYgKChzdHlsZS5nZXQoXCJvdmVyZmxvdy14XCIpPy5bMF0gPT09IFwiaGlkZGVuXCIgfHwgc3R5bGUuZ2V0KFwib3ZlcmZsb3cteVwiKT8uWzBdID09PSBcImhpZGRlblwiKSAmJiBzdHlsZS5nZXQoXCJ0ZXh0LW92ZXJmbG93XCIpPy5bMF0gPT09IFwiZWxsaXBzaXNcIiAmJiBub2RlLnNjcm9sbFdpZHRoID09PSBub2RlLmNsaWVudFdpZHRoKSB7XG4gICAgICBzdHlsZS5zZXQoXCJ0ZXh0LW92ZXJmbG93XCIsIFtcImNsaXBcIiwgXCJcIl0pO1xuICAgIH1cbiAgfVxuICBmb3IgKGxldCBsZW4gPSBjbG9uZWRTdHlsZS5sZW5ndGgsIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjbG9uZWRTdHlsZS5yZW1vdmVQcm9wZXJ0eShjbG9uZWRTdHlsZS5pdGVtKGkpKTtcbiAgfVxuICBzdHlsZS5mb3JFYWNoKChbdmFsdWUsIHByaW9yaXR5XSwgbmFtZSkgPT4ge1xuICAgIGNsb25lZFN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbHVlLCBwcmlvcml0eSk7XG4gIH0pO1xuICByZXR1cm4gc3R5bGU7XG59XG5cbmZ1bmN0aW9uIGNvcHlJbnB1dFZhbHVlKG5vZGUsIGNsb25lZCkge1xuICBpZiAoaXNUZXh0YXJlYUVsZW1lbnQobm9kZSkgfHwgaXNJbnB1dEVsZW1lbnQobm9kZSkgfHwgaXNTZWxlY3RFbGVtZW50KG5vZGUpKSB7XG4gICAgY2xvbmVkLnNldEF0dHJpYnV0ZShcInZhbHVlXCIsIG5vZGUudmFsdWUpO1xuICB9XG59XG5cbmNvbnN0IHBzZXVkb0NsYXNzZXMgPSBbXG4gIFwiOjpiZWZvcmVcIixcbiAgXCI6OmFmdGVyXCJcbiAgLy8gJzo6cGxhY2Vob2xkZXInLCBUT0RPXG5dO1xuY29uc3Qgc2Nyb2xsYmFyUHNldWRvQ2xhc3NlcyA9IFtcbiAgXCI6Oi13ZWJraXQtc2Nyb2xsYmFyXCIsXG4gIFwiOjotd2Via2l0LXNjcm9sbGJhci1idXR0b25cIixcbiAgLy8gJzo6LXdlYmtpdC1zY3JvbGxiYXI6aG9yaXpvbnRhbCcsIFRPRE9cbiAgXCI6Oi13ZWJraXQtc2Nyb2xsYmFyLXRodW1iXCIsXG4gIFwiOjotd2Via2l0LXNjcm9sbGJhci10cmFja1wiLFxuICBcIjo6LXdlYmtpdC1zY3JvbGxiYXItdHJhY2stcGllY2VcIixcbiAgLy8gJzo6LXdlYmtpdC1zY3JvbGxiYXI6dmVydGljYWwnLCBUT0RPXG4gIFwiOjotd2Via2l0LXNjcm9sbGJhci1jb3JuZXJcIixcbiAgXCI6Oi13ZWJraXQtcmVzaXplclwiXG5dO1xuZnVuY3Rpb24gY29weVBzZXVkb0NsYXNzKG5vZGUsIGNsb25lZCwgY29weVNjcm9sbGJhciwgY29udGV4dCwgYWRkV29yZFRvRm9udEZhbWlsaWVzKSB7XG4gIGNvbnN0IHsgb3duZXJXaW5kb3csIHN2Z1N0eWxlRWxlbWVudCwgc3ZnU3R5bGVzLCBjdXJyZW50Tm9kZVN0eWxlIH0gPSBjb250ZXh0O1xuICBpZiAoIXN2Z1N0eWxlRWxlbWVudCB8fCAhb3duZXJXaW5kb3cpXG4gICAgcmV0dXJuO1xuICBmdW5jdGlvbiBjb3B5QnkocHNldWRvQ2xhc3MpIHtcbiAgICBjb25zdCBjb21wdXRlZFN0eWxlID0gb3duZXJXaW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShub2RlLCBwc2V1ZG9DbGFzcyk7XG4gICAgbGV0IGNvbnRlbnQgPSBjb21wdXRlZFN0eWxlLmdldFByb3BlcnR5VmFsdWUoXCJjb250ZW50XCIpO1xuICAgIGlmICghY29udGVudCB8fCBjb250ZW50ID09PSBcIm5vbmVcIilcbiAgICAgIHJldHVybjtcbiAgICBhZGRXb3JkVG9Gb250RmFtaWxpZXM/Lihjb250ZW50KTtcbiAgICBjb250ZW50ID0gY29udGVudC5yZXBsYWNlKC8oJyl8KFwiKXwoY291bnRlclxcKC4rXFwpKS9nLCBcIlwiKTtcbiAgICBjb25zdCBrbGFzc2VzID0gW3V1aWQoKV07XG4gICAgY29uc3QgZGVmYXVsdFN0eWxlID0gZ2V0RGVmYXVsdFN0eWxlKG5vZGUsIHBzZXVkb0NsYXNzLCBjb250ZXh0KTtcbiAgICBjdXJyZW50Tm9kZVN0eWxlPy5mb3JFYWNoKChfLCBrZXkpID0+IHtcbiAgICAgIGRlZmF1bHRTdHlsZS5kZWxldGUoa2V5KTtcbiAgICB9KTtcbiAgICBjb25zdCBzdHlsZSA9IGdldERpZmZTdHlsZShjb21wdXRlZFN0eWxlLCBkZWZhdWx0U3R5bGUsIGNvbnRleHQuaW5jbHVkZVN0eWxlUHJvcGVydGllcyk7XG4gICAgc3R5bGUuZGVsZXRlKFwiY29udGVudFwiKTtcbiAgICBzdHlsZS5kZWxldGUoXCItd2Via2l0LWxvY2FsZVwiKTtcbiAgICBpZiAoc3R5bGUuZ2V0KFwiYmFja2dyb3VuZC1jbGlwXCIpPy5bMF0gPT09IFwidGV4dFwiKSB7XG4gICAgICBjbG9uZWQuY2xhc3NMaXN0LmFkZChcIl9fX19fX2JhY2tncm91bmQtY2xpcC0tdGV4dFwiKTtcbiAgICB9XG4gICAgY29uc3QgY2xvbmVTdHlsZSA9IFtcbiAgICAgIGBjb250ZW50OiAnJHtjb250ZW50fSc7YFxuICAgIF07XG4gICAgc3R5bGUuZm9yRWFjaCgoW3ZhbHVlLCBwcmlvcml0eV0sIG5hbWUpID0+IHtcbiAgICAgIGNsb25lU3R5bGUucHVzaChgJHtuYW1lfTogJHt2YWx1ZX0ke3ByaW9yaXR5ID8gXCIgIWltcG9ydGFudFwiIDogXCJcIn07YCk7XG4gICAgfSk7XG4gICAgaWYgKGNsb25lU3R5bGUubGVuZ3RoID09PSAxKVxuICAgICAgcmV0dXJuO1xuICAgIHRyeSB7XG4gICAgICBjbG9uZWQuY2xhc3NOYW1lID0gW2Nsb25lZC5jbGFzc05hbWUsIC4uLmtsYXNzZXNdLmpvaW4oXCIgXCIpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29udGV4dC5sb2cud2FybihcIkZhaWxlZCB0byBjb3B5UHNldWRvQ2xhc3NcIiwgZXJyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3NzVGV4dCA9IGNsb25lU3R5bGUuam9pbihcIlxcbiAgXCIpO1xuICAgIGxldCBhbGxDbGFzc2VzID0gc3ZnU3R5bGVzLmdldChjc3NUZXh0KTtcbiAgICBpZiAoIWFsbENsYXNzZXMpIHtcbiAgICAgIGFsbENsYXNzZXMgPSBbXTtcbiAgICAgIHN2Z1N0eWxlcy5zZXQoY3NzVGV4dCwgYWxsQ2xhc3Nlcyk7XG4gICAgfVxuICAgIGFsbENsYXNzZXMucHVzaChgLiR7a2xhc3Nlc1swXX0ke3BzZXVkb0NsYXNzfWApO1xuICB9XG4gIHBzZXVkb0NsYXNzZXMuZm9yRWFjaChjb3B5QnkpO1xuICBpZiAoY29weVNjcm9sbGJhcilcbiAgICBzY3JvbGxiYXJQc2V1ZG9DbGFzc2VzLmZvckVhY2goY29weUJ5KTtcbn1cblxuY29uc3QgZXhjbHVkZVBhcmVudE5vZGVzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1xuICBcInN5bWJvbFwiXG4gIC8vIHRlc3QvZml4dHVyZXMvc3ZnLnN5bWJvbC5odG1sXG5dKTtcbmFzeW5jIGZ1bmN0aW9uIGFwcGVuZENoaWxkTm9kZShub2RlLCBjbG9uZWQsIGNoaWxkLCBjb250ZXh0LCBhZGRXb3JkVG9Gb250RmFtaWxpZXMpIHtcbiAgaWYgKGlzRWxlbWVudE5vZGUoY2hpbGQpICYmIChpc1N0eWxlRWxlbWVudChjaGlsZCkgfHwgaXNTY3JpcHRFbGVtZW50KGNoaWxkKSkpXG4gICAgcmV0dXJuO1xuICBpZiAoY29udGV4dC5maWx0ZXIgJiYgIWNvbnRleHQuZmlsdGVyKGNoaWxkKSlcbiAgICByZXR1cm47XG4gIGlmIChleGNsdWRlUGFyZW50Tm9kZXMuaGFzKGNsb25lZC5ub2RlTmFtZSkgfHwgZXhjbHVkZVBhcmVudE5vZGVzLmhhcyhjaGlsZC5ub2RlTmFtZSkpIHtcbiAgICBjb250ZXh0LmN1cnJlbnRQYXJlbnROb2RlU3R5bGUgPSB2b2lkIDA7XG4gIH0gZWxzZSB7XG4gICAgY29udGV4dC5jdXJyZW50UGFyZW50Tm9kZVN0eWxlID0gY29udGV4dC5jdXJyZW50Tm9kZVN0eWxlO1xuICB9XG4gIGNvbnN0IGNoaWxkQ2xvbmVkID0gYXdhaXQgY2xvbmVOb2RlKGNoaWxkLCBjb250ZXh0LCBmYWxzZSwgYWRkV29yZFRvRm9udEZhbWlsaWVzKTtcbiAgaWYgKGNvbnRleHQuaXNFbmFibGUoXCJyZXN0b3JlU2Nyb2xsUG9zaXRpb25cIikpIHtcbiAgICByZXN0b3JlU2Nyb2xsUG9zaXRpb24obm9kZSwgY2hpbGRDbG9uZWQpO1xuICB9XG4gIGNsb25lZC5hcHBlbmRDaGlsZChjaGlsZENsb25lZCk7XG59XG5hc3luYyBmdW5jdGlvbiBjbG9uZUNoaWxkTm9kZXMobm9kZSwgY2xvbmVkLCBjb250ZXh0LCBhZGRXb3JkVG9Gb250RmFtaWxpZXMpIHtcbiAgbGV0IGZpcnN0Q2hpbGQgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gIGlmIChpc0VsZW1lbnROb2RlKG5vZGUpKSB7XG4gICAgaWYgKG5vZGUuc2hhZG93Um9vdCkge1xuICAgICAgZmlyc3RDaGlsZCA9IG5vZGUuc2hhZG93Um9vdD8uZmlyc3RDaGlsZDtcbiAgICAgIGNvbnRleHQuc2hhZG93Um9vdHMucHVzaChub2RlLnNoYWRvd1Jvb3QpO1xuICAgIH1cbiAgfVxuICBmb3IgKGxldCBjaGlsZCA9IGZpcnN0Q2hpbGQ7IGNoaWxkOyBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nKSB7XG4gICAgaWYgKGlzQ29tbWVudE5vZGUoY2hpbGQpKVxuICAgICAgY29udGludWU7XG4gICAgaWYgKGlzRWxlbWVudE5vZGUoY2hpbGQpICYmIGlzU2xvdEVsZW1lbnQoY2hpbGQpICYmIHR5cGVvZiBjaGlsZC5hc3NpZ25lZE5vZGVzID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGNvbnN0IG5vZGVzID0gY2hpbGQuYXNzaWduZWROb2RlcygpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBhd2FpdCBhcHBlbmRDaGlsZE5vZGUobm9kZSwgY2xvbmVkLCBub2Rlc1tpXSwgY29udGV4dCwgYWRkV29yZFRvRm9udEZhbWlsaWVzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYXdhaXQgYXBwZW5kQ2hpbGROb2RlKG5vZGUsIGNsb25lZCwgY2hpbGQsIGNvbnRleHQsIGFkZFdvcmRUb0ZvbnRGYW1pbGllcyk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiByZXN0b3JlU2Nyb2xsUG9zaXRpb24obm9kZSwgY2hsaWRDbG9uZWQpIHtcbiAgaWYgKCFpc0hUTUxFbGVtZW50Tm9kZShub2RlKSB8fCAhaXNIVE1MRWxlbWVudE5vZGUoY2hsaWRDbG9uZWQpKVxuICAgIHJldHVybjtcbiAgY29uc3QgeyBzY3JvbGxUb3AsIHNjcm9sbExlZnQgfSA9IG5vZGU7XG4gIGlmICghc2Nyb2xsVG9wICYmICFzY3JvbGxMZWZ0KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHsgdHJhbnNmb3JtIH0gPSBjaGxpZENsb25lZC5zdHlsZTtcbiAgY29uc3QgbWF0cml4ID0gbmV3IERPTU1hdHJpeCh0cmFuc2Zvcm0pO1xuICBjb25zdCB7IGEsIGIsIGMsIGQgfSA9IG1hdHJpeDtcbiAgbWF0cml4LmEgPSAxO1xuICBtYXRyaXguYiA9IDA7XG4gIG1hdHJpeC5jID0gMDtcbiAgbWF0cml4LmQgPSAxO1xuICBtYXRyaXgudHJhbnNsYXRlU2VsZigtc2Nyb2xsTGVmdCwgLXNjcm9sbFRvcCk7XG4gIG1hdHJpeC5hID0gYTtcbiAgbWF0cml4LmIgPSBiO1xuICBtYXRyaXguYyA9IGM7XG4gIG1hdHJpeC5kID0gZDtcbiAgY2hsaWRDbG9uZWQuc3R5bGUudHJhbnNmb3JtID0gbWF0cml4LnRvU3RyaW5nKCk7XG59XG5mdW5jdGlvbiBhcHBseUNzc1N0eWxlV2l0aE9wdGlvbnMoY2xvbmVkLCBjb250ZXh0KSB7XG4gIGNvbnN0IHsgYmFja2dyb3VuZENvbG9yLCB3aWR0aCwgaGVpZ2h0LCBzdHlsZTogc3R5bGVzIH0gPSBjb250ZXh0O1xuICBjb25zdCBjbG9uZWRTdHlsZSA9IGNsb25lZC5zdHlsZTtcbiAgaWYgKGJhY2tncm91bmRDb2xvcilcbiAgICBjbG9uZWRTdHlsZS5zZXRQcm9wZXJ0eShcImJhY2tncm91bmQtY29sb3JcIiwgYmFja2dyb3VuZENvbG9yLCBcImltcG9ydGFudFwiKTtcbiAgaWYgKHdpZHRoKVxuICAgIGNsb25lZFN0eWxlLnNldFByb3BlcnR5KFwid2lkdGhcIiwgYCR7d2lkdGh9cHhgLCBcImltcG9ydGFudFwiKTtcbiAgaWYgKGhlaWdodClcbiAgICBjbG9uZWRTdHlsZS5zZXRQcm9wZXJ0eShcImhlaWdodFwiLCBgJHtoZWlnaHR9cHhgLCBcImltcG9ydGFudFwiKTtcbiAgaWYgKHN0eWxlcykge1xuICAgIGZvciAoY29uc3QgbmFtZSBpbiBzdHlsZXMpIGNsb25lZFN0eWxlW25hbWVdID0gc3R5bGVzW25hbWVdO1xuICB9XG59XG5jb25zdCBOT1JNQUxfQVRUUklCVVRFX1JFID0gL15bXFx3LTpdKyQvO1xuYXN5bmMgZnVuY3Rpb24gY2xvbmVOb2RlKG5vZGUsIGNvbnRleHQsIGlzUm9vdCA9IGZhbHNlLCBhZGRXb3JkVG9Gb250RmFtaWxpZXMpIHtcbiAgY29uc3QgeyBvd25lckRvY3VtZW50LCBvd25lcldpbmRvdywgZm9udEZhbWlsaWVzLCBvbkNsb25lRWFjaE5vZGUgfSA9IGNvbnRleHQ7XG4gIGlmIChvd25lckRvY3VtZW50ICYmIGlzVGV4dE5vZGUobm9kZSkpIHtcbiAgICBpZiAoYWRkV29yZFRvRm9udEZhbWlsaWVzICYmIC9cXFMvLnRlc3Qobm9kZS5kYXRhKSkge1xuICAgICAgYWRkV29yZFRvRm9udEZhbWlsaWVzKG5vZGUuZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiBvd25lckRvY3VtZW50LmNyZWF0ZVRleHROb2RlKG5vZGUuZGF0YSk7XG4gIH1cbiAgaWYgKG93bmVyRG9jdW1lbnQgJiYgb3duZXJXaW5kb3cgJiYgaXNFbGVtZW50Tm9kZShub2RlKSAmJiAoaXNIVE1MRWxlbWVudE5vZGUobm9kZSkgfHwgaXNTVkdFbGVtZW50Tm9kZShub2RlKSkpIHtcbiAgICBjb25zdCBjbG9uZWQyID0gYXdhaXQgY2xvbmVFbGVtZW50KG5vZGUsIGNvbnRleHQpO1xuICAgIGlmIChjb250ZXh0LmlzRW5hYmxlKFwicmVtb3ZlQWJub3JtYWxBdHRyaWJ1dGVzXCIpKSB7XG4gICAgICBjb25zdCBuYW1lcyA9IGNsb25lZDIuZ2V0QXR0cmlidXRlTmFtZXMoKTtcbiAgICAgIGZvciAobGV0IGxlbiA9IG5hbWVzLmxlbmd0aCwgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBjb25zdCBuYW1lID0gbmFtZXNbaV07XG4gICAgICAgIGlmICghTk9STUFMX0FUVFJJQlVURV9SRS50ZXN0KG5hbWUpKSB7XG4gICAgICAgICAgY2xvbmVkMi5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgc3R5bGUgPSBjb250ZXh0LmN1cnJlbnROb2RlU3R5bGUgPSBjb3B5Q3NzU3R5bGVzKG5vZGUsIGNsb25lZDIsIGlzUm9vdCwgY29udGV4dCk7XG4gICAgaWYgKGlzUm9vdClcbiAgICAgIGFwcGx5Q3NzU3R5bGVXaXRoT3B0aW9ucyhjbG9uZWQyLCBjb250ZXh0KTtcbiAgICBsZXQgY29weVNjcm9sbGJhciA9IGZhbHNlO1xuICAgIGlmIChjb250ZXh0LmlzRW5hYmxlKFwiY29weVNjcm9sbGJhclwiKSkge1xuICAgICAgY29uc3Qgb3ZlcmZsb3cgPSBbXG4gICAgICAgIHN0eWxlLmdldChcIm92ZXJmbG93LXhcIik/LlswXSxcbiAgICAgICAgc3R5bGUuZ2V0KFwib3ZlcmZsb3cteVwiKT8uWzBdXG4gICAgICBdO1xuICAgICAgY29weVNjcm9sbGJhciA9IG92ZXJmbG93LmluY2x1ZGVzKFwic2Nyb2xsXCIpIHx8IChvdmVyZmxvdy5pbmNsdWRlcyhcImF1dG9cIikgfHwgb3ZlcmZsb3cuaW5jbHVkZXMoXCJvdmVybGF5XCIpKSAmJiAobm9kZS5zY3JvbGxIZWlnaHQgPiBub2RlLmNsaWVudEhlaWdodCB8fCBub2RlLnNjcm9sbFdpZHRoID4gbm9kZS5jbGllbnRXaWR0aCk7XG4gICAgfVxuICAgIGNvbnN0IHRleHRUcmFuc2Zvcm0gPSBzdHlsZS5nZXQoXCJ0ZXh0LXRyYW5zZm9ybVwiKT8uWzBdO1xuICAgIGNvbnN0IGZhbWlsaWVzID0gc3BsaXRGb250RmFtaWx5KHN0eWxlLmdldChcImZvbnQtZmFtaWx5XCIpPy5bMF0pO1xuICAgIGNvbnN0IGFkZFdvcmRUb0ZvbnRGYW1pbGllczIgPSBmYW1pbGllcyA/ICh3b3JkKSA9PiB7XG4gICAgICBpZiAodGV4dFRyYW5zZm9ybSA9PT0gXCJ1cHBlcmNhc2VcIikge1xuICAgICAgICB3b3JkID0gd29yZC50b1VwcGVyQ2FzZSgpO1xuICAgICAgfSBlbHNlIGlmICh0ZXh0VHJhbnNmb3JtID09PSBcImxvd2VyY2FzZVwiKSB7XG4gICAgICAgIHdvcmQgPSB3b3JkLnRvTG93ZXJDYXNlKCk7XG4gICAgICB9IGVsc2UgaWYgKHRleHRUcmFuc2Zvcm0gPT09IFwiY2FwaXRhbGl6ZVwiKSB7XG4gICAgICAgIHdvcmQgPSB3b3JkWzBdLnRvVXBwZXJDYXNlKCkgKyB3b3JkLnN1YnN0cmluZygxKTtcbiAgICAgIH1cbiAgICAgIGZhbWlsaWVzLmZvckVhY2goKGZhbWlseSkgPT4ge1xuICAgICAgICBsZXQgZm9udEZhbWlseSA9IGZvbnRGYW1pbGllcy5nZXQoZmFtaWx5KTtcbiAgICAgICAgaWYgKCFmb250RmFtaWx5KSB7XG4gICAgICAgICAgZm9udEZhbWlsaWVzLnNldChmYW1pbHksIGZvbnRGYW1pbHkgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKTtcbiAgICAgICAgfVxuICAgICAgICB3b3JkLnNwbGl0KFwiXCIpLmZvckVhY2goKHRleHQpID0+IGZvbnRGYW1pbHkuYWRkKHRleHQpKTtcbiAgICAgIH0pO1xuICAgIH0gOiB2b2lkIDA7XG4gICAgY29weVBzZXVkb0NsYXNzKFxuICAgICAgbm9kZSxcbiAgICAgIGNsb25lZDIsXG4gICAgICBjb3B5U2Nyb2xsYmFyLFxuICAgICAgY29udGV4dCxcbiAgICAgIGFkZFdvcmRUb0ZvbnRGYW1pbGllczJcbiAgICApO1xuICAgIGNvcHlJbnB1dFZhbHVlKG5vZGUsIGNsb25lZDIpO1xuICAgIGlmICghaXNWaWRlb0VsZW1lbnQobm9kZSkpIHtcbiAgICAgIGF3YWl0IGNsb25lQ2hpbGROb2RlcyhcbiAgICAgICAgbm9kZSxcbiAgICAgICAgY2xvbmVkMixcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgYWRkV29yZFRvRm9udEZhbWlsaWVzMlxuICAgICAgKTtcbiAgICB9XG4gICAgYXdhaXQgb25DbG9uZUVhY2hOb2RlPy4oY2xvbmVkMik7XG4gICAgcmV0dXJuIGNsb25lZDI7XG4gIH1cbiAgY29uc3QgY2xvbmVkID0gbm9kZS5jbG9uZU5vZGUoZmFsc2UpO1xuICBhd2FpdCBjbG9uZUNoaWxkTm9kZXMobm9kZSwgY2xvbmVkLCBjb250ZXh0KTtcbiAgYXdhaXQgb25DbG9uZUVhY2hOb2RlPy4oY2xvbmVkKTtcbiAgcmV0dXJuIGNsb25lZDtcbn1cblxuZnVuY3Rpb24gZGVzdHJveUNvbnRleHQoY29udGV4dCkge1xuICBjb250ZXh0Lm93bmVyRG9jdW1lbnQgPSB2b2lkIDA7XG4gIGNvbnRleHQub3duZXJXaW5kb3cgPSB2b2lkIDA7XG4gIGNvbnRleHQuc3ZnU3R5bGVFbGVtZW50ID0gdm9pZCAwO1xuICBjb250ZXh0LnN2Z0RlZnNFbGVtZW50ID0gdm9pZCAwO1xuICBjb250ZXh0LnN2Z1N0eWxlcy5jbGVhcigpO1xuICBjb250ZXh0LmRlZmF1bHRDb21wdXRlZFN0eWxlcy5jbGVhcigpO1xuICBpZiAoY29udGV4dC5zYW5kYm94KSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnRleHQuc2FuZGJveC5yZW1vdmUoKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnRleHQubG9nLndhcm4oXCJGYWlsZWQgdG8gZGVzdHJveUNvbnRleHRcIiwgZXJyKTtcbiAgICB9XG4gICAgY29udGV4dC5zYW5kYm94ID0gdm9pZCAwO1xuICB9XG4gIGNvbnRleHQud29ya2VycyA9IFtdO1xuICBjb250ZXh0LmZvbnRGYW1pbGllcy5jbGVhcigpO1xuICBjb250ZXh0LmZvbnRDc3NUZXh0cy5jbGVhcigpO1xuICBjb250ZXh0LnJlcXVlc3RzLmNsZWFyKCk7XG4gIGNvbnRleHQudGFza3MgPSBbXTtcbiAgY29udGV4dC5zaGFkb3dSb290cyA9IFtdO1xufVxuXG5mdW5jdGlvbiBiYXNlRmV0Y2gob3B0aW9ucykge1xuICBjb25zdCB7IHVybCwgdGltZW91dCwgcmVzcG9uc2VUeXBlLCAuLi5yZXF1ZXN0SW5pdCB9ID0gb3B0aW9ucztcbiAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgY29uc3QgdGltZXIgPSB0aW1lb3V0ID8gc2V0VGltZW91dCgoKSA9PiBjb250cm9sbGVyLmFib3J0KCksIHRpbWVvdXQpIDogdm9pZCAwO1xuICByZXR1cm4gZmV0Y2godXJsLCB7IHNpZ25hbDogY29udHJvbGxlci5zaWduYWwsIC4uLnJlcXVlc3RJbml0IH0pLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIGZldGNoLCBub3QgMnh4IHJlc3BvbnNlXCIsIHsgY2F1c2U6IHJlc3BvbnNlIH0pO1xuICAgIH1cbiAgICBzd2l0Y2ggKHJlc3BvbnNlVHlwZSkge1xuICAgICAgY2FzZSBcImFycmF5QnVmZmVyXCI6XG4gICAgICAgIHJldHVybiByZXNwb25zZS5hcnJheUJ1ZmZlcigpO1xuICAgICAgY2FzZSBcImRhdGFVcmxcIjpcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmJsb2IoKS50aGVuKGJsb2JUb0RhdGFVcmwpO1xuICAgICAgY2FzZSBcInRleHRcIjpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiByZXNwb25zZS50ZXh0KCk7XG4gICAgfVxuICB9KS5maW5hbGx5KCgpID0+IGNsZWFyVGltZW91dCh0aW1lcikpO1xufVxuZnVuY3Rpb24gY29udGV4dEZldGNoKGNvbnRleHQsIG9wdGlvbnMpIHtcbiAgY29uc3QgeyB1cmw6IHJhd1VybCwgcmVxdWVzdFR5cGUgPSBcInRleHRcIiwgcmVzcG9uc2VUeXBlID0gXCJ0ZXh0XCIsIGltYWdlRG9tIH0gPSBvcHRpb25zO1xuICBsZXQgdXJsID0gcmF3VXJsO1xuICBjb25zdCB7XG4gICAgdGltZW91dCxcbiAgICBhY2NlcHRPZkltYWdlLFxuICAgIHJlcXVlc3RzLFxuICAgIGZldGNoRm4sXG4gICAgZmV0Y2g6IHtcbiAgICAgIHJlcXVlc3RJbml0LFxuICAgICAgYnlwYXNzaW5nQ2FjaGUsXG4gICAgICBwbGFjZWhvbGRlckltYWdlXG4gICAgfSxcbiAgICBmb250LFxuICAgIHdvcmtlcnMsXG4gICAgZm9udEZhbWlsaWVzXG4gIH0gPSBjb250ZXh0O1xuICBpZiAocmVxdWVzdFR5cGUgPT09IFwiaW1hZ2VcIiAmJiAoSU5fU0FGQVJJIHx8IElOX0ZJUkVGT1gpKSB7XG4gICAgY29udGV4dC5kcmF3SW1hZ2VDb3VudCsrO1xuICB9XG4gIGxldCByZXF1ZXN0ID0gcmVxdWVzdHMuZ2V0KHJhd1VybCk7XG4gIGlmICghcmVxdWVzdCkge1xuICAgIGlmIChieXBhc3NpbmdDYWNoZSkge1xuICAgICAgaWYgKGJ5cGFzc2luZ0NhY2hlIGluc3RhbmNlb2YgUmVnRXhwICYmIGJ5cGFzc2luZ0NhY2hlLnRlc3QodXJsKSkge1xuICAgICAgICB1cmwgKz0gKC9cXD8vLnRlc3QodXJsKSA/IFwiJlwiIDogXCI/XCIpICsgKC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGNhbkZvbnRNaW5pZnkgPSByZXF1ZXN0VHlwZS5zdGFydHNXaXRoKFwiZm9udFwiKSAmJiBmb250ICYmIGZvbnQubWluaWZ5O1xuICAgIGNvbnN0IGZvbnRUZXh0cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgaWYgKGNhbkZvbnRNaW5pZnkpIHtcbiAgICAgIGNvbnN0IGZhbWlsaWVzID0gcmVxdWVzdFR5cGUuc3BsaXQoXCI7XCIpWzFdLnNwbGl0KFwiLFwiKTtcbiAgICAgIGZhbWlsaWVzLmZvckVhY2goKGZhbWlseSkgPT4ge1xuICAgICAgICBpZiAoIWZvbnRGYW1pbGllcy5oYXMoZmFtaWx5KSlcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGZvbnRGYW1pbGllcy5nZXQoZmFtaWx5KS5mb3JFYWNoKCh0ZXh0KSA9PiBmb250VGV4dHMuYWRkKHRleHQpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBuZWVkRm9udE1pbmlmeSA9IGNhbkZvbnRNaW5pZnkgJiYgZm9udFRleHRzLnNpemU7XG4gICAgY29uc3QgYmFzZUZldGNoT3B0aW9ucyA9IHtcbiAgICAgIHVybCxcbiAgICAgIHRpbWVvdXQsXG4gICAgICByZXNwb25zZVR5cGU6IG5lZWRGb250TWluaWZ5ID8gXCJhcnJheUJ1ZmZlclwiIDogcmVzcG9uc2VUeXBlLFxuICAgICAgaGVhZGVyczogcmVxdWVzdFR5cGUgPT09IFwiaW1hZ2VcIiA/IHsgYWNjZXB0OiBhY2NlcHRPZkltYWdlIH0gOiB2b2lkIDAsXG4gICAgICAuLi5yZXF1ZXN0SW5pdFxuICAgIH07XG4gICAgcmVxdWVzdCA9IHtcbiAgICAgIHR5cGU6IHJlcXVlc3RUeXBlLFxuICAgICAgcmVzb2x2ZTogdm9pZCAwLFxuICAgICAgcmVqZWN0OiB2b2lkIDAsXG4gICAgICByZXNwb25zZTogbnVsbFxuICAgIH07XG4gICAgcmVxdWVzdC5yZXNwb25zZSA9IChhc3luYyAoKSA9PiB7XG4gICAgICBpZiAoZmV0Y2hGbiAmJiByZXF1ZXN0VHlwZSA9PT0gXCJpbWFnZVwiKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGZldGNoRm4ocmF3VXJsKTtcbiAgICAgICAgaWYgKHJlc3VsdClcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgaWYgKCFJTl9TQUZBUkkgJiYgcmF3VXJsLnN0YXJ0c1dpdGgoXCJodHRwXCIpICYmIHdvcmtlcnMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgY29uc3Qgd29ya2VyID0gd29ya2Vyc1tyZXF1ZXN0cy5zaXplICYgd29ya2Vycy5sZW5ndGggLSAxXTtcbiAgICAgICAgICB3b3JrZXIucG9zdE1lc3NhZ2UoeyByYXdVcmwsIC4uLmJhc2VGZXRjaE9wdGlvbnMgfSk7XG4gICAgICAgICAgcmVxdWVzdC5yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgICByZXF1ZXN0LnJlamVjdCA9IHJlamVjdDtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUZldGNoKGJhc2VGZXRjaE9wdGlvbnMpO1xuICAgIH0pKCkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICByZXF1ZXN0cy5kZWxldGUocmF3VXJsKTtcbiAgICAgIGlmIChyZXF1ZXN0VHlwZSA9PT0gXCJpbWFnZVwiICYmIHBsYWNlaG9sZGVySW1hZ2UpIHtcbiAgICAgICAgY29udGV4dC5sb2cud2FybihcIkZhaWxlZCB0byBmZXRjaCBpbWFnZSBiYXNlNjQsIHRyeWluZyB0byB1c2UgcGxhY2Vob2xkZXIgaW1hZ2VcIiwgdXJsKTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBwbGFjZWhvbGRlckltYWdlID09PSBcInN0cmluZ1wiID8gcGxhY2Vob2xkZXJJbWFnZSA6IHBsYWNlaG9sZGVySW1hZ2UoaW1hZ2VEb20pO1xuICAgICAgfVxuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfSk7XG4gICAgcmVxdWVzdHMuc2V0KHJhd1VybCwgcmVxdWVzdCk7XG4gIH1cbiAgcmV0dXJuIHJlcXVlc3QucmVzcG9uc2U7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJlcGxhY2VDc3NVcmxUb0RhdGFVcmwoY3NzVGV4dCwgYmFzZVVybCwgY29udGV4dCwgaXNJbWFnZSkge1xuICBpZiAoIWhhc0Nzc1VybChjc3NUZXh0KSlcbiAgICByZXR1cm4gY3NzVGV4dDtcbiAgZm9yIChjb25zdCBbcmF3VXJsLCB1cmxdIG9mIHBhcnNlQ3NzVXJscyhjc3NUZXh0LCBiYXNlVXJsKSkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkYXRhVXJsID0gYXdhaXQgY29udGV4dEZldGNoKFxuICAgICAgICBjb250ZXh0LFxuICAgICAgICB7XG4gICAgICAgICAgdXJsLFxuICAgICAgICAgIHJlcXVlc3RUeXBlOiBpc0ltYWdlID8gXCJpbWFnZVwiIDogXCJ0ZXh0XCIsXG4gICAgICAgICAgcmVzcG9uc2VUeXBlOiBcImRhdGFVcmxcIlxuICAgICAgICB9XG4gICAgICApO1xuICAgICAgY3NzVGV4dCA9IGNzc1RleHQucmVwbGFjZSh0b1JFKHJhd1VybCksIGAkMSR7ZGF0YVVybH0kM2ApO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb250ZXh0LmxvZy53YXJuKFwiRmFpbGVkIHRvIGZldGNoIGNzcyBkYXRhIHVybFwiLCByYXdVcmwsIGVycm9yKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNzc1RleHQ7XG59XG5mdW5jdGlvbiBoYXNDc3NVcmwoY3NzVGV4dCkge1xuICByZXR1cm4gL3VybFxcKChbJ1wiXT8pKFteJ1wiXSs/KVxcMVxcKS8udGVzdChjc3NUZXh0KTtcbn1cbmNvbnN0IFVSTF9SRSA9IC91cmxcXCgoWydcIl0/KShbXidcIl0rPylcXDFcXCkvZztcbmZ1bmN0aW9uIHBhcnNlQ3NzVXJscyhjc3NUZXh0LCBiYXNlVXJsKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBjc3NUZXh0LnJlcGxhY2UoVVJMX1JFLCAocmF3LCBxdW90YXRpb24sIHVybCkgPT4ge1xuICAgIHJlc3VsdC5wdXNoKFt1cmwsIHJlc29sdmVVcmwodXJsLCBiYXNlVXJsKV0pO1xuICAgIHJldHVybiByYXc7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0LmZpbHRlcigoW3VybF0pID0+ICFpc0RhdGFVcmwodXJsKSk7XG59XG5mdW5jdGlvbiB0b1JFKHVybCkge1xuICBjb25zdCBlc2NhcGVkID0gdXJsLnJlcGxhY2UoLyhbLiorP14ke30oKXxcXFtcXF1cXC9cXFxcXSkvZywgXCJcXFxcJDFcIik7XG4gIHJldHVybiBuZXcgUmVnRXhwKGAodXJsXFxcXChbJ1wiXT8pKCR7ZXNjYXBlZH0pKFsnXCJdP1xcXFwpKWAsIFwiZ1wiKTtcbn1cblxuY29uc3QgcHJvcGVydGllcyA9IFtcbiAgXCJiYWNrZ3JvdW5kLWltYWdlXCIsXG4gIFwiYm9yZGVyLWltYWdlLXNvdXJjZVwiLFxuICBcIi13ZWJraXQtYm9yZGVyLWltYWdlXCIsXG4gIFwiLXdlYmtpdC1tYXNrLWltYWdlXCIsXG4gIFwibGlzdC1zdHlsZS1pbWFnZVwiXG5dO1xuZnVuY3Rpb24gZW1iZWRDc3NTdHlsZUltYWdlKHN0eWxlLCBjb250ZXh0KSB7XG4gIHJldHVybiBwcm9wZXJ0aWVzLm1hcCgocHJvcGVydHkpID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IHN0eWxlLmdldFByb3BlcnR5VmFsdWUocHJvcGVydHkpO1xuICAgIGlmICghdmFsdWUgfHwgdmFsdWUgPT09IFwibm9uZVwiKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKElOX1NBRkFSSSB8fCBJTl9GSVJFRk9YKSB7XG4gICAgICBjb250ZXh0LmRyYXdJbWFnZUNvdW50Kys7XG4gICAgfVxuICAgIHJldHVybiByZXBsYWNlQ3NzVXJsVG9EYXRhVXJsKHZhbHVlLCBudWxsLCBjb250ZXh0LCB0cnVlKS50aGVuKChuZXdWYWx1ZSkgPT4ge1xuICAgICAgaWYgKCFuZXdWYWx1ZSB8fCB2YWx1ZSA9PT0gbmV3VmFsdWUpXG4gICAgICAgIHJldHVybjtcbiAgICAgIHN0eWxlLnNldFByb3BlcnR5KFxuICAgICAgICBwcm9wZXJ0eSxcbiAgICAgICAgbmV3VmFsdWUsXG4gICAgICAgIHN0eWxlLmdldFByb3BlcnR5UHJpb3JpdHkocHJvcGVydHkpXG4gICAgICApO1xuICAgIH0pO1xuICB9KS5maWx0ZXIoQm9vbGVhbik7XG59XG5cbmZ1bmN0aW9uIGVtYmVkSW1hZ2VFbGVtZW50KGNsb25lZCwgY29udGV4dCkge1xuICBpZiAoaXNJbWFnZUVsZW1lbnQoY2xvbmVkKSkge1xuICAgIGNvbnN0IG9yaWdpbmFsU3JjID0gY2xvbmVkLmN1cnJlbnRTcmMgfHwgY2xvbmVkLnNyYztcbiAgICBpZiAoIWlzRGF0YVVybChvcmlnaW5hbFNyYykpIHtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIGNvbnRleHRGZXRjaChjb250ZXh0LCB7XG4gICAgICAgICAgdXJsOiBvcmlnaW5hbFNyYyxcbiAgICAgICAgICBpbWFnZURvbTogY2xvbmVkLFxuICAgICAgICAgIHJlcXVlc3RUeXBlOiBcImltYWdlXCIsXG4gICAgICAgICAgcmVzcG9uc2VUeXBlOiBcImRhdGFVcmxcIlxuICAgICAgICB9KS50aGVuKCh1cmwpID0+IHtcbiAgICAgICAgICBpZiAoIXVybClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBjbG9uZWQuc3Jjc2V0ID0gXCJcIjtcbiAgICAgICAgICBjbG9uZWQuZGF0YXNldC5vcmlnaW5hbFNyYyA9IG9yaWdpbmFsU3JjO1xuICAgICAgICAgIGNsb25lZC5zcmMgPSB1cmwgfHwgXCJcIjtcbiAgICAgICAgfSlcbiAgICAgIF07XG4gICAgfVxuICAgIGlmIChJTl9TQUZBUkkgfHwgSU5fRklSRUZPWCkge1xuICAgICAgY29udGV4dC5kcmF3SW1hZ2VDb3VudCsrO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc1NWR0VsZW1lbnROb2RlKGNsb25lZCkgJiYgIWlzRGF0YVVybChjbG9uZWQuaHJlZi5iYXNlVmFsKSkge1xuICAgIGNvbnN0IG9yaWdpbmFsU3JjID0gY2xvbmVkLmhyZWYuYmFzZVZhbDtcbiAgICByZXR1cm4gW1xuICAgICAgY29udGV4dEZldGNoKGNvbnRleHQsIHtcbiAgICAgICAgdXJsOiBvcmlnaW5hbFNyYyxcbiAgICAgICAgaW1hZ2VEb206IGNsb25lZCxcbiAgICAgICAgcmVxdWVzdFR5cGU6IFwiaW1hZ2VcIixcbiAgICAgICAgcmVzcG9uc2VUeXBlOiBcImRhdGFVcmxcIlxuICAgICAgfSkudGhlbigodXJsKSA9PiB7XG4gICAgICAgIGlmICghdXJsKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY2xvbmVkLmRhdGFzZXQub3JpZ2luYWxTcmMgPSBvcmlnaW5hbFNyYztcbiAgICAgICAgY2xvbmVkLmhyZWYuYmFzZVZhbCA9IHVybCB8fCBcIlwiO1xuICAgICAgfSlcbiAgICBdO1xuICB9XG4gIHJldHVybiBbXTtcbn1cblxuZnVuY3Rpb24gZW1iZWRTdmdVc2UoY2xvbmVkLCBjb250ZXh0KSB7XG4gIGNvbnN0IHsgb3duZXJEb2N1bWVudCwgc3ZnRGVmc0VsZW1lbnQgfSA9IGNvbnRleHQ7XG4gIGNvbnN0IGhyZWYgPSBjbG9uZWQuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSA/PyBjbG9uZWQuZ2V0QXR0cmlidXRlKFwieGxpbms6aHJlZlwiKTtcbiAgaWYgKCFocmVmKVxuICAgIHJldHVybiBbXTtcbiAgY29uc3QgW3N2Z1VybCwgaWRdID0gaHJlZi5zcGxpdChcIiNcIik7XG4gIGlmIChpZCkge1xuICAgIGNvbnN0IHF1ZXJ5ID0gYCMke2lkfWA7XG4gICAgY29uc3QgZGVmaW5pdGlvbiA9IGNvbnRleHQuc2hhZG93Um9vdHMucmVkdWNlKFxuICAgICAgKHJlcywgcm9vdCkgPT4ge1xuICAgICAgICByZXR1cm4gcmVzID8/IHJvb3QucXVlcnlTZWxlY3Rvcihgc3ZnICR7cXVlcnl9YCk7XG4gICAgICB9LFxuICAgICAgb3duZXJEb2N1bWVudD8ucXVlcnlTZWxlY3Rvcihgc3ZnICR7cXVlcnl9YClcbiAgICApO1xuICAgIGlmIChzdmdVcmwpIHtcbiAgICAgIGNsb25lZC5zZXRBdHRyaWJ1dGUoXCJocmVmXCIsIHF1ZXJ5KTtcbiAgICB9XG4gICAgaWYgKHN2Z0RlZnNFbGVtZW50Py5xdWVyeVNlbGVjdG9yKHF1ZXJ5KSlcbiAgICAgIHJldHVybiBbXTtcbiAgICBpZiAoZGVmaW5pdGlvbikge1xuICAgICAgc3ZnRGVmc0VsZW1lbnQ/LmFwcGVuZENoaWxkKGRlZmluaXRpb24uY2xvbmVOb2RlKHRydWUpKTtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9IGVsc2UgaWYgKHN2Z1VybCkge1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgY29udGV4dEZldGNoKGNvbnRleHQsIHtcbiAgICAgICAgICB1cmw6IHN2Z1VybCxcbiAgICAgICAgICByZXNwb25zZVR5cGU6IFwidGV4dFwiXG4gICAgICAgIH0pLnRoZW4oKHN2Z0RhdGEpID0+IHtcbiAgICAgICAgICBzdmdEZWZzRWxlbWVudD8uaW5zZXJ0QWRqYWNlbnRIVE1MKFwiYmVmb3JlZW5kXCIsIHN2Z0RhdGEpO1xuICAgICAgICB9KVxuICAgICAgXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtdO1xufVxuXG5mdW5jdGlvbiBlbWJlZE5vZGUoY2xvbmVkLCBjb250ZXh0KSB7XG4gIGNvbnN0IHsgdGFza3MgfSA9IGNvbnRleHQ7XG4gIGlmIChpc0VsZW1lbnROb2RlKGNsb25lZCkpIHtcbiAgICBpZiAoaXNJbWFnZUVsZW1lbnQoY2xvbmVkKSB8fCBpc1NWR0ltYWdlRWxlbWVudE5vZGUoY2xvbmVkKSkge1xuICAgICAgdGFza3MucHVzaCguLi5lbWJlZEltYWdlRWxlbWVudChjbG9uZWQsIGNvbnRleHQpKTtcbiAgICB9XG4gICAgaWYgKGlzU1ZHVXNlRWxlbWVudE5vZGUoY2xvbmVkKSkge1xuICAgICAgdGFza3MucHVzaCguLi5lbWJlZFN2Z1VzZShjbG9uZWQsIGNvbnRleHQpKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzSFRNTEVsZW1lbnROb2RlKGNsb25lZCkpIHtcbiAgICB0YXNrcy5wdXNoKC4uLmVtYmVkQ3NzU3R5bGVJbWFnZShjbG9uZWQuc3R5bGUsIGNvbnRleHQpKTtcbiAgfVxuICBjbG9uZWQuY2hpbGROb2Rlcy5mb3JFYWNoKChjaGlsZCkgPT4ge1xuICAgIGVtYmVkTm9kZShjaGlsZCwgY29udGV4dCk7XG4gIH0pO1xufVxuXG5hc3luYyBmdW5jdGlvbiBlbWJlZFdlYkZvbnQoY2xvbmUsIGNvbnRleHQpIHtcbiAgY29uc3Qge1xuICAgIG93bmVyRG9jdW1lbnQsXG4gICAgc3ZnU3R5bGVFbGVtZW50LFxuICAgIGZvbnRGYW1pbGllcyxcbiAgICBmb250Q3NzVGV4dHMsXG4gICAgdGFza3MsXG4gICAgZm9udFxuICB9ID0gY29udGV4dDtcbiAgaWYgKCFvd25lckRvY3VtZW50IHx8ICFzdmdTdHlsZUVsZW1lbnQgfHwgIWZvbnRGYW1pbGllcy5zaXplKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChmb250ICYmIGZvbnQuY3NzVGV4dCkge1xuICAgIGNvbnN0IGNzc1RleHQgPSBmaWx0ZXJQcmVmZXJyZWRGb3JtYXQoZm9udC5jc3NUZXh0LCBjb250ZXh0KTtcbiAgICBzdmdTdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQob3duZXJEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShgJHtjc3NUZXh0fVxuYCkpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHN0eWxlU2hlZXRzID0gQXJyYXkuZnJvbShvd25lckRvY3VtZW50LnN0eWxlU2hlZXRzKS5maWx0ZXIoKHN0eWxlU2hlZXQpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBcImNzc1J1bGVzXCIgaW4gc3R5bGVTaGVldCAmJiBCb29sZWFuKHN0eWxlU2hlZXQuY3NzUnVsZXMubGVuZ3RoKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnRleHQubG9nLndhcm4oYEVycm9yIHdoaWxlIHJlYWRpbmcgQ1NTIHJ1bGVzIGZyb20gJHtzdHlsZVNoZWV0LmhyZWZ9YCwgZXJyb3IpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICBzdHlsZVNoZWV0cy5mbGF0TWFwKChzdHlsZVNoZWV0KSA9PiB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHN0eWxlU2hlZXQuY3NzUnVsZXMpLm1hcChhc3luYyAoY3NzUnVsZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICBpZiAoaXNDU1NJbXBvcnRSdWxlKGNzc1J1bGUpKSB7XG4gICAgICAgICAgICBsZXQgaW1wb3J0SW5kZXggPSBpbmRleCArIDE7XG4gICAgICAgICAgICBjb25zdCBiYXNlVXJsID0gY3NzUnVsZS5ocmVmO1xuICAgICAgICAgICAgbGV0IGNzc1RleHQgPSBcIlwiO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY3NzVGV4dCA9IGF3YWl0IGNvbnRleHRGZXRjaChjb250ZXh0LCB7XG4gICAgICAgICAgICAgICAgdXJsOiBiYXNlVXJsLFxuICAgICAgICAgICAgICAgIHJlcXVlc3RUeXBlOiBcInRleHRcIixcbiAgICAgICAgICAgICAgICByZXNwb25zZVR5cGU6IFwidGV4dFwiXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgY29udGV4dC5sb2cud2FybihgRXJyb3IgZmV0Y2ggcmVtb3RlIGNzcyBpbXBvcnQgZnJvbSAke2Jhc2VVcmx9YCwgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVwbGFjZWRDc3NUZXh0ID0gY3NzVGV4dC5yZXBsYWNlKFxuICAgICAgICAgICAgICBVUkxfUkUsXG4gICAgICAgICAgICAgIChyYXcsIHF1b3RhdGlvbiwgdXJsKSA9PiByYXcucmVwbGFjZSh1cmwsIHJlc29sdmVVcmwodXJsLCBiYXNlVXJsKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJ1bGUgb2YgcGFyc2VDc3MocmVwbGFjZWRDc3NUZXh0KSkge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHN0eWxlU2hlZXQuaW5zZXJ0UnVsZShcbiAgICAgICAgICAgICAgICAgIHJ1bGUsXG4gICAgICAgICAgICAgICAgICBydWxlLnN0YXJ0c1dpdGgoXCJAaW1wb3J0XCIpID8gaW1wb3J0SW5kZXggKz0gMSA6IHN0eWxlU2hlZXQuY3NzUnVsZXMubGVuZ3RoXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmxvZy53YXJuKFwiRXJyb3IgaW5zZXJ0aW5nIHJ1bGUgZnJvbSByZW1vdGUgY3NzIGltcG9ydFwiLCB7IHJ1bGUsIGVycm9yIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pXG4gICAgKTtcbiAgICBjb25zdCBjc3NSdWxlcyA9IHN0eWxlU2hlZXRzLmZsYXRNYXAoKHN0eWxlU2hlZXQpID0+IEFycmF5LmZyb20oc3R5bGVTaGVldC5jc3NSdWxlcykpO1xuICAgIGNzc1J1bGVzLmZpbHRlcigoY3NzUnVsZSkgPT4gaXNDc3NGb250RmFjZVJ1bGUoY3NzUnVsZSkgJiYgaGFzQ3NzVXJsKGNzc1J1bGUuc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShcInNyY1wiKSkgJiYgc3BsaXRGb250RmFtaWx5KGNzc1J1bGUuc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShcImZvbnQtZmFtaWx5XCIpKT8uc29tZSgodmFsKSA9PiBmb250RmFtaWxpZXMuaGFzKHZhbCkpKS5mb3JFYWNoKCh2YWx1ZSkgPT4ge1xuICAgICAgY29uc3QgcnVsZSA9IHZhbHVlO1xuICAgICAgY29uc3QgY3NzVGV4dCA9IGZvbnRDc3NUZXh0cy5nZXQocnVsZS5jc3NUZXh0KTtcbiAgICAgIGlmIChjc3NUZXh0KSB7XG4gICAgICAgIHN2Z1N0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChvd25lckRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGAke2Nzc1RleHR9XG5gKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YXNrcy5wdXNoKFxuICAgICAgICAgIHJlcGxhY2VDc3NVcmxUb0RhdGFVcmwoXG4gICAgICAgICAgICBydWxlLmNzc1RleHQsXG4gICAgICAgICAgICBydWxlLnBhcmVudFN0eWxlU2hlZXQgPyBydWxlLnBhcmVudFN0eWxlU2hlZXQuaHJlZiA6IG51bGwsXG4gICAgICAgICAgICBjb250ZXh0XG4gICAgICAgICAgKS50aGVuKChjc3NUZXh0MikgPT4ge1xuICAgICAgICAgICAgY3NzVGV4dDIgPSBmaWx0ZXJQcmVmZXJyZWRGb3JtYXQoY3NzVGV4dDIsIGNvbnRleHQpO1xuICAgICAgICAgICAgZm9udENzc1RleHRzLnNldChydWxlLmNzc1RleHQsIGNzc1RleHQyKTtcbiAgICAgICAgICAgIHN2Z1N0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChvd25lckRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGAke2Nzc1RleHQyfVxuYCkpO1xuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbmNvbnN0IENPTU1FTlRTX1JFID0gLyhcXC9cXCpbXFxzXFxTXSo/XFwqXFwvKS9nO1xuY29uc3QgS0VZRlJBTUVTX1JFID0gLygoQC4qP2tleWZyYW1lcyBbXFxzXFxTXSo/KXsoW1xcc1xcU10qP31cXHMqPyl9KS9naTtcbmZ1bmN0aW9uIHBhcnNlQ3NzKHNvdXJjZSkge1xuICBpZiAoc291cmNlID09IG51bGwpXG4gICAgcmV0dXJuIFtdO1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgbGV0IGNzc1RleHQgPSBzb3VyY2UucmVwbGFjZShDT01NRU5UU19SRSwgXCJcIik7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3QgbWF0Y2hlcyA9IEtFWUZSQU1FU19SRS5leGVjKGNzc1RleHQpO1xuICAgIGlmICghbWF0Y2hlcylcbiAgICAgIGJyZWFrO1xuICAgIHJlc3VsdC5wdXNoKG1hdGNoZXNbMF0pO1xuICB9XG4gIGNzc1RleHQgPSBjc3NUZXh0LnJlcGxhY2UoS0VZRlJBTUVTX1JFLCBcIlwiKTtcbiAgY29uc3QgSU1QT1JUX1JFID0gL0BpbXBvcnRbXFxzXFxTXSo/dXJsXFwoW14pXSpcXClbXFxzXFxTXSo/Oy9naTtcbiAgY29uc3QgVU5JRklFRF9SRSA9IG5ldyBSZWdFeHAoXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgXCIoKFxcXFxzKj8oPzpcXFxcL1xcXFwqW1xcXFxzXFxcXFNdKj9cXFxcKlxcXFwvKT9cXFxccyo/QG1lZGlhW1xcXFxzXFxcXFNdKj8peyhbXFxcXHNcXFxcU10qPyl9XFxcXHMqP30pfCgoW1xcXFxzXFxcXFNdKj8peyhbXFxcXHNcXFxcU10qPyl9KVwiLFxuICAgIFwiZ2lcIlxuICApO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGxldCBtYXRjaGVzID0gSU1QT1JUX1JFLmV4ZWMoY3NzVGV4dCk7XG4gICAgaWYgKCFtYXRjaGVzKSB7XG4gICAgICBtYXRjaGVzID0gVU5JRklFRF9SRS5leGVjKGNzc1RleHQpO1xuICAgICAgaWYgKCFtYXRjaGVzKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgSU1QT1JUX1JFLmxhc3RJbmRleCA9IFVOSUZJRURfUkUubGFzdEluZGV4O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBVTklGSUVEX1JFLmxhc3RJbmRleCA9IElNUE9SVF9SRS5sYXN0SW5kZXg7XG4gICAgfVxuICAgIHJlc3VsdC5wdXNoKG1hdGNoZXNbMF0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5jb25zdCBVUkxfV0lUSF9GT1JNQVRfUkUgPSAvdXJsXFwoW14pXStcXClcXHMqZm9ybWF0XFwoKFtcIiddPykoW15cIiddKylcXDFcXCkvZztcbmNvbnN0IEZPTlRfU1JDX1JFID0gL3NyYzpcXHMqKD86dXJsXFwoW14pXStcXClcXHMqZm9ybWF0XFwoW14pXStcXClbLDtdXFxzKikrL2c7XG5mdW5jdGlvbiBmaWx0ZXJQcmVmZXJyZWRGb3JtYXQoc3RyLCBjb250ZXh0KSB7XG4gIGNvbnN0IHsgZm9udCB9ID0gY29udGV4dDtcbiAgY29uc3QgcHJlZmVycmVkRm9ybWF0ID0gZm9udCA/IGZvbnQ/LnByZWZlcnJlZEZvcm1hdCA6IHZvaWQgMDtcbiAgcmV0dXJuIHByZWZlcnJlZEZvcm1hdCA/IHN0ci5yZXBsYWNlKEZPTlRfU1JDX1JFLCAobWF0Y2gpID0+IHtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgY29uc3QgW3NyYywgLCBmb3JtYXRdID0gVVJMX1dJVEhfRk9STUFUX1JFLmV4ZWMobWF0Y2gpIHx8IFtdO1xuICAgICAgaWYgKCFmb3JtYXQpXG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgaWYgKGZvcm1hdCA9PT0gcHJlZmVycmVkRm9ybWF0KVxuICAgICAgICByZXR1cm4gYHNyYzogJHtzcmN9O2A7XG4gICAgfVxuICB9KSA6IHN0cjtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZG9tVG9Gb3JlaWduT2JqZWN0U3ZnKG5vZGUsIG9wdGlvbnMpIHtcbiAgY29uc3QgY29udGV4dCA9IGF3YWl0IG9yQ3JlYXRlQ29udGV4dChub2RlLCBvcHRpb25zKTtcbiAgaWYgKGlzRWxlbWVudE5vZGUoY29udGV4dC5ub2RlKSAmJiBpc1NWR0VsZW1lbnROb2RlKGNvbnRleHQubm9kZSkpXG4gICAgcmV0dXJuIGNvbnRleHQubm9kZTtcbiAgY29uc3Qge1xuICAgIG93bmVyRG9jdW1lbnQsXG4gICAgbG9nLFxuICAgIHRhc2tzLFxuICAgIHN2Z1N0eWxlRWxlbWVudCxcbiAgICBzdmdEZWZzRWxlbWVudCxcbiAgICBzdmdTdHlsZXMsXG4gICAgZm9udCxcbiAgICBwcm9ncmVzcyxcbiAgICBhdXRvRGVzdHJ1Y3QsXG4gICAgb25DbG9uZU5vZGUsXG4gICAgb25FbWJlZE5vZGUsXG4gICAgb25DcmVhdGVGb3JlaWduT2JqZWN0U3ZnXG4gIH0gPSBjb250ZXh0O1xuICBsb2cudGltZShcImNsb25lIG5vZGVcIik7XG4gIGNvbnN0IGNsb25lID0gYXdhaXQgY2xvbmVOb2RlKGNvbnRleHQubm9kZSwgY29udGV4dCwgdHJ1ZSk7XG4gIGlmIChzdmdTdHlsZUVsZW1lbnQgJiYgb3duZXJEb2N1bWVudCkge1xuICAgIGxldCBhbGxDc3NUZXh0ID0gXCJcIjtcbiAgICBzdmdTdHlsZXMuZm9yRWFjaCgoa2xhc3NlcywgY3NzVGV4dCkgPT4ge1xuICAgICAgYWxsQ3NzVGV4dCArPSBgJHtrbGFzc2VzLmpvaW4oXCIsXFxuXCIpfSB7XG4gICR7Y3NzVGV4dH1cbn1cbmA7XG4gICAgfSk7XG4gICAgc3ZnU3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKG93bmVyRG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoYWxsQ3NzVGV4dCkpO1xuICB9XG4gIGxvZy50aW1lRW5kKFwiY2xvbmUgbm9kZVwiKTtcbiAgYXdhaXQgb25DbG9uZU5vZGU/LihjbG9uZSk7XG4gIGlmIChmb250ICE9PSBmYWxzZSAmJiBpc0VsZW1lbnROb2RlKGNsb25lKSkge1xuICAgIGxvZy50aW1lKFwiZW1iZWQgd2ViIGZvbnRcIik7XG4gICAgYXdhaXQgZW1iZWRXZWJGb250KGNsb25lLCBjb250ZXh0KTtcbiAgICBsb2cudGltZUVuZChcImVtYmVkIHdlYiBmb250XCIpO1xuICB9XG4gIGxvZy50aW1lKFwiZW1iZWQgbm9kZVwiKTtcbiAgZW1iZWROb2RlKGNsb25lLCBjb250ZXh0KTtcbiAgY29uc3QgY291bnQgPSB0YXNrcy5sZW5ndGg7XG4gIGxldCBjdXJyZW50ID0gMDtcbiAgY29uc3QgcnVuVGFzayA9IGFzeW5jICgpID0+IHtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgY29uc3QgdGFzayA9IHRhc2tzLnBvcCgpO1xuICAgICAgaWYgKCF0YXNrKVxuICAgICAgICBicmVhaztcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHRhc2s7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb250ZXh0LmxvZy53YXJuKFwiRmFpbGVkIHRvIHJ1biB0YXNrXCIsIGVycm9yKTtcbiAgICAgIH1cbiAgICAgIHByb2dyZXNzPy4oKytjdXJyZW50LCBjb3VudCk7XG4gICAgfVxuICB9O1xuICBwcm9ncmVzcz8uKGN1cnJlbnQsIGNvdW50KTtcbiAgYXdhaXQgUHJvbWlzZS5hbGwoWy4uLkFycmF5LmZyb20oeyBsZW5ndGg6IDQgfSldLm1hcChydW5UYXNrKSk7XG4gIGxvZy50aW1lRW5kKFwiZW1iZWQgbm9kZVwiKTtcbiAgYXdhaXQgb25FbWJlZE5vZGU/LihjbG9uZSk7XG4gIGNvbnN0IHN2ZyA9IGNyZWF0ZUZvcmVpZ25PYmplY3RTdmcoY2xvbmUsIGNvbnRleHQpO1xuICBzdmdEZWZzRWxlbWVudCAmJiBzdmcuaW5zZXJ0QmVmb3JlKHN2Z0RlZnNFbGVtZW50LCBzdmcuY2hpbGRyZW5bMF0pO1xuICBzdmdTdHlsZUVsZW1lbnQgJiYgc3ZnLmluc2VydEJlZm9yZShzdmdTdHlsZUVsZW1lbnQsIHN2Zy5jaGlsZHJlblswXSk7XG4gIGF1dG9EZXN0cnVjdCAmJiBkZXN0cm95Q29udGV4dChjb250ZXh0KTtcbiAgYXdhaXQgb25DcmVhdGVGb3JlaWduT2JqZWN0U3ZnPy4oc3ZnKTtcbiAgcmV0dXJuIHN2Zztcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZvcmVpZ25PYmplY3RTdmcoY2xvbmUsIGNvbnRleHQpIHtcbiAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBjb250ZXh0O1xuICBjb25zdCBzdmcgPSBjcmVhdGVTdmcod2lkdGgsIGhlaWdodCwgY2xvbmUub3duZXJEb2N1bWVudCk7XG4gIGNvbnN0IGZvcmVpZ25PYmplY3QgPSBzdmcub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoc3ZnLm5hbWVzcGFjZVVSSSwgXCJmb3JlaWduT2JqZWN0XCIpO1xuICBmb3JlaWduT2JqZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieFwiLCBcIjAlXCIpO1xuICBmb3JlaWduT2JqZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieVwiLCBcIjAlXCIpO1xuICBmb3JlaWduT2JqZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwid2lkdGhcIiwgXCIxMDAlXCIpO1xuICBmb3JlaWduT2JqZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiaGVpZ2h0XCIsIFwiMTAwJVwiKTtcbiAgZm9yZWlnbk9iamVjdC5hcHBlbmQoY2xvbmUpO1xuICBzdmcuYXBwZW5kQ2hpbGQoZm9yZWlnbk9iamVjdCk7XG4gIHJldHVybiBzdmc7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGRvbVRvQ2FudmFzKG5vZGUsIG9wdGlvbnMpIHtcbiAgY29uc3QgY29udGV4dCA9IGF3YWl0IG9yQ3JlYXRlQ29udGV4dChub2RlLCBvcHRpb25zKTtcbiAgY29uc3Qgc3ZnID0gYXdhaXQgZG9tVG9Gb3JlaWduT2JqZWN0U3ZnKGNvbnRleHQpO1xuICBjb25zdCBkYXRhVXJsID0gc3ZnVG9EYXRhVXJsKHN2ZywgY29udGV4dC5pc0VuYWJsZShcInJlbW92ZUNvbnRyb2xDaGFyYWN0ZXJcIikpO1xuICBpZiAoIWNvbnRleHQuYXV0b0Rlc3RydWN0KSB7XG4gICAgY29udGV4dC5zdmdTdHlsZUVsZW1lbnQgPSBjcmVhdGVTdHlsZUVsZW1lbnQoY29udGV4dC5vd25lckRvY3VtZW50KTtcbiAgICBjb250ZXh0LnN2Z0RlZnNFbGVtZW50ID0gY29udGV4dC5vd25lckRvY3VtZW50Py5jcmVhdGVFbGVtZW50TlMoWE1MTlMsIFwiZGVmc1wiKTtcbiAgICBjb250ZXh0LnN2Z1N0eWxlcy5jbGVhcigpO1xuICB9XG4gIGNvbnN0IGltYWdlID0gY3JlYXRlSW1hZ2UoZGF0YVVybCwgc3ZnLm93bmVyRG9jdW1lbnQpO1xuICByZXR1cm4gYXdhaXQgaW1hZ2VUb0NhbnZhcyhpbWFnZSwgY29udGV4dCk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGRvbVRvQmxvYihub2RlLCBvcHRpb25zKSB7XG4gIGNvbnN0IGNvbnRleHQgPSBhd2FpdCBvckNyZWF0ZUNvbnRleHQobm9kZSwgb3B0aW9ucyk7XG4gIGNvbnN0IHsgbG9nLCB0eXBlLCBxdWFsaXR5LCBkcGkgfSA9IGNvbnRleHQ7XG4gIGNvbnN0IGNhbnZhcyA9IGF3YWl0IGRvbVRvQ2FudmFzKGNvbnRleHQpO1xuICBsb2cudGltZShcImNhbnZhcyB0byBibG9iXCIpO1xuICBjb25zdCBibG9iID0gYXdhaXQgY2FudmFzVG9CbG9iKGNhbnZhcywgdHlwZSwgcXVhbGl0eSk7XG4gIGlmIChbXCJpbWFnZS9wbmdcIiwgXCJpbWFnZS9qcGVnXCJdLmluY2x1ZGVzKHR5cGUpICYmIGRwaSkge1xuICAgIGNvbnN0IGFycmF5QnVmZmVyID0gYXdhaXQgYmxvYlRvQXJyYXlCdWZmZXIoYmxvYi5zbGljZSgwLCAzMykpO1xuICAgIGxldCB1aW50OEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpO1xuICAgIGlmICh0eXBlID09PSBcImltYWdlL3BuZ1wiKSB7XG4gICAgICB1aW50OEFycmF5ID0gY2hhbmdlUG5nRHBpKHVpbnQ4QXJyYXksIGRwaSk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBcImltYWdlL2pwZWdcIikge1xuICAgICAgdWludDhBcnJheSA9IGNoYW5nZUpwZWdEcGkodWludDhBcnJheSwgZHBpKTtcbiAgICB9XG4gICAgbG9nLnRpbWVFbmQoXCJjYW52YXMgdG8gYmxvYlwiKTtcbiAgICByZXR1cm4gbmV3IEJsb2IoW3VpbnQ4QXJyYXksIGJsb2Iuc2xpY2UoMzMpXSwgeyB0eXBlIH0pO1xuICB9XG4gIGxvZy50aW1lRW5kKFwiY2FudmFzIHRvIGJsb2JcIik7XG4gIHJldHVybiBibG9iO1xufVxuXG5hc3luYyBmdW5jdGlvbiBkb21Ub0RhdGFVcmwobm9kZSwgb3B0aW9ucykge1xuICBjb25zdCBjb250ZXh0ID0gYXdhaXQgb3JDcmVhdGVDb250ZXh0KG5vZGUsIG9wdGlvbnMpO1xuICBjb25zdCB7IGxvZywgcXVhbGl0eSwgdHlwZSwgZHBpIH0gPSBjb250ZXh0O1xuICBjb25zdCBjYW52YXMgPSBhd2FpdCBkb21Ub0NhbnZhcyhjb250ZXh0KTtcbiAgbG9nLnRpbWUoXCJjYW52YXMgdG8gZGF0YSB1cmxcIik7XG4gIGxldCBkYXRhVXJsID0gY2FudmFzLnRvRGF0YVVSTCh0eXBlLCBxdWFsaXR5KTtcbiAgaWYgKFtcImltYWdlL3BuZ1wiLCBcImltYWdlL2pwZWdcIl0uaW5jbHVkZXModHlwZSkgJiYgZHBpICYmIFNVUFBPUlRfQVRPQiAmJiBTVVBQT1JUX0JUT0EpIHtcbiAgICBjb25zdCBbZm9ybWF0LCBib2R5XSA9IGRhdGFVcmwuc3BsaXQoXCIsXCIpO1xuICAgIGxldCBoZWFkZXJMZW5ndGggPSAwO1xuICAgIGxldCBvdmVyd3JpdGVwSFlzID0gZmFsc2U7XG4gICAgaWYgKHR5cGUgPT09IFwiaW1hZ2UvcG5nXCIpIHtcbiAgICAgIGNvbnN0IGI2NEluZGV4ID0gZGV0ZWN0UGh5c0NodW5rRnJvbURhdGFVcmwoYm9keSk7XG4gICAgICBpZiAoYjY0SW5kZXggPj0gMCkge1xuICAgICAgICBoZWFkZXJMZW5ndGggPSBNYXRoLmNlaWwoKGI2NEluZGV4ICsgMjgpIC8gMykgKiA0O1xuICAgICAgICBvdmVyd3JpdGVwSFlzID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhlYWRlckxlbmd0aCA9IDMzIC8gMyAqIDQ7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBcImltYWdlL2pwZWdcIikge1xuICAgICAgaGVhZGVyTGVuZ3RoID0gMTggLyAzICogNDtcbiAgICB9XG4gICAgY29uc3Qgc3RyaW5nSGVhZGVyID0gYm9keS5zdWJzdHJpbmcoMCwgaGVhZGVyTGVuZ3RoKTtcbiAgICBjb25zdCByZXN0T2ZEYXRhID0gYm9keS5zdWJzdHJpbmcoaGVhZGVyTGVuZ3RoKTtcbiAgICBjb25zdCBoZWFkZXJCeXRlcyA9IHdpbmRvdy5hdG9iKHN0cmluZ0hlYWRlcik7XG4gICAgY29uc3QgdWludDhBcnJheSA9IG5ldyBVaW50OEFycmF5KGhlYWRlckJ5dGVzLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB1aW50OEFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB1aW50OEFycmF5W2ldID0gaGVhZGVyQnl0ZXMuY2hhckNvZGVBdChpKTtcbiAgICB9XG4gICAgY29uc3QgZmluYWxBcnJheSA9IHR5cGUgPT09IFwiaW1hZ2UvcG5nXCIgPyBjaGFuZ2VQbmdEcGkodWludDhBcnJheSwgZHBpLCBvdmVyd3JpdGVwSFlzKSA6IGNoYW5nZUpwZWdEcGkodWludDhBcnJheSwgZHBpKTtcbiAgICBjb25zdCBiYXNlNjRIZWFkZXIgPSB3aW5kb3cuYnRvYShTdHJpbmcuZnJvbUNoYXJDb2RlKC4uLmZpbmFsQXJyYXkpKTtcbiAgICBkYXRhVXJsID0gW2Zvcm1hdCwgXCIsXCIsIGJhc2U2NEhlYWRlciwgcmVzdE9mRGF0YV0uam9pbihcIlwiKTtcbiAgfVxuICBsb2cudGltZUVuZChcImNhbnZhcyB0byBkYXRhIHVybFwiKTtcbiAgcmV0dXJuIGRhdGFVcmw7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGRvbVRvU3ZnKG5vZGUsIG9wdGlvbnMpIHtcbiAgY29uc3QgY29udGV4dCA9IGF3YWl0IG9yQ3JlYXRlQ29udGV4dChub2RlLCBvcHRpb25zKTtcbiAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0LCBvd25lckRvY3VtZW50IH0gPSBjb250ZXh0O1xuICBjb25zdCBkYXRhVXJsID0gYXdhaXQgZG9tVG9EYXRhVXJsKGNvbnRleHQpO1xuICBjb25zdCBzdmcgPSBjcmVhdGVTdmcod2lkdGgsIGhlaWdodCwgb3duZXJEb2N1bWVudCk7XG4gIGNvbnN0IHN2Z0ltYWdlID0gc3ZnLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHN2Zy5uYW1lc3BhY2VVUkksIFwiaW1hZ2VcIik7XG4gIHN2Z0ltYWdlLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiaHJlZlwiLCBkYXRhVXJsKTtcbiAgc3ZnSW1hZ2Uuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJoZWlnaHRcIiwgXCIxMDAlXCIpO1xuICBzdmdJbWFnZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcIndpZHRoXCIsIFwiMTAwJVwiKTtcbiAgc3ZnLmFwcGVuZENoaWxkKHN2Z0ltYWdlKTtcbiAgcmV0dXJuIHN2Z1RvRGF0YVVybChzdmcsIGNvbnRleHQuaXNFbmFibGUoXCJyZW1vdmVDb250cm9sQ2hhcmFjdGVyXCIpKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZG9tVG9JbWFnZShub2RlLCBvcHRpb25zKSB7XG4gIGNvbnN0IGNvbnRleHQgPSBhd2FpdCBvckNyZWF0ZUNvbnRleHQobm9kZSwgb3B0aW9ucyk7XG4gIGNvbnN0IHsgb3duZXJEb2N1bWVudCwgd2lkdGgsIGhlaWdodCwgc2NhbGUsIHR5cGUgfSA9IGNvbnRleHQ7XG4gIGNvbnN0IHVybCA9IHR5cGUgPT09IFwiaW1hZ2Uvc3ZnK3htbFwiID8gYXdhaXQgZG9tVG9TdmcoY29udGV4dCkgOiBhd2FpdCBkb21Ub0RhdGFVcmwoY29udGV4dCk7XG4gIGNvbnN0IGltYWdlID0gY3JlYXRlSW1hZ2UodXJsLCBvd25lckRvY3VtZW50KTtcbiAgaW1hZ2Uud2lkdGggPSBNYXRoLmZsb29yKHdpZHRoICogc2NhbGUpO1xuICBpbWFnZS5oZWlnaHQgPSBNYXRoLmZsb29yKGhlaWdodCAqIHNjYWxlKTtcbiAgaW1hZ2Uuc3R5bGUud2lkdGggPSBgJHt3aWR0aH1weGA7XG4gIGltYWdlLnN0eWxlLmhlaWdodCA9IGAke2hlaWdodH1weGA7XG4gIHJldHVybiBpbWFnZTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZG9tVG9KcGVnKG5vZGUsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGRvbVRvRGF0YVVybChcbiAgICBhd2FpdCBvckNyZWF0ZUNvbnRleHQobm9kZSwgeyAuLi5vcHRpb25zLCB0eXBlOiBcImltYWdlL2pwZWdcIiB9KVxuICApO1xufVxuXG5hc3luYyBmdW5jdGlvbiBkb21Ub1BpeGVsKG5vZGUsIG9wdGlvbnMpIHtcbiAgY29uc3QgY29udGV4dCA9IGF3YWl0IG9yQ3JlYXRlQ29udGV4dChub2RlLCBvcHRpb25zKTtcbiAgY29uc3QgY2FudmFzID0gYXdhaXQgZG9tVG9DYW52YXMoY29udGV4dCk7XG4gIHJldHVybiBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpLmdldEltYWdlRGF0YSgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpLmRhdGE7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGRvbVRvUG5nKG5vZGUsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGRvbVRvRGF0YVVybChcbiAgICBhd2FpdCBvckNyZWF0ZUNvbnRleHQobm9kZSwgeyAuLi5vcHRpb25zLCB0eXBlOiBcImltYWdlL3BuZ1wiIH0pXG4gICk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGRvbVRvV2VicChub2RlLCBvcHRpb25zKSB7XG4gIHJldHVybiBkb21Ub0RhdGFVcmwoXG4gICAgYXdhaXQgb3JDcmVhdGVDb250ZXh0KG5vZGUsIHsgLi4ub3B0aW9ucywgdHlwZTogXCJpbWFnZS93ZWJwXCIgfSlcbiAgKTtcbn1cblxuZXhwb3J0IHsgY3JlYXRlQ29udGV4dCwgZGVzdHJveUNvbnRleHQsIGRvbVRvQmxvYiwgZG9tVG9DYW52YXMsIGRvbVRvRGF0YVVybCwgZG9tVG9Gb3JlaWduT2JqZWN0U3ZnLCBkb21Ub0ltYWdlLCBkb21Ub0pwZWcsIGRvbVRvUGl4ZWwsIGRvbVRvUG5nLCBkb21Ub1N2ZywgZG9tVG9XZWJwLCBsb2FkTWVkaWEsIHdhaXRVbnRpbExvYWQgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/modern-screenshot/dist/index.mjs\n"));

/***/ })

}]);